<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="今天主要刷leetcode的滑动窗口的题目，需要完成如下题目，本文主要记录解题思路和方法，以便加深理解记忆，答案到处都是，只有消化了才是自己的。\n">
<title>滑动窗口技巧</title>

<link rel='canonical' href='https://blog.bugxch.top/p/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7/'>

<link rel="stylesheet" href="/scss/style.min.abbd69b2908fdfcd5179898beaafd374514a86538d81639ddd2c58c06ae54e40.css"><meta property='og:title' content="滑动窗口技巧">
<meta property='og:description' content="今天主要刷leetcode的滑动窗口的题目，需要完成如下题目，本文主要记录解题思路和方法，以便加深理解记忆，答案到处都是，只有消化了才是自己的。\n">
<meta property='og:url' content='https://blog.bugxch.top/p/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7/'>
<meta property='og:site_name' content='巴巴变的博客'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='sliding window' /><meta property='article:published_time' content='2020-08-02T15:40:45&#43;08:00'/><meta property='article:modified_time' content='2020-08-02T15:40:45&#43;08:00'/>
<meta name="twitter:title" content="滑动窗口技巧">
<meta name="twitter:description" content="今天主要刷leetcode的滑动窗口的题目，需要完成如下题目，本文主要记录解题思路和方法，以便加深理解记忆，答案到处都是，只有消化了才是自己的。\n">
    <link rel="shortcut icon" href="/%5cfavicon.ico" />

  

<style>
    :root {
      --sys-font-family: "Noto Serif SC";
      --zh-font-family: "Noto Serif SC";
      --base-font-family: "Noto Serif SC";
      --code-font-family: "Noto Serif SC";
      --article-font-family: "Noto Serif SC";
    }
  </style>
  
  <script>
    (function () {
      const customFont = document.createElement("link");
      customFont.href =
        "https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap";
  
      customFont.type = "text/css";
      customFont.rel = "stylesheet";
  
      document.head.appendChild(customFont);
    })();
  </script>
  
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hue8037ab3c5772f21a937200919ce7a89_163234_300x0_resize_box_3.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">巴巴变的博客</a></h1>
            <h2 class="site-description">平凡的生活也值得记录</h2>
        </div>
    </header><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E6%94%B6%E9%9B%86/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>收集</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    

            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E6%8A%80%E8%89%BA/" >
                技艺
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7/">滑动窗口技巧</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Aug 02, 2020</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 8 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <p>今天主要刷leetcode的滑动窗口的题目，需要完成如下题目，本文主要记录解题思路和方法，以便加深理解记忆，答案到处都是，只有消化了才是自己的。</p>
<p><img src="https://www.cxyxiaowu.com/wp-content/uploads/2020/04/1587885580-7ad02b4170d7e1a.jpeg"
	
	
	
	loading="lazy"
	
	
></p>
<h2 id="引子">引子
</h2><p>首先来看leetcode中No. 3的<strong>无重复字符的最长子串</strong>这个题目，参考<a class="link" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/"  target="_blank" rel="noopener"
    >题目链接</a>，题目很简单</p>
<blockquote>
<p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>输入: <span style="color:#e6db74">&#34;abcabcbb&#34;</span>
</span></span><span style="display:flex;"><span>输出: <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>解释: 因为无重复字符的最长子串是 <span style="color:#e6db74">&#34;abc&#34;</span>，所以其长度为 3。
</span></span></code></pre></div><p>拿到题目的第一反应就是暴力解法，</p>
<ol>
<li>
<p>先暴力穷举所有的子串$S_i = [S[left], S[right])$；</p>
</li>
<li>
<p>判断这个子串，如果不含重复字符就记录子串长度$l_i$，此处判断是否有重复字串的时间复杂度是$O(n)$；</p>
</li>
<li>
<p>找出所有记录的子串长度的最大值$max_i{l_i}$。
一段伪代码如下，</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> maxlen <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; left <span style="color:#f92672">&lt;</span> S.length(); left<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> left <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; right <span style="color:#f92672">&lt;</span> S.length(); right<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">if</span>(window[left, right) contain <span style="color:#960050;background-color:#1e0010">重复字符</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">if</span>(right <span style="color:#f92672">-</span> left <span style="color:#f92672">&gt;</span> maxlen) {
</span></span><span style="display:flex;"><span>         maxlen <span style="color:#f92672">=</span> right <span style="color:#f92672">-</span>left;
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> maxlen;
</span></span></code></pre></div><p>很明显，该方法的时间复杂度是$O(n^3)$，非常费时。这个算法的复杂度主要来自于第一步，仔细想想那个子串伪代码中的第3行有点问题，伪代码可以看作我们用一个窗口截取所有子串，left表示窗口的左边界（包含），right表示窗口的右边界（不包含），如果窗口中含有重复子串，那么不应该继续扩展右边界的，所以right不能一直向右<strong>扩展</strong>，此时应该向右移动左边界，<strong>缩小</strong>窗口的长度。以示例中给出的字符串为例，参考下面的示意图</p>
<p><img src="https://raw.githubusercontent.com/bugxch/blogpics/master/202008/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20200802171014.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>所以我们有一个更通用的实现框架。</p>
<h2 id="通用框架">通用框架
</h2><p>维护一个<strong>滑动窗口</strong>，</p>
<blockquote>
<ol>
<li>窗口的边界是$[left, right)$，刚开始窗口的长度为0，即left = right = 0；</li>
<li>维护一个哈希表table，用于记录窗口中的字符的统计情况，比如上面的图一中就<code>table['a'] = 2, table['b'] = 1, table['c'] = 1</code>；</li>
<li>窗口可<strong>扩展</strong>可<strong>收缩</strong>，</li>
</ol>
<ul>
<li>如果当前窗口中没有重复字符，则窗口扩展，<code>right++</code>，更新哈希表；</li>
<li>如果当前窗口中有重复字符，那么窗口收缩，<code>left++</code>，更新哈希表；</li>
</ul>
<ol start="4">
<li>直到<code>right</code>超过需要遍历的字符串的边界为止。</li>
</ol>
</blockquote>
<p>需要注意，上面的扩展和收缩的时机，对于当前的这个程序，如何判断当前的窗口中是否有重复字符呢？一般的想法是遍历每个键的值，如果有大于1的值就认为有重复字符，而且是在窗口位置发生变化的时候触发遍历动作。其实，这里有一个小技巧，<strong>键值只有在向右扩展的时候才会增长</strong>，刚开始窗口是没有键的，或者即便有也只能是1，所以在窗口扩展的时候，只要去查看新加入的<code>right</code>位置的字符的键值是否超过1即可。通过以上分析，我们有了下面的新的伪代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, right <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> maxlen <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (right <span style="color:#f92672">&lt;</span> s.size()) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 增大窗口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    window.add(s[right]);
</span></span><span style="display:flex;"><span>    right<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(window doesnot contain repeat charactor) {
</span></span><span style="display:flex;"><span>        maxlen <span style="color:#f92672">=</span> max(maxlen, right <span style="color:#f92672">-</span> left);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (window needs shrink) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 缩小窗口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        window.remove(s[left]);
</span></span><span style="display:flex;"><span>        left<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> maxlen;
</span></span></code></pre></div><p>将上面的伪代码翻译成最后的c++代码，列示如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lengthOfLongestSubstring</span>(string s)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxlen <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> window;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (right <span style="color:#f92672">&lt;</span> s.length())
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> rch <span style="color:#f92672">=</span> s[right];
</span></span><span style="display:flex;"><span>        right<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        window[rch]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (window[rch] <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            maxlen <span style="color:#f92672">=</span> max(maxlen, right <span style="color:#f92672">-</span> left);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (window[rch] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> lch <span style="color:#f92672">=</span> s[left];
</span></span><span style="display:flex;"><span>                left<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                window[lch]<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> maxlen;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="类似题目">类似题目
</h2><p>下面使用上面的框架解答一下其他的滑动窗口的类似题目</p>
<h3 id="最小覆盖子串---力扣leetcode">最小覆盖子串 - 力扣（LeetCode）
</h3><p>题目见<a class="link" href="https://leetcode-cn.com/problems/minimum-window-substring/"  target="_blank" rel="noopener"
    >76. 最小覆盖子串 - 力扣（LeetCode）</a>：给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p>
<p>示例：</p>
<blockquote>
<p><strong>输入:</strong> S = &ldquo;ADOBECODEBANC&rdquo;, T = &ldquo;ABC&rdquo;
<strong>输出:</strong> &ldquo;BANC&rdquo;</p>
</blockquote>
<p>也是同样的做法，但是需要搞清楚几个问题</p>
<h4 id="何时扩展窗口">何时扩展窗口？
</h4><p>如果窗口中没有将所有的T中的字符包含，那么向右扩展窗口。</p>
<h4 id="何时更新长度">何时更新长度？
</h4><p>扩展窗口之后，检查窗口的字符集合。如果当前窗口包含了所有的T中的字符，那么更新子串的起始位置id及长度。</p>
<h4 id="何时缩减窗口">何时缩减窗口？
</h4><p>更新长度之后，窗口的左端右移，缩减窗口。于是有了下面的代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// No. 76
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>string <span style="color:#a6e22e">minWindow</span>(string s, string t)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> startId <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> rightId <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> minLen <span style="color:#f92672">=</span> s.length() <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, right <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span>  matchCount <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// record the only need characters
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> window;
</span></span><span style="display:flex;"><span>    unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> need;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> ch : t)
</span></span><span style="display:flex;"><span>        need[ch]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (right <span style="color:#f92672">&lt;</span> s.length())
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> rch <span style="color:#f92672">=</span> s[right];
</span></span><span style="display:flex;"><span>        right<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (need.count(rch)) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// expand window
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            window[rch]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (window[rch] <span style="color:#f92672">==</span> need[rch]) {
</span></span><span style="display:flex;"><span>                matchCount<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// shrink the window
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (matchCount <span style="color:#f92672">==</span> need.size())
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (right <span style="color:#f92672">-</span> left <span style="color:#f92672">&lt;</span> minLen)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                startId <span style="color:#f92672">=</span> left;
</span></span><span style="display:flex;"><span>                rightId <span style="color:#f92672">=</span> right;
</span></span><span style="display:flex;"><span>                minLen <span style="color:#f92672">=</span> right <span style="color:#f92672">-</span> left;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> lch <span style="color:#f92672">=</span> s[left];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (need.count(lch)) {
</span></span><span style="display:flex;"><span>                window[lch]<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (window[lch] <span style="color:#f92672">&lt;</span> need[lch]) {
</span></span><span style="display:flex;"><span>                    matchCount<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            left<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> rightId <span style="color:#f92672">-</span> startId <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">?</span> s.substr(startId, rightId <span style="color:#f92672">-</span> startId) <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面的写法中，需要注意几个问题</p>
<ol>
<li><code>window</code>仅仅记录了<code>[left, right)</code>的子串中的出现在need窗口中的字符的情况，并没有对窗口中所有的字符都做统计，其实也没有必要做，因为我们并不关心其他的字符；</li>
<li><code>minLen</code>用来记录最短的子串长度，刚开始初始化为字符串的长度+1；</li>
<li>我们用<code>matchCount</code>标记匹配的字符的个数，如果匹配了一个字符就加一，否则减一，匹配的标准是该字符的出现次数在window中<strong>不少于</strong>在need中出现的次数。注意，这个<strong>参数在扩展窗口时增加，在缩减窗口时减少</strong>，增加或减少之后即刻与need比较判断。</li>
</ol>
<h3 id="424-替换后的最长重复字符">424. 替换后的最长重复字符
</h3><p>题目见<a class="link" href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/"  target="_blank" rel="noopener"
    >424. 替换后的最长重复字符 - 力扣（LeetCode）</a>，题目也比较简单，维护滑动窗口，每次在扩展窗口时候检查当前的窗口中的最多的字符的个数与替换的数量k的和是否大于等于窗口的长度？</p>
<ol>
<li>如果是，则更新窗口的长度，窗口继续扩展；</li>
<li>如果否，则缩减窗口的长度；</li>
</ol>
<p>循环往复，直到窗口的右边界超过了字符串的长度。代码如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> characterReplacement(string s, <span style="color:#66d9ef">int</span> k) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> maxLen <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, right <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> window;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (right <span style="color:#f92672">&lt;</span> s.length()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> rch <span style="color:#f92672">=</span> s[right];
</span></span><span style="display:flex;"><span>            window[rch]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            right<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// find max count char
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> maxCount <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> iter <span style="color:#f92672">=</span> window.begin(); iter <span style="color:#f92672">!=</span> window.end(); iter<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                maxCount <span style="color:#f92672">=</span> max(maxCount, iter<span style="color:#f92672">-&gt;</span>second);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (maxCount <span style="color:#f92672">+</span> k <span style="color:#f92672">&gt;=</span> right <span style="color:#f92672">-</span> left) {
</span></span><span style="display:flex;"><span>                maxLen <span style="color:#f92672">=</span> max(right <span style="color:#f92672">-</span> left, maxLen);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> lch <span style="color:#f92672">=</span> s[left];
</span></span><span style="display:flex;"><span>                window[lch]<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>                left<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> maxLen;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="1004-最大连续1的个数-iii">1004. 最大连续1的个数 III
</h3><p>题目见<a class="link" href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/"  target="_blank" rel="noopener"
    >1004. 最大连续1的个数 III - 力扣（LeetCode）</a>，与上一题目类似，直接看代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> longestOnes(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> A, <span style="color:#66d9ef">int</span> K) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> maxLen <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, right <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> window;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (right <span style="color:#f92672">&lt;</span> A.size()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> rnum <span style="color:#f92672">=</span> A[right];
</span></span><span style="display:flex;"><span>            window[rnum]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            right<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (window[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> K <span style="color:#f92672">&gt;=</span> right <span style="color:#f92672">-</span> left) {
</span></span><span style="display:flex;"><span>                maxLen <span style="color:#f92672">=</span> max(right <span style="color:#f92672">-</span> left, maxLen);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> lnum <span style="color:#f92672">=</span> A[left];
</span></span><span style="display:flex;"><span>                window[lnum]<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>                left<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> maxLen;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>可以看出这个代码与上一题目非常相似，通用框架都是默认扩展窗口，如果不满足某些条件再缩减窗口。</p>
<h3 id="992-k个不同整数的数组">992. K个不同整数的数组
</h3><p>题目见<a class="link" href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/"  target="_blank" rel="noopener"
    >992. K 个不同整数的子数组 - 力扣（LeetCode）</a>，这个比上面的两道题要复杂点，两次使用双指针解决，基本思路是：</p>
<ol>
<li>维护像之前一样的滑动窗口，如果当前的窗口不满足条件，那么向右扩张；</li>
<li>如果窗口满足条件了，停止向右扩张，右边界不变，左边界向右移动（收缩窗口），开始计算满足条件的窗口数目。注意，这里的动作，在满足条件的窗口上再开一个滑动窗口，但是该窗口的右边界不变，不停右移左边界，遍历满足条件的总数；</li>
<li>如此这般往复循环，直到滑动窗口的右边缘到达字符串的右边界为止。</li>
</ol>
<p>我第一次提交的代码如下，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">subarraysWithKDistinct</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> A, <span style="color:#66d9ef">int</span> K) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, right <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> window;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (right <span style="color:#f92672">&lt;</span> A.size()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> rnum <span style="color:#f92672">=</span> A[right];
</span></span><span style="display:flex;"><span>            window[rnum]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            right<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 如果当前的窗口中超过了K个不同的整数，那么需要缩小左边缘（即窗口左移）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span> (window.size() <span style="color:#f92672">&gt;</span> K) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> lnum <span style="color:#f92672">=</span> A[left];
</span></span><span style="display:flex;"><span>                window[lnum]<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (window[lnum] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                    window.erase(lnum);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                left<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 当前的窗口有K个不同的整数，移动左边缘，遍历所有满足条件的窗口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (window.size() <span style="color:#f92672">==</span> K) {
</span></span><span style="display:flex;"><span>                unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> subWindow(window);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> tmpLeft <span style="color:#f92672">=</span> left;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">while</span> (subWindow.size() <span style="color:#f92672">==</span> K) {
</span></span><span style="display:flex;"><span>                    count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                    subWindow[A[tmpLeft]]<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (subWindow[A[tmpLeft]] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                        subWindow.erase(A[tmpLeft]);
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    tmpLeft<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> count;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>计算结果正确，但是超时了，仔细想想，其实不需要在创建一个subWindow窗口，可以复用原来的窗口，但是遍历完毕需要记得恢复，适当修改代码如下，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">subarraysWithKDistinct</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> A, <span style="color:#66d9ef">int</span> K) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, right <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> window;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (right <span style="color:#f92672">&lt;</span> A.size()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> rnum <span style="color:#f92672">=</span> A[right];
</span></span><span style="display:flex;"><span>            window[rnum]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            right<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (window.size() <span style="color:#f92672">&gt;</span> K) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> lnum <span style="color:#f92672">=</span> A[left];
</span></span><span style="display:flex;"><span>                window[lnum]<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (window[lnum] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                    window.erase(lnum);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                left<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> tmpLeft <span style="color:#f92672">=</span> left;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (window.size() <span style="color:#f92672">==</span> K) {
</span></span><span style="display:flex;"><span>                count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                window[A[tmpLeft]]<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (window[A[tmpLeft]] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                    window.erase(A[tmpLeft]);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                tmpLeft<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// recover the window
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span> (tmpLeft <span style="color:#f92672">&gt;</span> left) {
</span></span><span style="display:flex;"><span>                window[A[tmpLeft<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>                tmpLeft<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> count;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="数据结构">数据结构
</h2><h3 id="哈希表">哈希表
</h3><p>上面的示例都用到了哈希表，又称为散列表，具体的定义可以参考<a class="link" href="https://www.wikiwand.com/zh/%E5%93%88%E5%B8%8C%E8%A1%A8"  target="_blank" rel="noopener"
    >哈希表</a>。与一般的顺序访问的数组等数据结构不同，哈希表将查询的数据映射到表中的位置来记录，加快了查询的速度（类似于数组的下表和数组的值的映射关系）。一般而言，哈希表的查询，插入和删除的性能是$O(1)$。</p>
<h3 id="c-stl-中的哈希表">C++ STL 中的哈希表
</h3><p>C++在stl中使用<code>unordered_map</code>的数据结构保存哈希表，基本的用法如下所示</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// C++ program to demonstrate functionality of unordered_map
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unordered_map&gt;</span><span style="color:#75715e">  </span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Declaring umap to be of &lt;string, int&gt; type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// key will be of string type and mapped value will
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// be of double type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	unordered_map<span style="color:#f92672">&lt;</span>string, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> umap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// inserting values by using [] operator
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	umap[<span style="color:#e6db74">&#34;GeeksforGeeks&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>	umap[<span style="color:#e6db74">&#34;Practice&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span>	umap[<span style="color:#e6db74">&#34;Contribute&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Traversing an unordered map
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> x : umap)
</span></span><span style="display:flex;"><span>	cout <span style="color:#f92672">&lt;&lt;</span> x.first <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> x.second <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>创建一个哈希表格，在哈希表中添加“键-值”对。</p>
<ul>
<li>
<p><code>unordered_map</code>和<code>unordered_set</code>有什么区别？</p>
<p><code>unordered_set</code>中只保存了键，主要用于查看某元素是否在集合中，不能保存每个键出现的次数。</p>
</li>
<li>
<p><code>unordered_map</code>和<code>map</code>有什么区别？</p>
<ol>
<li>
<p><code>map</code>中的键值是按序保存的，但是<code>unorederd_map</code>的键值是无序保存的；</p>
</li>
<li>
<p>二者底层实现的数据结构不同，<code>map</code>使用的是<a class="link" href="https://zh.wikipedia.org/zh-my/%E7%BA%A2%E9%BB%91%E6%A0%91"  target="_blank" rel="noopener"
    >红黑树</a>，操作性能分别是$O(logn)$和$O(1)$</p>
</li>
</ol>
</li>
</ul>
<p>常见的操作如下面的代码所示</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// C++ program to demonstrate functionality of unordered_map
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unordered_map&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Declaring umap to be of &lt;string, double&gt; type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// key will be of string type and mapped value will
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// be of double type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    unordered_map<span style="color:#f92672">&lt;</span>string, <span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> umap;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 新增键值对
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    umap[<span style="color:#e6db74">&#34;PI&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14</span>;
</span></span><span style="display:flex;"><span>    umap[<span style="color:#e6db74">&#34;root2&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.414</span>;
</span></span><span style="display:flex;"><span>    umap[<span style="color:#e6db74">&#34;root3&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.732</span>;
</span></span><span style="display:flex;"><span>    umap[<span style="color:#e6db74">&#34;log10&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2.302</span>;
</span></span><span style="display:flex;"><span>    umap[<span style="color:#e6db74">&#34;loge&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 插入键值对，可以使用c++的make_pair函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    umap.insert(make_pair(<span style="color:#e6db74">&#34;e&#34;</span>, <span style="color:#ae81ff">2.718</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    string key <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;PI&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 查询方法一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (umap.find(key) <span style="color:#f92672">==</span> umap.end())
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> key <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; not found</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// If key found then iterator to that key is returned
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Found &#34;</span> <span style="color:#f92672">&lt;&lt;</span> key <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 查询方法二
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (umap.count(key) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> )
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> key <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; not found</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// If key found then iterator to that key is returned
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Found &#34;</span> <span style="color:#f92672">&lt;&lt;</span> key <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 遍历方法一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    unordered_map<span style="color:#f92672">&lt;</span>string, <span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;::</span>iterator itr;
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">All Elements : </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (itr <span style="color:#f92672">=</span> umap.begin(); itr <span style="color:#f92672">!=</span> umap.end(); itr<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// itr works as a pointer to pair&lt;string, double&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// type itr-&gt;first stores the key part and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// itr-&gt;second stroes the value part
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        cout <span style="color:#f92672">&lt;&lt;</span> itr<span style="color:#f92672">-&gt;</span>first <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> itr<span style="color:#f92672">-&gt;</span>second <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 遍历方法二
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> iter : umap) {
</span></span><span style="display:flex;"><span>        cout <span style="color:#f92672">&lt;&lt;</span> iter.first <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> iter.second <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要格外注意，除了上面的<code>find</code>方法之外，查询某个键是否在哈希表中，还可以通过如下代码查询某个键值<code>key</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (umap[key] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> key <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; is found</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Not found</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果哈希表中没有这个键值，<strong>那么它会自动添加进去，并赋给它初值</strong>，所以在查询某个键是否存在时，不要用这样的方法。</p>
<h2 id="参考资料">参考资料
</h2><ul>
<li><a class="link" href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hua-dong-chuang-kou-ji-qiao-jin-jie"  target="_blank" rel="noopener"
    >我写了首诗，把滑动窗口算法算法变成了默写题 - labuladong的算法小抄</a>，非常通俗易懂的算法说明，基本上按照这个顺序来刷题的</li>
<li><a class="link" href="https://www.geeksforgeeks.org/unordered_map-in-cpp-stl/"  target="_blank" rel="noopener"
    >unordered_map in C++ STL - GeeksforGeeks</a>，C++ stl中的unordered_map</li>
<li><a class="link" href="https://www.geeksforgeeks.org/hashing-set-1-introduction/"  target="_blank" rel="noopener"
    >Hashing | Set 1 (Introduction) - GeeksforGeeks</a>，哈希表的介绍</li>
</ul>
</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/sliding-window/">Sliding Window</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css"integrity="sha256-J&#43;iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s="crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js"integrity="sha256-InsNdER1b2xUewP&#43;pKCUJpkhiqwHgqiPXDlIk7GzBu4="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js"integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI="crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "bugxch" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2016 - 
        
        2024 bugxch
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.26.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
