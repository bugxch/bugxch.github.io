[{"content":"这是一篇转载的文章，学习rust时候很多地方说不清楚什么时变量绑定和借用，这篇翻译的文章给说清楚了。\n如果不理解背后的设计理念和工作原理，那么就会对Rust的所有权和借用特性产生困惑。这种困惑尤其出现在将以前学习的编程风格应用于新范式时, 我们称之为范式转移。所有权是一个新颖的想法，初次接触时非常难以理解。但是，随着使用经验的逐渐积累，开发人员会越来越深刻的体会到其设计理念的精妙。在进一步学习Rust的所有权和借用特性之前。首先，需要了解下“内存安全”和“内存泄漏”的原理以及编程语言处理这两种问题的方式。\n内存安全 内存安全是指软件程序的一种状态，在这种状态下内存指针或引用始终指向有效内存。因为内存存在损坏的可能性，因此如果无法做到内存安全，那么就几乎无法保证程序的运行效果。简而言之，如果程序无法做到真正的内存安全，那么就无法保证其功能可以正常实现和执行。在运行内存不安全的程序时，攻击方可以利用漏洞在他人设备上窃取机密信息或任意执行恶意代码。下面我们将使用伪代码来解释有效内存。\n1 2 3 4 5 // pseudocode #1 - shows valid reference { // scope starts here int x = 5 int y = \u0026amp;x } // scope ends he 在上面的伪代码中，我们创建了一个值为10的变量x。我们使用\u0026amp;作为运算符或关键字来创建引用。因此，语法\u0026amp;x允许我们创建对变量x的值的引用。简单地说，我们创建了一个值为5的变量x和一个引用x的变量\nY。\n由于变量x和y在同一个代码块或作用域中，因此变量y对x的值的引用是有效引用。因此，变量y的值是5。\n下面的伪代码示例中，正如我们所见，x的作用域仅限于创建它的代码块。当我们尝试在其作用域之外访问x时，就会遇到悬空引用问题。悬空引用……？它到底是什么？\n1 2 3 4 5 // pseudocode #2 - shows invalid reference aka dangling reference { // scope starts here int x = 5 } // scope ends here int y = \u0026amp;x // can\u0026#39;t access x from here; creates dangling reference 悬空引用\n悬空引用的意思是指向已分配或已释放内存位置的指针。如果一个程序（也称为进程）引用了已释放或已清除数据的内存，就可能会崩溃或产生无法预知的结果。话虽如此，内存不安全也是一些编程语言的特性，程序员使用这些特性处理无效数据。因此，内存不安全引入了很多问题，这些问题可能会导致以下安全漏洞：\n越界读取 越界写入 UAF漏洞（Use-After-Free） 内存不安全导致的漏洞是许多高风险安全威胁的根源。更棘手的是，发现并处理此类漏洞对于开发人员来说是非常困难的。\n内存泄漏 我们需要了解内存泄漏的原理及其引发的严重后果。内存泄漏是非正常的内存使用形式，在这种情况下，会导致开发人员无法释放已分配的堆内存块，即使该内存块已不再需要存放数据。这与内存安全的概念是相反的。稍后我们将详细探讨不同的内存类型，但现在，我们只需要知道栈会存储在编译时就长度固定的变量，而在运行时会改变长度的变量则必须存放在堆上。与堆内存分配相比，栈内存分配被认为是更安全的，因为内存会在与程序无关或不再需要时被自动释放，释放过程可以由程序员控制，也可以由运行时系统自动判断。\n但是，当程序员在堆上占用内存并且未能将其释放，且没有垃圾回收器（例如C或C++）的情况下，就会发生内存泄漏。此外，如果我们丢失了一块内存的所有引用且没有释放该内存，也会发生内存泄漏。我们的程序将继续拥有该内存，却无法再次使用它。\n轻微的内存泄漏并不是问题，但是如果一个程序占用了大量的内存却从不释放，那么程序的内存占用将持续上升，最终导致拒绝服务。\n当程序退出时，操作系统会立即接管并释放其占用的所有内存。因此，只有当程序运行时内存泄露问题才会存在。一旦程序终止，内存泄露问题就会消失。让我们回顾一下内存泄漏的主要影响。\n内存泄漏能够通过减少可用内存（堆内存）的数量来降低计算机的性能。它最终会导致系统整体或部分的工作异常或造成严重的性能损耗。崩溃通常与内存泄漏有关。不同编程语言应对内存泄漏的方法是不同的。内存泄漏可能会从一个微小的几乎“不明显的问题”开始，但这些问题会迅速扩散并对操作系统造成难以承受的影响。我们应该尽最大努力密切关注内存泄露问题，尽可能避免并修正相关错误，而非任其发展。\n内存不安全和内存泄漏 内存泄漏和内存不安全是预防和补救方面最受关注的两类问题。而且两者相对独立，并不会因为其中一种问题被修复而使另一种问题被自动修复。 图1：内存不安全与内存泄漏\n内存的类型及其工作原理 在我们继续学习之前，我们需要了解不同类型的内存在代码中是如何被使用的。如下所示，这些内存的结构是不同的。\n寄存器 静态内存 栈内存 堆内存 寄存器和静态内存类型不在本文的讨论范围。\n栈内存及其工作原理 栈按照接收顺序存储数据，并以相反的顺序将其删除。栈中的元素是按照后进先出 (LIFO) 的顺序进行访问的。将数据添加到栈中称为“pushing”，将数据从栈中移除称为“popping”。\n所有存储在栈上的数据都必须是已知且长度固定的。在编译时长度未知或长度会发生变化数据必须存储在堆上。\n作为开发人员，我们不必为栈内存的分配和释放操心；栈内存的分配和释放是由编译器“自动完成”。这意味着当栈上的数据与程序无关（即超出范围）时，它会被自动删除而无需人工的干预。\n这种内存分配方式也被称为临时内存分配，因为当函数执行结束时，属于该函数的所有数据都会“自动”从栈中被清除。Rust中的所有原始类型都存在栈中。数字、字符、切片、布尔值、固定大小的数组、包含原始元素的元组和函数指针等类型都可以存放在栈上\n堆内存及其工作原理 与栈不同，当我们将数据存放到堆上时，需要请求一定的内存空间。内存分配器在堆中定位一个足够大的未占用空间，并将其标记为正在使用，同时返回该位置地址的引用。这就是内存分配。\n在堆上存放数据比在栈上存放数据要慢，因为栈永远不需要内存分配器寻找空位置来放置新数据。此外，由于我们必须通过指针来获取堆上的数据，所以堆的数据访问速度要比栈慢。栈内存是在编译时就被分配和释放的，与之不同的是，堆内存是在程序指令执行期间被分配和释放的。在某些编程语言中，使用关键字new来分配堆内存。关键字new（又名运算符）表示在堆上请求分配内存。如果堆上有充足的可用内存，则运算符new会将内存初始化并返回分配内存的唯一地址。值得一提的是，堆内存是由程序员或运行时系统“显式”释放的。\n编程语言如何实现内存安全？ 谈到内存管理，尤其是堆内存，我们希望编程语言具有以下特征：\n不需要内存时就尽快释放，且不增加资源消耗。 对已释放数据的引用（也就是悬空引用）进行自动维护。否则，极易发生程序崩溃和安全问题。 编程语言通过以下方式确保内存安全：\n显式内存释放（例如C和C++） 自动或隐式内存释放（例如Java、Python和C#） 基于区域的内存管理 线性或特殊类型系统 基于区域的内存管理和线性系统都不在本文的讨论范围。\n手动或显式内存释放 在使用显式内存管理时，程序员必须“手动”释放或擦除已分配的内存。运算符“释放”（例如，C中的delete）存在于需要显式内存释放的语言中。\n在C和C++等系统语言中，垃圾回收的成本很高，因此显式内存分配一定会长久存在的。将释放内存的职责留给程序员，能够让程序员在变量的生命周期内拥有其完整的控制权。然而，如果释放运算符使用不当，软件在执行过程中就极易出现故障。事实上，这种手动分配和释放内存的过程很容易出错。常见的编码错误包括：\n悬空引用 内存泄漏 尽管如此，我们更倾向于手动内存管理而非依赖垃圾回收机制，因为这赋予我们更多的控制权并能够有更出色的性能表现。请注意，任何系统编程语言的设计目标都是拥有更好的鲁棒性。换句话说，编程语言的设计者在性能和便利性之间选择了性能。\n确保不使用任何指向已释放内存的指针，是开发人员的责任。\n不久之前，有一些方法已经被验证可以避免这些错误，但这一切最终都归结为严格遵循代码规范，这需要严格使用正确的内存管理方法。\n关键要点是：\n严格的内存管理。 悬空引用和内存泄漏的安全性比较低。 较长的开发周期。 自动或隐式内存释放 自动内存管理已成为包括Java在内的现代编程语言的基本特征。\n在内存自动释放的场景中，垃圾回收器就是自动化的内存管理器。垃圾回收器会周期性的遍历堆内存并回收未使用的内存块。它代替我们管理内存的分配和释放。因此，我们不必编写代码来执行内存管理任务。这很好，因为垃圾回收器将我们从繁琐的内存管理职责中解放出来。同时也大大减少了开发时间。\n但是，垃圾回收机制并非完美无缺的，它同样有许多的缺点。在垃圾回收期间，程序需要暂停其他任务，并消耗时间搜索需要清理和回收的内存。\n此外，自动内存管理机制对内存有更高优先级的需求。垃圾回收器为我们执行内存释放的操作，而这些操作会消耗内存和CPU时钟周期。因此，自动内存管理会降低应用程序的性能，尤其是在资源有限的大型应用程序中。\n关键要点是：\n自动内存管理。 解决悬空引用或内存泄露问题，并高效提升内存安全性。 更简洁的代码。 更快的开发周期。 轻量化的内存管理。 由于它消耗内存和CPU时钟周期，因此延迟较高。 Rust中的内存安全 一些语言提供垃圾回收机制，它在程序运行时寻找不再使用的内存；而其他语言则要求程序员显式分配和释放内存。这两种模型各有优劣。垃圾回收机制虽然已经广泛应用，但也有一些缺点；它是以牺牲资源和性能为代价，来提升开发人员的工作效率。\n话虽如此，一边是提供高效的内存管理机制，而另一边通过消除悬空引用和内存泄漏提供更好的安全性。Rust将这两种优点集于一身。\n图2：Rust有优秀的内存管理机制，并提供很好的安全性\n**Rust采用了与上述两种方案不同的方法，即基于规则组的所有权模型，编译器验证这些规则组来确保内存安全。**只有在完全满足这些规则的情况下，程序才会被编译成功。事实上，所有权用编译时的内存安全检查替代运行时的垃圾回收机制。\n显式内存管理、隐式内存管理和Rust的所有权模型由于所有权是一个新的概念，因此，即使是与我一样的程序员，学习和适应它也需要一定时间。\n所有权 至此，我们对数据在内存中的存储方式有了基本的了解。现在我们来认真研究下Rust中的所有权模型。Rust最大的特点就是所有权模型，它在编译时就保障了内存的安全性。\n首先，让我们从字面意义来理解“所有权”。所有权是合法“拥有”和“控制”“某物”的一种状态。话虽如此，我们必须明确谁是所有者以及所有者能够拥有和控制什么。在Rust中，每个值都有对应的变量，变量就是值的所有者。简而言之，变量就是所有者，变量的值就是所有者能够拥有和控制的东西。\n图3：变量绑定展示所有者及其值/资源\n在所有权模型中，一旦变量超出作用域，内存就会被自动释放。当值超出作用域或结束其生命周期时，其析构函数就会被调用。析构函数（尤其是自动析构函数）是一个函数，它通过从程序中删除值的引用痕迹来释放内存。\n借用检查器 Rust通过借用检查器（一种静态分析器）实现所有权。借用检查器是Rust编译器中的一个组件，它跟踪整个程序中数据的使用位置，并且根据所有权规则，它能够识别需要执行释放的数据的位置。此外，借用检查器可以确保在运行时，已释放的内存永远不会被访问。它甚至消除了因为数据出现同时突变（或修改）而引起的竞争问题。\n所有权规则 如前所述，所有权模型建立在一组所有权规则之上，这些规则相对简单。Rust编译器\n(rustc) 强制执行以下规则：\n在Rust中，每个值都有对应的变量，变量就是值的所有者。 同时只能存在一个所有者。 当所有者超出作用域时，该值将被删除。 编译时检查的所有权规则会对以下内存错误进行保护：\n悬空引用：这是一个指向已经不再包含数据的内存地址的指针；此指针指向空数据或随机数据。 UAF漏洞：当内存被释放后，仍试图访问该内存，就可能会导致程序崩溃。这个内存位置经常被黑客用来执行恶意代码。 双重释放：当已分配的内存被释放后，再次执行释放操作。这会导致程序崩溃，进而暴露敏感信息。这种情况同样允许黑客执行恶意代码。 分段错误：程序尝试访问被禁止访问的内存区域时，就会出现分段错误。 缓冲区溢出：数据量超过内存缓冲区的存储容量时，就会出现缓冲区溢出，这通常会导致程序崩溃。 在深入了解所有权规则之前，我们需要先了解copy、move和clone之间的区别。\nCopy 长度固定的数据类型（尤其是原始类型）可以存储在栈中，并在其作用范围结束时清除数据释放内存。如果其他代码在其作用范围内需要相同数据的时候，还可以从栈中便捷的将该数据复制为一个新的独立变量。因为栈内存的复制非常高效便捷，因此具有固定长度的原始类型被称为拥有复制语义特性。它高效的创建了一个完美的复制品。\n值得注意的是，具有固定长度的原始类型实现了通过复制特征来进行复制。\n1 2 3 4 let x = \u0026#34;hello\u0026#34;; let y = x; println!(\u0026#34;{}\u0026#34;, x) // hello println!(\u0026#34;{}\u0026#34;, y) // hello 在Rust中，有两种字符串：String（堆分配的，可增长的）和\u0026amp;str（固定大小，不能改变）。\n因为x存储在栈中，所以复制它的值来为y生成一个副本非常容易。这种用法并不适用于存储在堆上的数据。下面是栈的示意图： 图4：x和y都有自己的数据\n复制数据会增加程序运行时间和内存消耗。因此，大块数据不适合使用复制。\nMove 在Rust术语中，“move”意味着将转移内存的所有权。想象一下堆上存储的数据类型有多复杂。\n1 2 let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; 我们可以假设第二行（即\nLet s2 = s1;）将复制s1中的值并绑定到s2。然而所见并非所得。\n下面我们将研究下String究竟在后台执行了什么样的操作。String由存储在栈中的三部分组成。实际的内容（在本例中是hello）存储在堆上。\n指针-指向保存字符串内容的内存。 长度-字符串当前使用的内存大小（以字节为单位）。 容量-字符串从分配器获得的内存总量（以字节为单位）。 换句话说，元数据存储在栈上，而实际数据则存储在堆上。 图5：栈存储元数据，堆存储实际内容\n当我们将s1分配给s2时，会复制字符串的元数据，这意味着我们会复制栈上的指针、长度和容量。不会复制堆上指针所指向的数据。内存中的数据如下所示： 图6：变量s2获取s1的指针、长度和容量的副本\n值得注意的是，下图表示的是Rust复制了堆数据后内存的状态，真实情况并不是这样的。如果Rust执行此操作，当堆数据很大时，则s2 = s1操作在运行时性能表现会非常差。\n图7：如果Rust复制堆数据，s2 = s1操作的结果就是数据复制。但是，Rust默认不执行数据复制\n请注意，当复杂类型不在作用域内时，Rust将调用drop函数对堆内存执行显式释放。但是，图6中的两个数据指针指向同一个位置，Rust并不会这样做。我们将很快进入技术实现细节。\n如前所述，当我们将s1分配给s2时，变量s2会复制s1的元数据（指针、长度和容量）。但是，将s1分配给s2之后，s1会发生什么呢？Rust认为此时s1是无效的。是的，你没看错。\n让我们重新思考下let s2 = s1的赋值操作。假设Rust在此操作之后仍然认为s1是有效的，那么会发生什么。当s2和s1超出范围时，它们都会尝试释放相同的内存。这是个糟糕的情况。这被称为双重释放错误，它属于内存安全错误的一种情况。双重释放内存可能会导致内存损坏，进而带来安全风险。\n为了确保内存安全，Rust在let s2 = s1操作执行之后会认为s1无效。因此，当s1不在作用域内时，Rust不需要执行内存释放。假如创建s2后仍然尝试使用s1会发生什么，下面我们做个试验。\n1 2 3 let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; println!(\u0026#34;{}, world!\u0026#34;, s1); // Won\u0026#39;t compile. 我们得到一个错误。 我们会得到一个类似下面的错误，因为Rust不允许使用无效的引用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ cargo run Compiling playground v0.0.1 (/playground) error[E0382]: borrow of moved value: `s1` --\u0026gt; src/main.rs:6:28 | 3 | let s1 = String::from(\u0026#34;hello\u0026#34;); | -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait 4 | let s2 = s1; | -- value moved here 5 | 6 | println!(\u0026#34;{}, world!\u0026#34;, s1); | ^^ value borrowed here after move | = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info) For more information about this error, try `rustc --explain E0382`. 由于Rust在let s2 = s1操作执行之后将s1的内存所有权转移给了s2，因此它认为s1是无效的。这是s1失效后的内存表示： 图8：s1无效后的内存表示\n当只有s2保持有效时，就会在其超出范围时执行内存释放操作。因此，Rust消除了双重释放错误出现的可能性。这是非常优秀的解决方案！\nClone 如果我们需要深度复制字符串的堆数据，而不仅仅是栈数据，可以使用一种叫做clone的方法。以下是克隆方法的使用示例：\n1 2 3 let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1.clone(); println!(\u0026#34;s1 = {}, s2 = {}\u0026#34;, s1, s2); Clone方法确实将堆数据复制到s2中了。操作非常完美，下图是示例： 图9：clone方法确实将堆数据复制给s2\n然而clone方法有一个严重的后果；它只复制数据，却不会同步两者之间的任何更改。通常情况下，进行clone应当审慎评估其效果和影响。\n至此，我们详细了解了copy、move和clone的技术原理。下面我们将详细地了解所有权规则。\n所有权规则1 每个值都有对应的变量，变量就是值的所有者。这意味着值都归变量所有。在下面的示例中，变量s拥有指向字符串的指针，而在第二行中，变量x拥有值1。\n1 2 let s = String::from(\u0026#34;Rule 1\u0026#34;); let n = 1; 所有权规则2 在给定时间，一个值只有一个所有者。一个人可以拥有许多宠物，但在所有权模型中，任何时候一个值都只有一个所有者:-)\n原始类型是在编译时就已知其固定长度的数据类型，下面是原始类型的使用示例。\n1 2 3 let x = 10; let y = x; let z = x; 我们将10分配给变量x；换句话说，变量x拥有10。然后我们将x分配给y，同时将其分配给z。我们知道同一时间只能存在一个所有者，但没有引发任何错误。所以在此示例中，每次当我们将x分配给一个新变量时，编译器都会对其进行复制。\n栈帧如下：x = 10，y = 10 和 z = 10。然而，真实情况似乎与我们的设想（x = 10、y = x 和 z = x）不一样。我们知道，x是10的唯一所有者，y和z都不能拥有这个值。\n图10：编译器将x复制到y和z\n就像前文所述，由于复制栈内存高效便捷，因此具有固定长度的原始类型被称为拥有复制语义特性，而复杂类型就只是移动所有权。因此，在这种情况下，编译器执行了复制操作。\n这种情况下，变量绑定的行为与其他的编程语言类似。为了阐释所有权规则，我们需要复杂的数据类型。\n我们通过观察数据在堆上的存储方式，来学习Rust如何判断需要清理哪些数据；字符串类型是就是一个很好的例子。我们将聚焦于字符串类型所有权相关的行为；这些原则也适用于其他复杂的数据类型。\n众所周知，存储在堆上的复杂数据类型，其内容在编译时是不可预知的。我们来观察这个示例：\n1 2 3 4 let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; println!(\u0026#34;{}, world!\u0026#34;, s1); // Won\u0026#39;t compile. 我们得到一个错误。 字符串类型的场景下，其存储在堆上的数据长度可能会发生变化。这就表示:\n程序在运行的时候就必须从内存分配器请求内存（我们称之为第一部分）。 当不再需要该字符串后，需要将此内存释放回内存分配器（我们称之为第二部分）。 开发人员需要重点关注第一部分：当我们从String:: 开始执行调用时，它会向内存分配器请求内存。这部分的技术实现在编程语言中很常见。但是，第二部分是不一样的。在拥有垃圾回收机制的编程语言中，垃圾回收器会跟踪并清理不再使用的内存，开发人员并不需要在此方面投入精力。在没有垃圾回收机制的语言中，识别不再需要的内存并显式释放内存就是开发人员的职责。确保正确释放内存是一项很有挑战性的编程任务:\n如果我们忘记释放内存，就会造成内存空间浪费。 如果我们过早的释放内存，那么就会产生一个无效变量。 如果我们重复释放内存，程序就会出现BUG。 Rust以一种新颖的方式处理内存释放，有效减轻了开发人员的工作压力：当变量超出其作用域时，内存就会被自动释放。\n让我们回到正题。在Rust中，对于复杂类型，诸如为变量赋值、参数传递或函数返回值这类的操作是不会执行copy操作，而是会执行move操作。简而言之，对于复杂类型来说，通过转移其所有权来完成上述任务。当复杂类型超出其作用域时，Rust将调用drop函数显式地执行内存释放。\n所有权规则3 当所有者超出作用域时，该值将被删除。再次考虑之前的示例：\n1 2 3 4 let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; println!(\u0026#34;{}, world!\u0026#34;, s1); // Won\u0026#39;t compile. The value of s1 has already been dropped. 在将s1分配给s2之后（在let s2 = s1赋值语句中），s1的值就被释放了。因此，赋值语句执行后，s1就失效了。S1被释放后的内存状态： 图11：s1被释放后的内存状态\n所有权如何变动 在Rust程序中，有三种方式可以在变量之间转移所有权：\n（1）将一个变量的值分配给另一个变量（前文已经讨论过）。 （2）将值传递给函数。 （3）从函数返回值。\n将值传递给函数 将值传递给函数与为变量赋值有相似的语义。就像赋值一样，将变量传递给函数会导致变量被移动或复制。下面的例子向我们展示了复制和移动：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 fn main() { let s = String::from(\u0026#34;hello\u0026#34;); // s comes into scope move_ownership(s); // s\u0026#39;s value moves into the function... // so it\u0026#39;s no longer valid from this // point forward let x = 5; // x comes into scope makes_copy(x); // x would move into the function // It follows copy semantics since it\u0026#39;s // primitive, so we use x afterward } // Here, x goes out of scope, then s. But because s\u0026#39;s value was moved, nothing // special happens. fn move_ownership(some_string: String) { // some_string comes into scope println!(\u0026#34;{}\u0026#34;, some_string); } // Here, some_string goes out of scope and `drop` is called. // The occupied memory is freed. fn makes_copy(some_integer: i32) { // some_integer comes into scope println!(\u0026#34;{}\u0026#34;, some_integer); } // Here, some_integer goes out of scope. Nothing special happens. 如果我们在调用move_ownership之后尝试使用s，Rust会抛出编译错误。\n从函数返回值 从函数返回值同样可以转移所有权。下面是一个包含返回值的函数示例，其注释与上一个示例中的注释相同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 fn main() { let s1 = gives_ownership(); // gives_ownership moves its return // value into s1 let s2 = String::from(\u0026#34;hello\u0026#34;); // s2 comes into scope let s3 = takes_and_gives_back(s2); // s2 is moved into // takes_and_gives_back, which also // moves its return value into s3 } // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing // happens. s1 goes out of scope and is dropped. fn gives_ownership() -\u0026gt; String { // gives_ownership will move its // return value into the function // that calls it let some_string = String::from(\u0026#34;yours\u0026#34;); // some_string comes into scope some_string // some_string is returned and // moves out to the calling // function } // This function takes a String and returns it fn takes_and_gives_back(a_string: String) -\u0026gt; String { // a_string comes into // scope a_string // a_string is returned and moves out to the calling function } 变量的所有权改变始终遵循相同的模式：当值被分配给另一个变量时，就会触发move操作。除非数据的所有权被转移至另一个变量，否则当包含堆上数据的变量超出作用域时，该值将被清除。\n希望这能让大家对所有权模型及其对Rust处理数据的方式（例如赋值引用和参数传递）有一个基本的了解。\n等等。还有一件事…\n没有什么是完美无缺的，Rust所有权模型同样有其局限性。当我们开始使用Rust后，很快就会发现一些使用不顺手的地方。我们已经观察到，获取所有权然后函数传递所有权就有一些不顺手。\n令人讨厌的是，假设我们想再次使用数据，那么传递给函数的所有内容都必须执行返回操作，即使其他函数已经返回了部分相关数据。如果我们需要一个函数只使用数据但是不获取数据所有权，又该如何操作呢？\n参考以下示例。下面的代码示例将报错，因为一旦所有权转移到print_vector函数，变量v就不能再被最初拥有它的main函数（在 println 中！）使用。\n1 2 3 4 5 6 7 8 9 fn main() { let v = vec![10,20,30]; print_vector(v); println!(\u0026#34;{}\u0026#34;, v[0]); // this line gives us an error } fn print_vector(x: Vec\u0026lt;i32\u0026gt;) { println!(\u0026#34;Inside print_vector function {:?}\u0026#34;,x); } 跟踪所有权看似很容易，但是当我们面对复杂的大型程序时，它就会变得非常复杂。所以我们需要一种在不转移“所有权”的情况下传递数据的方法，这就是“借用”概念发挥作用的地方。\n借用 借用，从字面意义上来说，就是收到一个物品并承诺会归还。在Rust的上下文中，借用是一种在不获取所有权的情况下访问数据的方式，因为它必须在恰当的时机返还给所有者。\n当我们借用一个数据时，我们用运算符\u0026amp;引用它的内存地址。\u0026amp;被称为引用。引用本身并没有什么特别之处——它只是对内存地址的指向。对于熟悉C语言指针的人来说，引用是指向内存的指针，其中包含属于另一个变量的数据。值得注意的是，Rust中的引用不能为空。实际上，引用就是一个指针；它是最基本的指针类型。大多数编程语言中只有一种指针类型，但Rust有多种指针类型。指针及其类型是另外一个话题，以后有机会将会单独讨论。\n简而言之，Rust将对某个数据的引用称为借用，该数据最终必须返回给所有者。示例如下：\n1 2 3 4 5 6 let x = 5; let y = \u0026amp;x; println!(\u0026#34;Value y={}\u0026#34;, y); println!(\u0026#34;Address of y={:p}\u0026#34;, y); println!(\u0026#34;Deref of y={}\u0026#34;, *y); 上述代码生成以下输出：\n1 2 3 Value y=5 Address of y=0x7fff6c0f131c Deref of y=5 示例中，变量y借用了变量x拥有的数据，而x仍然拥有该数据的所有权。我们称之为y对x的引用。当y超出范围时，借用关系结束，由于y没有该数据的所有权，因此该数据不会被销毁。要借用数据，请使用运算符\u0026amp;进行引用。{: p}代表输出以十六进制表示的内存位置。\n在上面的代码示例中，“*”（即星号）是对引用变量进行操作的解引用运算符。这个解引用运算符允许我们获取指针指向的内存地址中的数据。\n下面是函数通过借用，在不获取所有权的情况下使用数据的示例：\n1 2 3 4 5 6 7 8 9 fn main() { let v = vec![10,20,30]; print_vector(\u0026amp;v); println!(\u0026#34;{}\u0026#34;, v[0]); // can access v here as references can\u0026#39;t move the value } fn print_vector(x: \u0026amp;Vec\u0026lt;i32\u0026gt;) { println!(\u0026#34;Inside print_vector function {:?}\u0026#34;, x); } 我们将引用 (\u0026amp;v)（又名pass-by-reference）而非所有权（即pass-by-value）传递给print_vector函数。因此在main函数中调用print_vector函数后，我们就可以访问v了。\n通过解引用运算符跟踪指针的指向数据 如前所述，引用是指针的一种类型，可以将指针视为指向存储在其他位置的数据的箭头。下面是一个示例：\n1 2 3 4 5 let x = 5; let y = \u0026amp;x; assert_eq!(5, x); assert_eq!(5, *y); 在上面的代码中，我们创建了一个对i32类型数据的引用，然后使用解引用运算符跟踪被引用的数据。变量x存储一个i32类型的值5。我们将y设置为对x的引用。\n下面是栈内存的状态： 栈内存状态\n我们可以断言x等于5。然而，假如我们需要对y中的数据进行断言，就必须使用*y来跟踪它所引用的数据（因此在这里解引用）。一旦我们解开了y的引用，就可以访问y指向的整型数据，然后将其与5进行比较。\n如果我们尝试写assert_eq! (5, y); 就会得到以下编译错误提示：\n1 2 3 4 5 error[E0277]: can\u0026#39;t compare `{integer}` with `\u0026amp;{integer}` --\u0026gt; src/main.rs:11:5 | 11 | assert_eq!(5, y); | ^^^^^^^^^^^^^^^^ no implementation for `{integer} == \u0026amp;{integer}` 左右滑动查看完整代码由于它们是不同的数据类型，因此无法对数字和数字的引用进行比较。所以，我们必须通过解引用运算符来跟踪其指向的真实数据。\n默认情况下，引用是不可变的 默认情况下，引用和变量一样是不可变的——可以通过mut使其可变，但前提是它的所有者也是可变的：\n1 2 let mut x = 5; let y = \u0026amp;mut x; 不可变引用也被称为共享引用，而可变引用也被称为独占引用。\n我们观察下面的案例。我们赋予对引用的只读权限，因为我们使用的是运算符\u0026amp;而非\u0026amp;mut。即使源变量n是可变的，ref_to_n和another_ref_to_n也不是可变的，因为它们只是n借用，并没有n的所有权。\n1 2 3 let mut n = 10; let ref_to_n = \u0026amp;n; let another_ref_to_n = \u0026amp;n; 借用检查器将抛出以下错误：\n1 2 3 4 5 6 7 error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable --\u0026gt; src/main.rs:4:9 | 3 | let x = 5; | - help: consider changing this to be mutable: `mut x` 4 | let y = \u0026amp;mut x; | ^^^^^^ cannot borrow as mutable 借用规则 有人可能会有疑问，为什么有些情况下开发人员更倾向于使用move而非借用。如果这是关键点，那么为什么Rust还会有move语义，以及为什么不将默认机制设置为借用？根本原因是在Rust中借用的使用是受到限制的。只有在特定情况下才允许借用。\n借用有自己的一套规则，借用检查器在编译期间会严格执行这些规则。制定这些规则是为了防止数据竞争。规则如下：\n（1）借用者的作用域不能超过所有者的作用域。\n（2）不可变引用的数量不受限制，但可变引用只能存在一个。\n（3）所有者可以拥有可变引用或不可变引用，但不能同时拥有两者。\n（4）所有引用必须有效（不能为空）。\n引用的作用域不能超过所有者的作用域 引用的作用域必须包含在所有者的作用域内。否则，可能会引用一个已释放的数据，从而导致UAF错误。\n1 2 3 4 5 6 let x; { let y = 0; x = \u0026amp;y; } println!(\u0026#34;{}\u0026#34;, x); 上面的示例程序尝试在所有者y超出作用域后取消x对y的引用。Rust阻止了这种UAF错误。\n可以有很多不可变引用，但只允许有一个可变引用 特定数据可以拥有数量不受限制的不可变引用（又名共享引用），但只允许有一个可变引用（又名独占引用）。这条规则的存在是为了消除数据竞争。当两个引用同时指向一个内存位置，至少有一个在执行写操作，且它们的动作没有进行同步时，这就被称为数据竞争。\n我们可以有数量不受限制的不可变引用，因为它们不会更改数据。另一方面，借用机制限制我们同一时刻只能拥有一个可变引用（\u0026amp;mut），目的是降低在编译时出现数据竞争的可能性。\n我们看看如下示例：\n1 2 3 4 5 6 7 8 fn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); let r1 = \u0026amp;mut s; let r2 = \u0026amp;mut s; println!(\u0026#34;{}, {}\u0026#34;, r1, r2); } 上面的代码尝试为s创建两个可变引用（r1 和 r2），这最终会执行失败：\n1 2 3 4 5 6 7 8 9 10 error[E0499]: cannot borrow `s` as mutable more than once at a time --\u0026gt; src/main.rs:6:14 | 5 | let r1 = \u0026amp;mut s; | ------ first mutable borrow occurs here 6 | let r2 = \u0026amp;mut s; | ^^^^^^ second mutable borrow occurs here 7 | 8 | println!(\u0026#34;{}, {}\u0026#34;, r1, r2); | -- first borrow later used here 总结 希望本文能够澄清所有权和借用的概念。我还简单介绍了借用检查器，它是实现所有权和借用的基础。正如我在开头提到的，所有权是一个很有创意的想法，即使对于经验丰富的开发人员来说，初次接触也会很难理解其设计理念和使用方法，但是随着使用经验的增加，它就会成为开发人员得心应手的工具。这只是Rust如何增强内存安全的简要说明。我试图使这篇文章尽可能的易于理解，同时提供足够的信息来掌握这些概念。有关Rust所有权特性的更多详细信息，请查看他们的在线文档。\n当开发项目对性能要求高时，Rust是一个不错的选择，它解决了困扰其他语言的很多痛点，并以陡峭的学习曲线向前迈出了重要的一步。Rust连续第六年成为Stack Overflow最受欢迎的语言，这意味着很多人将会有机会使用它并爱上了它。Rust社区正在持续发展壮大。随着我们走向未来，Rust似乎正走在无限光明的道路上。祝大家学习愉快！\n原文链接 Rust’s Ownership and Borrowing Enforce Memory Safety | HackerNoon\n译者介绍 仇凯，51CTO社区编辑，目前就职于北京宅急送快运股份有限公司，职位为信息安全工程师。主要负责公司信息安全规划和建设（等保，ISO27001），日常主要工作内容为安全方案制定和落地、内部安全审计和风险评估以及管理。\n本文原载于 巴巴变的博客，遵循CC BY-NC-SA 4.0协议，复制请保留原文出处。\n","date":"2024-07-19T20:44:30+08:00","image":"https://image-1258996033.cos.ap-shanghai.myqcloud.com/lake-7838004_1280.jpg","permalink":"https://blog.bugxch.top/p/%E7%90%86%E8%A7%A3rust%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E5%92%8C%E5%80%9F%E7%94%A8%E6%A6%82%E5%BF%B5%E8%BD%AC%E8%BD%BD/","title":"理解Rust中的“所有权”和“借用”概念（转载）"},{"content":"端午节前一天，老婆在家里突然说要出去玩，要不然这个假期浪费了，索性就选了离上海最近的苏州，我原以为假期车票很难买，结果在12306上居然可以买到当天往返的车票，所以一家三口就直接买票去玩了。买的高铁票从上海站出发到最近的苏州园区站，那里有苏州最具标志性的东方之门和金鸡湖，之前反复听人提起过，倒是没有去过，这次说走就走的特种兵式旅行是我入职华为以来第一次，其他时间离开上海要么是出差要么是回家。\n下面是这次旅行的照片，都是富士XT 30 II相机 + 50230的镜头拍摄，我们的游览路线是在苏州园区站下车，然后在苏州中心商场吃饭，下午坐车去逛诚品书店和李公堤，最后回家。\n诚品书店旁边的码头，一众人在为第二天端午节的龙舟比赛做准备。\n诚品书店的音乐会表演，在一楼大厅演奏的是传统的民族乐曲，观众坐在阶梯上听得非常入神。\n远眺金鸡湖景色，非常不错。\n泛舟金鸡湖，舒适惬意。\n金鸡湖的典型景色。上面这些照片就是第一次短暂停留苏州拍摄的，总得印象非常不错，视野开阔商业现代，据说金鸡湖是按照新加坡的模式开发的。消费比较低，出租车起步价应该不超过10块，节奏比上海慢很多。我大体算了下，从我家里出门到金鸡湖差不多也就是一个半小时的时间（地铁到上海站-\u0026gt;苏州园区站 -\u0026gt; 苏州地铁到李公堤），很适合周末特种兵旅行。\n中间发生一件趣事，儿子吵着要玩滑滑梯，我忙着拍照片，出租车司机说可以去湖心岛玩，他还想坐苏州的公交车🚌（十足的公交车迷），我就说3个选择你选一个，他说我想坐公交车去湖心岛上玩滑滑梯，是个人才。\n第二次旅行，在6.16的周日，带着丈母娘一家四口出发，但是这次目的地是去苏州老城区，所以目的地是苏州站，我刚开始以为很远，结果回来才知道苏州园区站到苏州站也就不到10分钟高铁车程，看来苏州确实比较小。规划的比较好，前一天买了虎丘、拙政园的门票，本来计划中间去西园寺和山塘街，或者逛多点去平江路，但是发现真的精力不济，现在看来当时应该中午搞个钟点房休息下，这样的特种兵旅行太累了。\n在阊门休息时候沿河边走路拍到的精致，很好结合了苏州古城的特色，文化底蕴深厚，五步一个景点。我从虎丘出来坐船沿河一路到山塘街，发现路边的题词古迹很多，看了了五人墓。 虎丘一景。\n上面房子的全景。\n虎丘的剑池，前面的阶梯状的石头是古代高僧讲经的地方，儿子特别喜欢爬上爬下。\n为数不多的拍的不错的照片之一。\n最终还是在金鸡湖边发呆。这次旅游没有尽兴，山塘街也没好好逛逛，还有很多计划中的景点都没有去，后面还会去打卡。\n本文原载于 巴巴变的博客，遵循CC BY-NC-SA 4.0协议，复制请保留原文出处。\n","date":"2024-06-22T22:02:20+08:00","image":"https://image-1258996033.cos.ap-shanghai.myqcloud.com/DEFG7034.JPG","permalink":"https://blog.bugxch.top/p/%E4%B8%A4%E6%AC%A1%E7%9F%AD%E6%9A%82%E8%8B%8F%E5%B7%9E%E4%B9%8B%E8%A1%8C/","title":"两次短暂苏州之行"},{"content":"这是CSAPP第四章，作者想通过自己定义的Y86-64的ISA指令集定义、设计、编码以及制造一个简单的单周期流水线化的处理器。作者的思路也非常清晰，包括了上述的所有步骤，在每一步描述了嵌入了处理器设计的基本原则以及需要注意的技术细节。下面是设计的ISA的指令\n前置知识 堆栈操作 作者在4.1.6和4.3.3两次提到堆栈操作的特殊性，此处做一个基本的回顾。堆栈指令包括 popq 和 pushq 两条，作者设计假定栈顶的地址始终保存在寄存器 %rsp 中，参考程序的机器级表示中的内容，有如下示意图\n在理解上面过程之前，我们假设：\n堆栈中保存的是 8字节的元素，而且按照小端法存储的，即低有效位对应低地址； 数据在内存中的地址，指的是整个数据的第一个字节在内存中的地址，例如保存一个2字节的数据 0x1234 在内存地址0x100处，那么0x100地址保存字节0x34，0x101处保存字节0x12。 结合上面的假设，很容易看出，\n堆栈是从高地址向低地址增长的，推入一个元素栈顶指针地址变小，弹出一个元素则变大； %rsp 始终指向栈顶的最后一个元素的地址，也就是最后一个元素在内存中的起始地址。 基于上面的两点，程序的操作就比较好理解了，初始状态 %rsp 中地址是0x108，\n将 %rax 寄存器中的数据push进去，所以堆栈元素要增加8字节，为了将新的元素放到堆栈里面，先执行 %rsp = %rsp - 8，此时 %rsp 指向要入栈的新元素的起始地址0x100，这时就可以根据 %rsp 的起始地址连续存储8个字节的新元素了，这个操作类似于 1 2 subq $8, %rsp // rsp = rsp - 8 movq %rbp, (%rsp) // %rbp的元素拷贝到%rsp存储的地址处 出栈就是相反的，当前的 %rsp 保存的就是需要弹出元素的地址，那么可以直接将该地址开始的连续8个字节先拷贝到目的地址，然后 %rsp = %rsp + 8，此时 %rsp 指向堆栈的新的最后一个元素的地址。等价于如下的操作 1 2 movq (%rsp), %rax subq $8, %rsp 上面的操作可以保证，%rsp 始终指向栈顶元素的起始地址\n条件传送 vs 条件分支 条件分支是我们认识的C语言比较常规的分支程序的处理方式，下面是条件分支的一个例子\n计算 $|x- y|$，查看汇编指令，可以看到第8行有一个跳转到L2的过程，这里的问题在于CPU执行程序时候需要根据bool(x\u0026lt;y)判断是否需要跳转，如果判断的bool条件比较复杂，需要经过比较长的时钟周期才可以计算出结果的话，现代CPU不会等待这个结束才继续下面的计算，而是按照分支预测的方式先执行概率比较大的那个分支。如果预测分支执行中，计算得到的bool值跟预期的不一致，就需要丢弃已经执行的分支指令，重新跳转回去执行另一个没有被预测命中的分支，那这样的话计算时间就很长了。\n作者介绍了x86下面的传送指令，这些指令会先将源地址S中的数据读取出来，然后检查对应的条件码，根据条件码的值确认是否需要将读出来的值写入到目的寄存器R中，C语言中三目运算符编译器一般会翻译成条件传送指令。\n使用传送指令编译之前的计算绝对值的代码，如下所示，\n上面代码有2个特点：\n计算x - y和y - x两个值； 没有跳转指令，所以没有之前说的分支预测错误运行时间变长的问题，而且按照现代CPU的逻辑，推理这段代码的ALU单元基本上是满载的。 参考文献 汇编语言（第4版） (豆瓣) 本文原载于 巴巴变的博客，遵循 CC BY-NC-SA 4.0协议，复制请保留原文出处。\n","date":"2024-06-01T21:54:52+08:00","image":"https://image-1258996033.cos.ap-shanghai.myqcloud.com/staircase-7718335_1280.jpg?imageSlim","permalink":"https://blog.bugxch.top/p/csapp%E4%B9%8B%E5%9B%9B%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","title":"CSAPP之四——处理器体系结构"},{"content":"这周末去了杨浦公园玩，地方不大，公园比较朴素，石桥修得有趣，但是护栏很低，而且人工湖没有护栏，带小孩去玩还是要小心。\n一家三口一起游玩\n湖边没有护栏\n到哪里都可以看到的火箭玩具\n居然在公园发现树上的小松鼠，上次在上海市区看到松鼠都是七八年前的事情了，只记得是在浦西小马路旁边的大树上，具体在哪里记不得了。 桥有点意思，虽然看起来有点简陋，护栏很低，但是有点古朴的味道。 杨浦公园外面有个花鸟古玩市场，里面非常热闹，我在儿童公园都能听到里面鼎沸的人声。公园外面的人行道上有很多小商贩，电瓶车后面小行李箱打开就是个小货摊，有卖古玩，铜币的，居然有卖经典 CD 和磁带的，里面夹杂着些蓝色小药丸，这些小玩意不知道现在还有谁会买，就像这公园一样古朴。\n本文原载于 巴巴变的博客，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-01-14T08:20:51+08:00","image":"https://image-1258996033.cos.ap-shanghai.myqcloud.com/undefinedDEFG4941.JPG","permalink":"https://blog.bugxch.top/p/%E5%91%A8%E8%AE%B0%E4%B9%8B%E4%BA%8C/","title":"周记之二"},{"content":"r2s 每更新一次固件版本，就需要重新刷一下风扇的脚本，非常麻烦，记录下，下面是文章全文。\n主要包括如下几个步骤：\n通过ssh登录路由器的shell界面，进入目录 /etc/init.d目录，查看是否有fa-fancontrol或者pwm-fan等包含fan字段的脚本，如果有则选中删除。\n在当前目录，输入以下命令\n1 2 3 4 cd /etc/init.d/ touch pwm-fan chmod 777 pwm-fan /etc/init.d/pwm-fan enable 打开pwm-fan文件，输入如下内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/bin/sh /etc/rc.common START=99 start () { echo 0 \u0026gt; /sys/class/pwm/pwmchip0/export echo 0 \u0026gt; /sys/class/pwm/pwmchip0/pwm0/enable echo 50000 \u0026gt; /sys/class/pwm/pwmchip0/pwm0/period echo 1 \u0026gt; /sys/class/pwm/pwmchip0/pwm0/enable echo 49990 \u0026gt; /sys/class/pwm/pwmchip0/pwm0/duty_cycle; # 初始风扇不转 while true do temp=$(cat /sys/class/thermal/thermal_zone0/temp) #去掉了$旁的空格 if [ $temp -gt 50000 ] ; then # 温度高于 50 风扇开始转，可修改，比如65000为65度； echo 30000 \u0026gt; /sys/class/pwm/pwmchip0/pwm0/duty_cycle; elif [ $temp -le 45000 ] ; then # 温度低于 45 风扇停转，可修改，比如55000为55度； echo 49990 \u0026gt; /sys/class/pwm/pwmchip0/pwm0/duty_cycle; fi #多加了fi sleep 1s; # 1s检测一次，正常使用设置为60s done } 使用下面的shell命令改成shell的format\n1 dos2unix pwm-fan 然后我们登陆后台web管理界面，在【系统】\u0026ndash;【启动项】\u0026ndash;“启动脚本”下面能看到99号优先级名为pwm-fan的脚本，点击第二个【启动】按钮，风扇就开始转了，当温度降低到你设定的最低临界值的时候，风扇会自动停止。温度达到你设定的启动临界值的时候风扇会自动启动。最后重启一下你的路由器，确保设置生效。\n全文完🚀\n","date":"2023-01-25T21:16:42+08:00","image":"https://pic.imgdb.cn/item/63d13639face21e9efb8dbc4.jpg","permalink":"https://blog.bugxch.top/p/r2s%E5%A4%96%E6%8E%A5%E9%A3%8E%E6%89%87%E8%AE%BE%E7%BD%AE/","title":"R2S外接风扇设置"},{"content":"驾考科目二总结，考试要点如下，\n在考试过程中，在保证不停车的前提下，尽量以最慢的速度完成考试 转方向盘要迅速，尤其左打满右打满要快； 熟记每一个考试内容的操作要点，按照步骤操作，不要省略、跳过或者打乱步骤 驾考内容 左右倒库 操作步骤 以右倒库为例，左倒库是右倒库的镜像操作。参考上面的示意图\n入场时从C点开始，沿着绿色箭头方向缓缓驶入考场。此处在开车过程中，方向盘正对图中最右侧的红色标志，左肩膀与A点处白色虚线平齐为止，此时可以保证小车前轮越过白色虚线； 挂倒挡开始倒车，与左边线平齐行驶，注意观察与左边线垂直的黄色标记，在肩膀与黄色标记平齐时右打满方向盘开始入库。 在倒车过程中观察右后视镜中的F处入库的虚线，当车身任意部位与从右往左数第三根虚线相交时，注意观察车把前端点与交点的距离P与虚线右端与交点的距离Q的长度。如果P \u0026gt; Q，那么方向盘回一圈，边后退边观察，此时P会慢慢变短，当P = Q时，迅速右打满方向盘，继续倒车 当右库角（点E）出现在右后视镜时，迅速回正方向盘，观察左后视镜中GH边线与车身的距离，左右微调方向盘，保证前大后小。 观察车库左边线的黄色的垂直线，待肩膀与黄色线平齐后停车，不可超过。 操作要点 左倒库观察左后视镜，右倒库观察右后视镜；’ 上面的第3步是非常关键的调整机会，注意P和Q距离的大小比较，此处速度能有多慢就调多慢，务必保证操作正确； 方向盘的操作有打满、回一圈、微调3种操作； 把握方向盘调整的时机，该打满的时候迅速打满，或者可以稍微早点操作 扣分点 不按规定路线、顺序行驶，不合格 车身出线，不合格； 倒库不入，不合格； 在倒车前，未将两个前轮出地点均驶过控制线； 项目完成时间超过210秒； 中途停车时间超过2秒，每次扣5分 直角转弯 操作步骤 开车过程中需要瞄准B点，保证行驶右车身与右边线A保持在30公分左右的车距； 车辆摆正后就打开左转向灯，缓慢向前行驶，前面的边线在前车窗视野中消失时关闭左转向灯； 注意观察左边转弯延长线与车身内门锁把手的交点，待其稍微超过门锁把手后边沿时迅速左打满，开始转弯； 转弯后，待车辆驶入道路中心时，回正方向盘，此项目考核结束。 操作要点 不要忘记打转向灯或者错误打灯； 注意转弯前的右车身与边线的距离； 转弯时机掌握到位，方向盘操作迅捷不犹豫。 扣分点 车轮轧道路边缘线，不合格； 转弯时不使用或者错误使用转向灯，转弯后不关闭转向灯，扣10分。 侧方停车 操作步骤 车辆从右往左行驶，注意保持车身和边线AE的距离，保持在30公分左右。开车过程中瞄准前方的点，或者注意左边雨刮器1/3处在右边线上行驶，基本可以保证达标； 库角A出现在右后视镜中心点时停车，挂R档开始倒车，观察库角A在右后视镜中的位置，它会慢慢消失，在A点即将消失之前快速右打满方向盘； 倒车过程中注意观察左后视镜，注意库角从右往左数第二根虚线，当其完全出现在左后视镜时迅速回正方向盘 观察左后轮轴心与地面的垂线P和和入库虚线延长线Q的位置关系，当左后轮中心点在延长线时迅速左打满方向盘； 观察左边车身，与入库线的位置关系，当与入库线平行时停车； 打左转向灯，挂前进档，准备驶出车库； 观察最左边线，如果左边线的延长线在车速表的40时回正方向盘，继续向前开； 观察左边线延长线到达仪表的160的方向时，右打一圈，待车头摆正后回正方向盘，驶出考试场地。 操作要点 上面第4步是一个重要的调整节点，需要格外注意车身与入库虚线的夹角，如夹角比较小，那么就需要早一点左打方向盘，否则可以晚一点打方向盘； 出库的第7步和第8步容易出错，一定要注意操作迅速。第7步回正慢了，就车子离AE边线会比较远，容易碰到边线，如果回正早了，后面第8步容易碰到AE边线。 第8步时右打一圈，不是半圈，一定要到位。 此项目出库时需要打左转向灯。 扣分情况 车辆入库停止后，车身出现，不合格； 项目完成时间超过90秒，不合格； 行驶中车轮触轧车道边线，每次扣10分； 行驶中车身触碰库位边线，每次扣10分； 出库时不适用或者错误使用转向灯，扣10分； 中途停车超过2秒，每次扣5分； 窄路掉头 操作步骤 右车身与A边线保持30公分左右距离行驶，缓慢驶入窄路； 观察前车窗中的B线，待其快消失在车窗前（此时车头与边线B的距离在50公分左右），迅速左打满方向盘； 观察C边线与车内门锁交点位置，在门锁后端边沿时停车，挂倒挡，迅速右打满方向盘； 观察左后轮与边线A的相交情况，当其任意部分与边线接触时停车，挂前进档，迅速左打满方向盘； 缓慢驶出考试场地，此项目考核结束。 操作要点 该项目不需要打灯； 操作方向盘的顺序很好记，左打满 -\u0026gt; 右打满 -\u0026gt;左打满，挡位是前进 -\u0026gt; 倒退 - \u0026gt; 前进。 换挡和转方向盘速度要快，节省时间。 扣分项 超过2分钟未完成，不合格； 三进二退未完成的，不合格； 车轮轧道路边缘线的，不合格。 曲线行驶 操作步骤 如图所示，从左向右行驶，在进入曲线之前需要摆正方向盘，行驶在车道正中间； 缓慢驶入曲线，观察左边曲线与左后视镜下边沿的交点，它会沿着后视镜下边沿从左往右缓慢移动，等到移动到左后视镜根部时，方向盘左打一圈； 在行驶中随时微调方向盘，保持左后视镜的左边沿距离左边曲线一拳左右的距离； 当行驶到左边线的大B点时到达了反向弯，提前拉起左前窗的挡风玻璃，继续观察左边曲线与左后视镜下边沿的交点，它会沿着后视镜下边沿从左往右缓慢移动，等到移动到左后视镜根部时，方向盘迅速回正； 此时观察左边曲线的出口处边线，随着车辆向前行驶，它会慢慢消失在前车窗的视野中，当它消失时候迅速右打方向盘一圈，头向左靠在车窗玻璃上； 观察左边线延长线与车内门锁把手的交点，在行驶中随时微调方向盘，保持该交点始终保持在门锁把手的长度范围内。此处有调节技巧，如果交点超出门把手前端，则微微向左打方向盘，如果交点超出门把手后端，则微微向右打方向盘。 待车辆驶出曲线出口时，回正方向盘，该项目结束。 操作要点 始终观察左后视镜和左边线的情况，不需要查看右边的情况； 方向盘的调整量为一圈，要么左打一圈，要么右打一圈。 扣分情况 车轮轧道路边缘线，不合格； 疑问点 直角转弯，是完成转弯之后关掉转向灯，还是现在这样在准备转弯前就关闭转向灯？ 倒库的步骤3方向盘的调整量是半圈还是一圈？ 参考资料 如何顺利一次性通过驾考科目二考试？ - 知乎 全文完🚀\n","date":"2023-01-02T11:30:42+08:00","image":"https://pic.imgdb.cn/item/63b250f65d94efb26fab6812.jpg","permalink":"https://blog.bugxch.top/p/%E4%B8%8A%E6%B5%B7%E9%A9%BE%E8%80%83%E7%A7%91%E7%9B%AE%E4%BA%8C%E8%80%83%E8%AF%95%E6%80%BB%E7%BB%93/","title":"上海驾考科目二考试总结"},{"content":"前段时间买了个nas，折腾了两个礼拜多，总算摸到点门道。\n本月初心里痒痒拿下威联通TS-216，某东价格1199，为什么会买这个呢？我的脑回路也比较清奇，我在之前给我的R2S计划启用openclash，但是发现那个固件的插件有问题，于是在网上搜索了一番，找到了R2S/R4S 设备 | 易有云 文档中心的固件，发现安装之后的界面还挺好看，openclash也顺利用起来了（虽然后面是从Tags · vernesong/OpenClash · GitHub页面自己下载手动安装的）。\n细看上图里面有个易有云的存储服务，顺手google 下什么是易有云，发现就是个NAS。我在某宝上搜了，发现盒子比较简陋，可以安装一块硬盘，非常便宜，就下图的样子，看起来玩得花样比较多。联想之前华为发布家用NAS，加上我的时光相册不能上传比较大的图片和视频，让我觉得云盘备份瞬间不香了，要不整个家用NAS玩玩？\n于是，我又在最新NAS存储新品推荐_什么值得买下面泡了一段时间，发现NAS用的最多的就是群晖和威联通，鉴于威联通颜值能打，而且看到论坛里面的讨论这么全面，将来入手遇到问题也能方便找到解决方案，最终放弃了某宝非常便宜的方案，买了入门款的威联通TS216，先把这个玩熟，等过几年用的差不多了，升级的时候再换更高级的吧。\n基本配置 这个东西买回来很快，但是我发现要真的玩起来还是有比较高的学习成本的，下面是我边学边练的折腾记录。\n安装系统 我刚开始安装的是西数红盘4T plus，后来发现同步照片的时候NAS炒豆子的声音太大了，所以后来又买了两条m.2的闪迪500G固态硬盘，2个硬盘600大洋，所以整个一套下来应该花了3400大洋（还是蛮肉疼的）。\n安装系统可以参考NAS无法拒绝SSD的N个理由！这些厉害玩法，你知道吗？，选择RAID 1阵列。为了搞清楚安装里面各种名词，我也看了很多文章，终于搞清楚了存储池、静态卷、厚卷、精简卷和RAID、Qtier这些名词的含义，当时本来计划看说明书的，奈何500页太长了，而且也发现了威联通居然还有个QNAPedia网站，全英文你能信？下图是我当前存储池的状态\n远程访问 家用NAS需要能在外部访问才能发挥它最大的威力，这一节从下面的几个步骤一步步做介绍，我主要参考了威联通 TS-451D外网高速访问：公网IP、DSM主机、端口映射、DDNS动态域名设置_NAS存储_什么值得买，基本上照着配置即可。需要注意两点：\n外网IP申请下来之后，使用中国电信的网络app设置DMZ主机时，需要输入的是威联通连接的那台路由器在光猫中的IP地址。这里要特别提醒使用软路由的朋友，我的网络拓扑是入户光猫 -\u0026gt; r2s软路由 -\u0026gt; 无线硬路由（有线桥接模式）-\u0026gt; 威联通，所以我要输入的就是r2s的软路由在入户光猫中分配的ip地址，这个可以在中国电信网络关键app首页最下面的在线设备中看到。 我的r2s刷的是openwrt系统，这个系统的内部端口转发可以参考OpenWRT 设置 端口转发 小白教程 - 彧繎博客，我的端口转发设置长这样\n如果没有外网IP，可以使用威联通自带的myCloud和DDNS服务，但是速度比较慢，设置系统查看状态应该可以，但是下载上传文件就勉为其难了。更好的方案是使用有偿的服务，比如上面易有云就提供内网穿透服务，最高到8M速度，我后来没有用。\n域名映射 如果外网IP申请下来，一般是在浏览器中直接输入外网IP地址和端口号，但是外网IP会因为光猫重新上电而发生变化，这个就不太方便，所以可以绑定域名，自动DDNS解析解决这个问题。我参考威联通使用腾讯DNSPod域名DDNS解析完全小白指南+HTTPS证书部署（阿里、华为等国内主流云服务商通用）_NAS存储_什么值得买设置好的，但是没有做最后的证书配置。\n安装APP 以我一周左右的使用经验来看，最有的APP有下面几个，\nQsirch，智能搜索各种文档，甚至支持图片的OCR识别后的内容搜索，非常好用，高级搜索功能非常好玩，甚至可以根据相机的镜头筛选照片； QuMagic，智能相册，比较有趣的是人物识别、物体分类、地点分类和智能相册； Qfiling，非常好用文档整理软件，填写好条件和要求，就可以自动将源目录中的文档按照要求搬移到对应的目的目录里面，比如我喜欢使用相机拍照，就可以使用这个功能，将所有的富士相机的照片按照年/月的文件夹的结构给我归档到多媒体的文件夹里面 上面最有用的3个软件具体怎么配置和使用可以参考\nQfiling，我注意你很久了！——威联通文件整理神器使用体验_NAS存储_什么值得买 Qumagie 与 PhotoPrism丨两个NAS相册神级工具，AI人脸、元数据、搜索功能都有_NAS存储_什么值得买 QNAP威联通发布Qsirch 5.0搜索神器，图片搜索和归档更便捷好用_软件应用_什么值得买 应用设置 同步Obsidian笔记 从去年开始，我在初识卡片笔记写作法 - 不写，就无法思考里面使用Obsidian，之前也使用过坚果云 + folerSync同步PC端，但是同步效果不理想。这次使用NAS，我发现APP Center里面有 Resilio Sync，顺便就google了下，发现很适合NAS啊，可以参考Resilio Sync | 全平台多设备文件同步/传输终极产品 - 知乎。这个软件特点是可以多达60M+的速率在所有安装该软件的跨平台设备上同步，但是需要保证多个同步文件夹中至少有一个是在线的。所以，我的做法是在NAS上安装该软件作为共享的源文件夹，然后在PC和手机端分别安装并同步这个源文件夹，都赋予读写权限，这样无论哪一端的修改都会同步到其他两端。我在手机上安装后使用，可以实现瞬时同步，体验极佳。\n同步博客 使用类似的方法，我将hugo博客的文件夹也放在了NAS上，PC端与其同步，这样就能实现二者的同步了。\n搭建书屋 参考NAS指南 篇三：打造最强家用NAS之私人书库搭建教程_NAS存储_什么值得买就能搭建起个人书库，唯一的缺憾是不能批量上传，我把中亚上面的几乎所有电子书和文档全部上传到NAS电子书服务器上了。\n参考资料 威联通 TS-451D外网高速访问：公网IP、DSM主机、端口映射、DDNS动态域名设置_NAS存储_什么值得买 新手轻松玩转的NAS丨威联通TS-216 +东芝N300开箱体验_QNAP TS-221_游戏硬件存储-中关村在线 NAS无法拒绝SSD的N个理由！这些厉害玩法，你知道吗？_NAS存储_什么值得买 Resilio Sync，兼具文件同步/共享/备份/加密的神器 - 知乎 全文完🚀\n","date":"2022-12-19T16:35:51+08:00","image":"https://pic.imgdb.cn/item/63b250255d94efb26faa6c53.jpg","permalink":"https://blog.bugxch.top/p/nas%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/","title":"NAS折腾小记"},{"content":"疫情期间，复习下之前的指数基金投资指南。\n这本书我在2018年10月左右第一次读完的，从那个时候开始投资基金到现在差不多3年半的时间。经历过还算完整的高峰和低谷，直到去年底收益倒还不错，但是今年开年到现在亏损比较严重，刚好疫情居家隔离，正好把这本书复习下，重新理解下之前不甚明了的概念，梳理下内容，系统化投资策略。\n我的理念 凡是投资收益强过银行的长期定存收益的方法，都值得学习。\n这是我开始入坑基金投资的缘由，出身农村，视野狭隘，但是经历过2015年房地产暴涨的行情，我意识到金融的重要性。当劳动所得的收入的涨幅无法追上金融资产的涨幅时，当看到有人凭借房地产买卖早早实现财富自由的时候，我觉得是时候主动去理解经济运行的逻辑了，而且要多元化自己的收入来源，仅仅依靠劳动所得的收入长远看根本抵不过通货膨胀带来的贬值损失。\n越早学习投资受益越大。\n有工具不用，和没有工具是两回事。学会金融和经济的逻辑，是在现代社会有质量生存的基本技能。我要是很早就是意识到房子的金融属性，也不至于眼睁睁错过2015年房子的涨幅而陷入绝望。越早学习投资，越早意识到金融经济的重要性，受益越大。\n金融市场充满波动，有高峰有低谷，赚钱赚的就是这个利差。\n波动越大，不确定性越大，风险越大，但是峰谷差值越大，利润也越大。\n基础知识 这本书的核心内容是基金介绍和指数基金挑选这两个章节，展开说说。\n基金分类 我把书里面介绍的基金分类罗列在下面的表格里面，一目了然。\n宽基指数 基金名称 基金代码 指数特点 上证50 000016 大盘股为主，也称为蓝筹股。只有上交所的股票，没有深交所的股票。 沪深300 000300和399300 上交所和深交所规模最大、流动性最好的300只股票，影响力十分巨大。 中证500 000905和399905 在沪深300之外的公司和最近一年的日均市值排名前300的企业排除，挑选剩下的前500个企业。国内中型公司的代表。 创业板指数 399006 创业板上市公司中，挑选出规模最大、流动性最好的100只股票。 创业板50指数 399673 是从创业板指数的100家企业中，再挑选出流动性最好的50家，相当于创业板的“上证50”。创业板指数容易暴涨暴跌，中小型公司为主，盈利不稳定。 上证红利指数 000015 上交所过去两年平均现金股息率最高的50只股票 中证红利指数 000922/399922 从上交所和深交所挑选过去两年平均现金股息率最高的股票，成份股数量扩大到100只 深证红利指数 399324 专门投资深交所的高现金股息率的股票，不过成份股只有40只 红利机会指数 CSPSADRP 过去3年盈利增长必须为正；过去12个月的净利润必须为正；每只股票权重不超过3%，单个行业不超过33%。 基本面50指数 000925/399925 基本面得分前50名。和上证50相似，但是考察更全面 央视50指数 399550 是专家们投票选出来的50只股票，规则不透明，主观性较强，兼顾龙头企业和小盘股。 恒生指数 HSI 历史悠久、收益稳定。所有在中国香港上市的公司中规模最大的50家企业。投资者以境外为主，容易受到境外市场的影响，避坑老千股。主要通过QDII的ETF联结基金投资。 H股指数 暂缺 内地注册，香港上市的前40只成分股。境外人士通过H股投资内地企业，和A股关系密切，与上证50指数重合度高。 上证50AH优选 暂缺 与上证50几乎相同，但是选的是A股和H股中相对便宜的那一个。推荐华夏上证50AH优选指数。 纳斯达克100指数 NDX 全球规模最大信息技术类公司的指数，市值最高前100个公司，基本都是行业龙头。通过QDII基金投资，如果基金公司的外汇额度不够，会停止申购。 标普500指数 SPX 美国影响最大的指数，并不全是大盘股，同样需要通过QDII基金投资。 上证综指 000001 影响力较大，上证股市的晴雨表，追踪这个指数的基金通过抽样挑选一部分股票。 此外，还有中证公司开发的其他的指数\n中证100：大盘股为主，沪深两市规模最大的100只。 沪深300：大盘股为主，沪深两市规模最大的300只。 中证500：中盘股为主，排除沪深300后，沪深两市规模最大的500只。 中证800：大中盘股，沪深300+中证500。 中证1000：小盘股为主，除去中证800外，最大的1 000只小盘股 行业基金 行业分类很多，作者在这里主要推荐日用消费品和医疗保健行业的指数，此外有一部分强周期的行业指数，在底部购入也会比较好。\n消费行业 基金名称 基金特点 上证消费指数 从上交所挑选必需消费行业公司 上证消费80指数 从上交所挑选80家规模最大的必需消费行业公司 中证消费指数 从中证800，即沪深300和中证500中挑选必需消费行业公司 全指消费指数 从所有上市公司中挑选必需消费行业公司，覆盖范围最广 下面是常见的消费行业基金，\n医药行业 中证医药指数：又称中证800医药指数，是从中证800指数中挑选医药行业。 中证医药100指数：挑选了100家大型医药股，每只股票买入相同的金额。 上证医药指数：只投资上交所的医药行业公司。 全指医药指数：从整个A股中挑选医药行业，它覆盖的医药公司是最全的。 细分医药指数：挑选了医药行业细分领域的主要公司。 300医药指数：挑选了沪深300指数里的医药行业公司。 500医药指数：挑选了中证500指数里的医药行业公司 2020年新冠疫情之后，医药行业有一波比较强的周期，当前奥密克戎肆虐，很多国外研发了mRNA疫苗，中国内地的复星医药也在研制，可能有一小波机会。\n养老行业 覆盖范围较广，人口老龄化越来越严重，长期来看试一个比较好的品类\n金融行业 银行业 书本里面介绍的篇幅比较大，银行业的利润受宏观经济的影响较大，下行周期风险准备金增加，国家降息，银行收益减少。反之就比较好，银行业在宏观周期的波动中反复。书里面重点介绍了银行在国民经济发展中的作用，介绍了银行不同的盈利模式，可以了解下。\n投资银行也有两种方式，之前的的上证50指数、基本面50指数、H股指数、50AH优选指数等相关的指数基金已经包含了很多银行股（当前的银行股在股市中占比很高），或者专门投资银行股的中证银行指数，\n证券业\n应该是金融行业中周期性最强的行业，不适合长期持有，基本面与股价走势趋同，因为我不喜欢投机性很强的行业，所以忽略。\n保险业\n保险业的上市公司不多，只有中国平安、中国太保、中国人寿和新华保险这4家，没有纯粹的保险行业指数基金。\n总结下，基本上如果已经关注了上面的4只指数，就没必要再单独购买持有了。\n地产 现在基本是下行周期了，长期看恢复乏力，不需要关注。\n军工行业 祖国终将统一，祖国必将统一。这个品种与国家政策影响比较大，投资难度较高。但是，我国最近几年军事工业发展迅猛，可以从江南造船厂分析报告看到国内第三艘航母即将下水，未来可期\n白酒 目前比较惨，目前国内的白酒基本上已经包括在消费行业指数里面了。\n环保 国内环保长线发展，值得关注。\n其他要点 避开规模较小的指数基金。可能强制赎回，导致投资中断，这一条可以在基金的基础资料中看到，一般而言少于1亿规模就不要申购了。 增强型基金在追踪指数的基础上，去做一些操作来赚取超额收益，但是具体的操作不公开，有一定的风险。指数基金投资尽量挑选费用较低、规模较大、历史悠久、误差较小的指数基金产品，或者是挑选有一定超额收益的增强型指数基金。 红利指数有下面的3个特点： 高股息率，在熊市更有优势； 能持续发放现金股息的公司，盈利能力和财务健康状况好的概率越高。 提供分红现金流 QDII指数基金，合格境内机构投资者主要用于投资中国香港、美国等市场的股票。 基金分场内基金和场外基金两种。相对于场外基金仅有”申购赎回”的交易渠道，场内基金还有“买入卖出”的渠道。但是，这里推荐场外基金的投资方式，操作方便，省心省力，对于一般的工薪族来说足够。 联结基金复制场内的指数，通过场外基金的方式申购和赎回，一般看到的ETF（交易型开放式指数基金）的联结基金就属于这一类。 价值投资核心理念 判断清楚价格与价值的关系，在价格低于价值的时买入，在价格高于价值的时售出。\n这就是价值投资的核心理念，要求能够合理预估投资产品的价值。所以自然就引出两个问题：如何评估股票的价值，评估后如何实操？\n如何估值股票 常见的股票估值由下面的评估指标。\n指标 定义 意义 适用范围 市盈率 PE，公司市值 / 公司盈利 愿意为获取1元的净利润付出的代价；估算市值 流通性好、盈利稳定的品种。周期性行业不适用，高速成长期股票不适用的，一般进入沪深300、中证500指数的股票符合条件。 盈利收益率 市盈率的倒数 购买公司之后一年盈利能够带来的收益 同市盈率是适用范围 市净率 PB，市值/净资产 净资产是资产减去负债，比盈利更加稳定，和企业净资产收益率密切相关，尤其对于拥有大部分有形资产的公司来说比较合适。 当企业的资产大多是比较容易衡量价值的有形资产，并且是长期保值的资产时，比较适合用市净率来估值。包括证券、航空、航运、能源等行业。 股息率 过去一年的现金分红与市值的比率 股息，则可以将公司的净利润增长映射到投资者的现金收益上。股息是一个既能长期持有股权资产，又能同时享受现金流收益的好方法。 盈利收益率 * 分红率 = 股息率，一般而言分红率不变，所以股息率间接等同于盈利收益率。 需要区分股息率和分红率的不同，\n股息率是企业过去一年的现金派息额除以公司的总市值，而分红率是企业过去一年的现金派息额除以公司的总净利润。这两个比率，分子一样，但是分母一个是公司市值，一个是公司当年净利润。\n需要注意，任何一个基金指数本质上是一堆股票的加权和，所以可以将上面的概念推广到这些股票上，比如上证50的盈利收益率就是指数后面的这些股票的盈利总和除以市值总和，以此推算其他数值。本书的作者在自己的公众号的每个股票交易日之后会贴出上述指数的这些指标，可以搜搜银行螺丝钉之后关注后查看。比如下面这张图就是最近一次的指数参数表\n投资实操 书中介绍了两种不同的方法，大概总结以下\n盈利收益率法 当盈利收益率大于10%时，开始定投，分批买入。当盈利收益率低于6.4%时，暂停定投，分批卖出。其他区段，坚定持有\n按照这个说法，其实参考上面的估值表格，当前可以分批买入恒生指数以上的所有的指数了。盈利收益率法也是有它的局限性的。盈利收益率的使用条件比较苛刻，只适合于流通性比较好、盈利比较稳定的品种。如果是盈利增长速度较快，或者盈利波动比较大的指数基金，则不适合使用盈利收益率法。\n博格公式法 指数基金未来的年复合收益率 = 指数基金的投资初期股息率 + 指数基金每年的市盈率变化率 + 指数基金的每年的盈利变化率\n上面的是理论计算公式，后面的两个指数是在若干年之后才能计算出来的结果，实操中实际上就围绕这3个指数进行投资。\n股息率越高，指数越低估，此时可以买入持有。 市盈率的变化在9~50倍之间周期变动。统计历史上的市盈率变化区间，计算当前市盈率在这个区间中的位置，如果较低则买入基金； 公司的盈利一般不可预测，与国家经济的发展高度相关，是我们无法控制的变量，放弃 在前2个指标比较低的时候买入，然后持有后等待均值回归。需要注意的是，对于盈利不稳定或者周期性比较强的行业，可以使用市净率替换市盈率进行评估，即在市净率比较低的时候买入。\n对于长期亏损的企业，上面的两个方法均不适用，放弃即可。\n实操公式 上面的内容已经基本上把这本书的精华讲完了，后面作者补充了一些内容，比较有价值的是实操的具体公式。这个是定期不定额的投资方法的公式\n另一个博格公式的投资公式是\n这里的$n$是投资的放大系数，一般设置成1就可以了，如果资金比较充裕，设置成2也可以。\n年龄与投资比例 指数基金是一种风险比较高的资产，我们可以用100减去自己当前的年龄，用得到的数值加上百分号就是适合投入到指数基金中的资金比例。\n比如如果当前是35岁，流动资产100万元，那么可以将100 - 35 = 65万元投入到指数基金中来。作者在书本里面提到一个不错的投资建议，\n先将100万元分成20份，每份5万元。取第一份5万元，定投到当前市场中满足条件的低估的指数基金中。剩余的19份，共计95万元，可以投入到货币基金或债券基金中。 随后的19个月，每个月再从货币基金或债券基金中提取5万元，定投到指数基金，直到配置完成。\n债券相对盈利相对稳定，这个投资方案也比将大笔的闲置资金放在银行好。\n🚀全文完结\n","date":"2022-05-14T09:46:46+08:00","image":"https://pic.imgdb.cn/item/627f0a6d09475431294c2403.jpg","permalink":"https://blog.bugxch.top/p/%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E6%8A%95%E8%B5%84%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/","title":"《指数基金投资指南》笔记"},{"content":"这是之前读书计划中《深入理解计算机系统》的读书笔记。\n章节 读书笔记 状态 第2章 信息的表示和处理 完成 第3章 程序的机器级表示 在写 第4章 CSAPP之四——处理器体系结构 在写 第5章 计划中 计划中 全文完🚀\n","date":"2022-05-08T07:32:49+08:00","image":"https://image-1258996033.cos.ap-shanghai.myqcloud.com/csapptotal.jpeg","permalink":"https://blog.bugxch.top/p/csapp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","title":"CSAPP读书笔记"},{"content":"继续之前的CSAPP读书笔记，这是第3章的读书笔记。\n第3章介绍计算机的底层机器编码，包括常见的基本数据、为了执行机器指令而设置的寄存器、算术和逻辑操作以及控制的指令。3.7节详细介绍了过程的概念，最后是其他数据结构在计算机机器代码的表示。\n实验工具 要想研究底层机器指令，最直观的就是汇编程序，参考书本里面的介绍，以linux系统的gcc程序为工具，有两种方式可以得到。如下图所示，是一个 hello.c的程序从高级语言程序编译成机器代码的过程。\n使用编译器运行如下命令\n1 gcc -Og -S hello.c 可以得到 hello.s的汇编文件，该文件仅仅包括汇编指令，没有二进制的机器码，如下图所示\n不过对于理解本章节的内容已经足够。\n使用汇编器进一步可以将 hello.s翻译成机器语言指令，称为可重定位目标程序，里面全是二进制码，这个就是底层机器指令，肉眼看过去就是一串二进制码，根本不知道是什么东西。可以基于反汇编的方法将该文件反汇编成汇编的代码，\n1 2 gcc -Og -c hello.c #生成hello.o文件 objdump -d hello.o #反汇编文件 得到的文件，如下所示\n与上面的方法相比，除了汇编指令之外，还有这些指令的二进制编码。\n基础概念 数据格式和指令 这些是本章的主要内容，也是理解汇编代码的基础。具体的技术细节书本里面已经说清楚了，此处仅仅对于需要特别注意的地方做一个总结。\nISA指令包括16个长度是64bit的寄存器，这是计算机运行的数据保存的地方。需要注意，每个寄存器有长度，可以覆盖1、2、4和8个字节的所有长度。\n计算机的寻址方式有如下几种\n数据传送指令需要注意下面的点\n传送的指令的两个操作数不能都指向内存位置。因此，没有指令可以直接将内存中的位置A搬移到内存中的位置B，必须先将A搬移到寄存器，之后再从寄存器搬移到内存B；\nmovl这个指令比较特殊，它是传送双字（4个字节）的数据，但是也会同时将目的寄存器的高4个字节一并清零。\n所有的汇编指令的立即数都是二进制补码编码的，如果是十进制数，也是有符号的整数。\n一般的栈结构，栈底是高地址，栈顶是低地址，数据在栈顶进出，%rsp指向栈顶。常见的栈结构如下所示\n算术指令的所有操作都是在寄存器中进行的，换句话说，如果需要将内存中的两个数相加，第一步是先把它们搬移到寄存器中，然后调用ADD指令再相加，结果也会保存在寄存器中。\n根据TEST指令可以判断一个数的正负或者零。因为testq %rax %rax指令不会改变寄存器里面的值，但是会根据(%rax) \u0026amp;\u0026amp; (%rax) = (%rax)的值来设置条件码的标志位。比如，可以根据指令结束之后的ZF的值判断是否是0，SF的值判断是否是负数等。\n根据上一条指令的cmp结果设置指定寄存器的值，使用下面的表格实现，想起来挺烧脑，了解即可\n跳转指令的底层机器编码中的跳转地址使用相对编码的形式。注意，汇编器生成的*.s中是汇编语言，里面跳转指令的地址偏移是绝对值，但是通过链接器或者反汇编得到的二进制编码就是用相对寻址编码的。还是书里面的例子。汇编文件如下\n*.o反汇编之后的文件如下\n注意第2行的跳转指令的地址二进制编码是03，这个是下一条指令地址的相对值，也就是跳转的地址（8) = 下一条指令的地址(5) + 偏移量(3)。第5行也一样，5 = 0xd + f8(-8)。这样做的好处之一，是可重定位目标程序通过链接器链接之后，指令的虚拟地址发生变化，但是二进制编码依然保持不变。\n函数跳转 问题解答 学习本章的内容之后，应该可以回答下面的问题\n为什么switch的case必须是整数？\n还没写完🚀\n","date":"2022-05-08T07:27:38+08:00","image":"https://pic.imgdb.cn/item/6277012f0947543129b619f5.jpg","permalink":"https://blog.bugxch.top/p/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/","title":"程序的机器级表示"},{"content":"之前的blog换过很多个评论系统，这次换成giscus试试。\n操作比较简单，参考giscus页面上的配置一步步做就可以了，最后将下面的生成的信息填写进博客的config.toml配置文件即可\n全文完🚀\n","date":"2022-05-08T06:53:47+08:00","permalink":"https://blog.bugxch.top/p/hugo%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%8D%A2giscus%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/","title":"hugo博客更换giscus评论系统"},{"content":"之前在win10上安装了双系统，最近发现wsl的ubuntu也挺香，所以就尝试卸载manjaro。\n基础流程 按照这个视频操作即可。\n参考资料里面是另一种卸载的方法。\n参考资料 win10和ubuntu双系统下彻底删除ubuntu系统和grub引导_喵学长的博客-CSDN博客_双系统删除ubuntu的grub引导 全文完🚀\n","date":"2022-05-06T08:59:46+08:00","permalink":"https://blog.bugxch.top/p/%E5%AE%8C%E5%85%A8%E5%B9%B2%E5%87%80%E5%8D%B8%E8%BD%BD%E5%8F%8C%E7%B3%BB%E7%BB%9F/","title":"完全干净卸载双系统"},{"content":"四年前跳槽时写的一篇旧文，现在可以贴出来放在这里了。从去年开始，我就有跳槽的想法，陆陆续续面试过华为，中兴和一些其他的企业，到前不久拿到中兴算法offer，跳槽的过程至此告一段落，所以现在是一个静下来好好思考的机会。\n什么才是好工作？ 再有10天我就工作满4年了，虽然目前为止我仅仅在一家公司工作过，但是不管是结合自己的切身感受，还是与朋友同学聊天了解其他公司的情况，又或者通过媒体的报道，对于什么是好工作我自己也有一些体会。世界上没有十全十美的工作，也就是说下面列出的衡量一个工作的指标并不能样样都满足，所以我依照重要程度递减排序，大体上可以分为精神和物质两个方面。\n工作内容好。抛却功利心，这是我认为最重要的指标，对于大多数人来说每天24小时除了睡觉吃饭之外的大多数时间就是工作，因此是否热爱是否能够全情投入很重要。越是热爱，越会钻研，越能达成不错的成就。这一点细分起来又可以分为不同的层面\n充满挑战。每个人都讨厌无聊，相信不管什么工作如果没有挑战性也不会有太大的热情。挑战可以逼迫个人逃离舒适区，在不断赢得挑战的过程中个人的能力就得到锻炼，而且会很有成就感。需要特别区分工作量饱满和工作内容饱满这两点的不同，前者大多数是技能的重复使用，后者是技能的深度和广度的拓展，对个人而言一定要跳出前者的陷阱。\n可持续发展。工作的内容很饱满，富于变化，无论从深度还是广度都不错的延伸，值得投入精力去延展。通信行业目前来看还是有蛮大的创新空间，整个行业也在不停向前发展，但是具体到每个岗位还是固定的内容居多，算法岗就比协议岗的内容更加精深，它的横向延展性也更好（可以转深度学习，图像处理等等）。这一条注定每个人不可能只从事一个岗位，必然会有岗位的变迁和轮换，每个人的职业生涯是个动态变化的过程，个人应该结合自己阶段性的兴趣以及能力主动寻求变迁的机会。\n成长空间大。上一条在很大程度上自我可控，这一条更多的是外部条件对自我的认可，成长空间可以分为两方面。\n薪酬上涨空间大。这是对自我工作的直接的肯定，但是这一点需要看的长远些，可能在目前的公司并不能获得满意的薪水，但是同行业其他公司有不错的待遇，可以将目前的公司当做跳板，一两年后跳槽就可以得到不错的薪水。\n职位升迁空间大。基本与薪酬一起涨，好公司不会亏待好员工。\n企业人性化。在前面两条满足的前提下，这个是更高级的需求。下面是比较重要的几个问题。\n公司是否尊重员工？高层是否与底层员工有闭环沟通？是否愿意改善员工的工作环境（工具软件/电脑桌椅/办公用具/IT支持等等）以及细微的需求？\n公司是否愿意与员工分享成果？是否愿意主动加薪？是否愿意同甘共苦？\n公司是否有公平完备的考核体系？每个员工有公平公正的竞争环境，才能保证优秀的员工脱颖而出。将加班时间作为考核指标，不仅无形消耗员工的健康和热情，而且大部分员工开始磨洋工，浪费精力浪费时间，就是公司人事管理的惰政和无能。\n公司是否有考虑员工能力成长？是否有完备的培训体系？是否有轮岗制度？员工内部按需转岗是否顺利？\n按照以上的各个指标来看，展讯几乎哪一条都不满足，满足于小恩小惠，就是中了公司的圈套。\n前两天我导师告诉我一个机会，他在美国读书认识的朋友回国创业，就在张江创办了一家专注物联网芯片的创业公司，现在缺协议栈的人，问我愿不愿意去。前两天，饭桌上一起聊聊，感觉老板还不错，今天打算过去和他们的团队聊聊。晚上面试，肯定是大家互相了解的过程，我需要理顺自己的思路，想想自己真正想要了解的东西，所以有这篇文章。\n为什么要从展讯离职？ 参照上面的好工作的标准，可以总结出来如下三点：\n成长空间有限。技术能力提升有限，每天的大部分时间是解决大量重复的简单的客户问题，最大的问题就是你的所有专注的持续的思考总是会被随时打断，技术上比较难专注下去。展讯内部并不鼓励轮岗，因此无论纵向还是横向技术提升的空间都被堵死，这就决定了基本没有技术成长和突破的可能性，这最令我焦虑和恐慌；薪资岗位提升空间有限，技术成长是薪资岗位突破的前提条件，因此我并没有期待会有多好的未来。\n企业文化糟糕。展讯已经成为业务驱动型公司，攻占手机中高端芯片的策略基本失败，展讯内部对工程师并不友好，管理团队不信任工程师；恶性加班文化盛行，2014~2016年各个部门为了争取上市利益，恶性竞争加班时间，管理层在年末考评上也会考察员工的加班时长；基层员工和管理层的沟通很少，工程师对公司愿景并不了解，鼓吹奋斗加班拼搏，只谈奉献，不谈薪酬。CEO的很多次谈话里总是无意间表达出对工程师的不屑，个人没有太多归属感，我就是流水线上的一个螺丝钉，想用就用，不想用就扔掉。\n从展讯学到什么？ 持续稳定的收入，至少可以在社会立足。毋庸置疑，能在上海生存下来，全靠公司了。\n解决问题，精益求精。和学校相比，个人能力和思维完全转换过来，以前以完成任务考取高分为目标，现在已解决问题服务客户为导向。凡事都要准确分析从根本上高效充分地解决，而不是考90分考80分就差不多了。不再应付差事，而是坚定精准完美解决问题，这是学校和公司的办事思维上的最大区别。\n了解公司运作机制。项目从立项，开发到完成的整套流程，基本收有一个清晰的认识。\n为什么来我们公司？ 这个问题可以换成，我们公司吸引你的是什么？我想考察如下几个方面：\n成长空间，保证成长的速度。我还年轻，我不甘于全面平庸化，我不想做流水线上的螺丝钉，我还想拓宽技术的深度和广度。我希望公司能有不错的成长的环境，有足够多的机会去学习交流，有足够好的任务锻炼个人的技术能力，有足够好的团队切磋交流。如果没有上面的这些，我呆在大公司更好，因为收入稳定，而且承担的责任更小，我还可以过得更舒服一些。\n企业文化。灵活，公平，工程师的企业文化，很多人全力以赴专注于一件事，\n我的疑虑是什么？ 关于我自己 我的直接上司是谁？他为什么加入这家公司？平时花费时间最多的事情是什么？ 你们对我的期许是什么？我的职责是什么？能否保证我的工作质量？工作量饱满还是工作内容饱满？ 我是否有机会发展其他技术能力？我是否有机会发展其他软技能？ 团队是否靠谱 管理团队都来自哪里？之前具体做什么工作？是否有丰富的管理经验？ 技术团队都来自哪里？之前具体做什么工作？是否有丰富的技术经验？是否在工程师文化比较浓厚的公司待过？ 基层员工之间以及管理团队和基层员工之间平时是否有充分的交流？有问题如何解决？ 员工的精神状态如何？ 公司的发展前景 创始人为何创立该公司？一时兴起还是深思熟虑？是否有持续为之奋斗的决心？ 如何理解物联网这个行业？有什么样的期许和愿景？ 竞争对手有哪些？如何脱颖而出？ 公司的发展计划如何？市场定位是否清晰？客户群是什么？什么时候出产品？产品是什么？是否有其他的计划？ 企业文化 是否能保证公正对待？ 如何激励和惩罚员工？ 是不是有随时被解雇的可能？在什么情况下会解雇我？ 我是否可以掌控自己的节奏并持续发挥影响力？ 回报和收入 公司的资金来源有哪些？目前的资金如何？最近一年有没有新的融资计划？ 是否有五险一金等基本的收入保障？ 是否能保证团队成员的收入维持在一个合理的水平上？ 波动有多大？我能维持的最低的生活收入为多少？ 如果伴随公司成长了，我之后会有什么样的回报？ 个人决策要结合年龄，贷款，能力高低等等因素，目前我这个阶段，要不要去一家公司，要不要继续待在一家公司，我看中以下几点。\n时间宝贵，尤其是25~35岁的黄金十年，容不得浪费。 能力提升，无论是硬技术还是软技能，最好每天都能有技术提升的幸福感。 内心感受，我是否主动，积极，对要做的事情充满热情。 物质回报，当然越多越好，至少与我的贡献匹配。 撇开该不该去创业公司，先聊聊我在展讯这几年工作的感受。26岁入职，到现在4年多，前两2年除了加班累成狗，我还算满意，至少从啥都不懂到能处理大部分工作中的问题，诚惶诚恐得拿到些股票，后来又调薪，无论是技术还是收入感觉都还不错。但是从15年开始，我就觉得迷茫了，工作强度每月100+/小时，工资却不见涨，内容大部分是掉网掉话，我就是个人力bug转发器，技术上没啥成长，心里越来越焦虑，工作越来越没热情，待着没劲。\n回头再看股票，从承诺的200万到15万，再想想套现的时间和将来提现去掉税费之后的所得，我觉得跳槽去华为2年的年终奖直接可以秒杀吧。股票这事，无非就是5年时间，是待在展讯一直等到股票套现所得的收入高呢还是跳槽去别的公司累计获得的薪资和奖金的涨幅更高呢？我觉得大家都不傻，心里都有数。\n能力不见长，当然有我个人的原因，我不够主动，不够敏锐，职场上更多靠自己。但是我觉得也不能全怪个人，你问我想不想看？我想看，但是机会和环境也很重要：第一，有没有机会去做能够提升技能的事情，第二，有没有环境给你去做这件事。我个人觉得机会是很少的，项目少，而且环境也不能保证，因为时间少，展讯的研发不仅是研发也是维护，现在又兼任FAE了，责任重大啊。4年时间我就没有休过长假，最长也就过年时候连续的2天时间，敢说自己是勤勤恳恳，兢兢业业，交给我的任务大部分都能很好解决，没出什么版本回退啊客户退货的乱子。即便是这样，每天过得忙忙碌碌，从前两年支持三星到现在的客户接口人，CS域问题多且杂，我印象里从来没有长时间的比较闲的时候。腾点时间出来看看LTE？三星和客户问题处理起来既费时又心累，三星问题又有新log了，FAE打电话过来催，侯奇你赶紧看啊，今天下午要有更新，客户问题24小时就要逾期了，这个问题96小时能不能解决，上次客户问题开会，有领导还提议你们客户支持接口人不要解bug了，就专心assign和总结组内bug吧，哎，我不想说啥了。\n总之，内心感觉就是心累，干着没劲，而且看不到缓过来的时间，再等半年？再等一年？算了，还是直接找别的锻炼人的地方去吧，时间宝贵，我耗不起。\n至于公司层面的管理水平，激励机制，和我目前关心的个人成长比起来，不太重要，不过到底怎么样，我觉得大家心里都有数，我就不做评判了。\n我最想要的是什么？\n志不在协议栈，而是由协议栈引申出来平台，操作系统和DSP等其他的技能 全情主动的投入。积极主动，全情投入，不想确认2G版本，不想继续看2G的客户问题，不想在5G研发时候还受到2G的牵绊 硬技能和软技能的双份提升。不仅是解决技术问题的能力，还有管理团队的经验 项目 展讯 小公司 技能提升 5G协议栈尤其是层2的设计，调试经验，速度一般（70） NB-iot的全栈协议，甚至于DSP/平台的调试经验，倒逼成长，速度很快（60） 全情程度 2G很可能没法甩干净，需要解决紧急客户问题，确认版本case（60） 全身心投入，无客户问题的忧虑 （90） 自由度 PSIT测试，束手束脚，有深度，但是可能想做的一直做不到（60） 自由度很大，只要能解决问题，工具方法软件技术不限（90） 薪资待遇 一般，无成长 （60） 未来可期 （90） 成长空间 一般，职位不会变化 （60） 未来可期，项目管理经验，带团队经验都会有 （90） 风险 两年内风险为0 （100） 前两年风险不大，随着产品的优劣风险会变化（60） 全文完🚀\n","date":"2022-05-04T07:28:27+08:00","image":"https://pic.imgdb.cn/item/6271bb480947543129ed3ab6.png","permalink":"https://blog.bugxch.top/p/%E4%BB%80%E4%B9%88%E6%89%8D%E6%98%AF%E5%A5%BD%E5%B7%A5%E4%BD%9C/","title":"什么才是好工作"},{"content":"工欲善其事，必先利其器。对自己工具软件的一次总结。\n下面表格是对我当前电脑配置的软件工具的总结。\n软件列表 软件 功能 平台 费用 使用说明 Typora 默认md编辑器 win 付费 参考官网的Quick Start - Typora Support，我现在就在使用这个软件写这篇博客，前段时间更新到了1.0，然后收费了，觉得好用就买了，购买链接在此，89元rmb终身买断，支持最多3个终端。当前使用主题是Mo 微软To Do 任务管理 win/android 免费 跨平台任务管理软件，使用不到一个月，但是体验极好，win/android全平台同步，尤其是“我的一天”的任务，操作简单，上手容易 Edge浏览器 浏览器 win/android 免费 微软官方浏览器，之前是IE内核，现在换成chromium内核，支持微软账户书签密码同步，更重要的是兼容chrome插件，chrome用户可以无缝平移。插件丰富，同步无忧，还不占内存 Bandizip 解压缩 win 免费 简单智能，免费省心 Beyond Compare 文本比较 win 付费 程序员都知道，我还没有付费，考虑中，或者使用更低的商业版本也够用 Listary 效率工具 win 可付费 可以使用免费版，我付费买断了，和windows无缝集成，文本搜索，软件搜索，快捷操作不在话下 AutoHotkey 效率工具 win 免费 基本上等同一个叫脚本语言了，我主要用于使用快捷键快速打开软件和文件夹 Obsidian 知识管理 win/android 免费 可以付费购买它的全平台同步功能，但是基本可以通过其他方法绕过来。第二大脑的称谓不是虚的，支持双链笔记，原生支持md，数据在本地存储，支持git，插件丰富，我在2021年发现的最有价值软件 RescueTime 时间管理 win 免费 下载在后台静悄悄运行，精细统计每日的电脑时间，知道自己时间花到哪里去了 Internet Download Manager 下载 win 付费 付费买断，下载神器 亿图图示 软件绘图 win 付费 可以使用免费版，visio的替代软件，已经买断 Picasa 图片浏览 win 免费 虽然google在几年前停更了，但是仍然不影响它的使用，迄今用过的最好看的看图软件 PicGo 图片上传 win 免费 写博客上传图床的工具软件，结合复制图片的快捷键，非常好用 Snipaste 截图 win 免费 好用的截图软件 Notepad++ 编辑器 win 免费 这个就不介绍了，程序员都知道 Visual Studio Code 编辑器 win 免费 现在应该是No. 1了的编辑器了，插件很丰富 Visual Studio 2022 IDE win 免费 主要用来练习leetcode，使用C++语言 Hugo 博客生成 win 免费 当前博客的生成工具 小宇宙播客 播客 android 免费 手机上的博客终端，正常通勤路上，我基本上在听它，目前累计收听176小时 服务列表 服务 功能 平台 说明 GLaDOS 机场 win 便宜、稳定、好用 聚合图床 图床 win 好用，和Picgo，Obsidian配合使用天衣无缝 得到电子书 电子书 win/android 收录全面，排版精美 flomo 知识管理 win/android 全平台支持的卡片笔记型知识管理工具，支持标签嵌套，目前整合了得到电子书，有知有行等软件 读库 纸质书 android/纸质书 从第一期开始就关注，现在是年度会员，之前还给岳父订阅过一年 最后，放一张我今年生日买的收音机，外形和声音都很喜欢，\n全文完🚀\n","date":"2022-05-03T22:11:34+08:00","image":"https://pic.imgdb.cn/item/62725d110947543129526ae2.png","permalink":"https://blog.bugxch.top/p/%E5%B7%A5%E5%85%B7%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BB%93/","title":"工具服务总结"},{"content":"今年刚好是35岁，现在正值五一居家隔离，最近读了一些书，看了一些文章，有一些对过半人生的思考。\n按：10年前，我研究生毕业开始工作，当时计划在blogger写一封给自己未来10年的信，非常可惜，后来还是没有写下来。转眼间这个时刻已经到来，那这人生的黄金十年发生了哪些变化？我达到了我当时期望的样子了吗？\n期望与变化 虽然没有写博客，但是我记得那时跟朋友描述我将来的样子，非常世俗化，当时设想在一线或者某个二线城市拥有幸福美满的家庭，有一份不错的工作，有一辆代步车，最好出任某个公司的CTO，过得应该不错。按照我现在的状态，确实在一线买房安家，而且建立了一个还算不错的家庭，按照的社会的标准，工作的薪资也还不错，但是没有买车，也没有担任任何公司的CEO，目前仍然是一个普通的技术工人（虽然在公司里面是高级软件工程师了，但是我自认为也就是个经验稍微丰富技术工人的水平）。\n回头看当时自己设想的这些东西非常世俗化，虽然看起来生活还算体面，但是并不能保证深层次的幸福，现在的我就处在拔剑四顾心茫然的状态。只要我愿意，买辆车是很容易的，只是现在看起来基本上没有必要。所以，有了我现在的一切，然后薪资再上一个台阶，就是理想中的生活了吗？So What？我不认为是这样。\n后面做什么在回顾一生时才不会后悔？我继续往前走的原动力是什么？\n原动力转变 在拥有现在的所有以前，我人生的原动力应该就是对自己所处环境的强烈的改善的欲望，出身农村，父母亲戚无一例外得嘱咐我要努力读书，将来去城市坐办公室工作，没有农民的风吹日晒，工作轻松赚钱还容易。小时候帮家里干农活，对于农民生存的艰辛有切身的体会，这也成为我奋勇向前的原动力。如果有人说我是靠笨功夫走出来的，我丝毫不会回避这一点，小学和初中在我们村上和镇上念书，北方冬天的教室早上停电，没有暖气没有空调，我们一边点着蜡烛吸着鼻涕，一边跺脚读书，想想当时确实艰苦。我初中的学业压力最大，因为我要保持年级第一的位置，最魔性的初一，我在姑妈家里借宿，每次年级大考之前，每天醒来的第一件事就是在脑子里面不停计算我昨天考过的科目错了几分，我今天考试的科目哪些还没有背完。初一上学期的期末考试，腊九寒天我早上起来，偷偷到另一个屋子里面把政治课本老师划线的内容从头到尾背了一遍。初中同学常有打架斗殴时间，我曾亲眼目睹同学早读课时候拿砖头拍在另一个同学的脑门上，血流不止，我也听到过某天出门谁又被社会上小混混用刀子捅了，男厕所里面抽烟打架的更不在话下。这么恶劣的环境，一直到我中考结束到宝鸡中学读书有了明显的改善。不知道为什么，虽然非常苦，但是我非常怀念那段时间，就像怀念冬天推着自行车默默走出家门，抬头看到的满天星辰一样。\n这种渴求改善自身境遇，通过读书改变命运的原动力伴随着我，一直到大学毕业开始工作。我很感激当时的自己，战战兢兢一路走来，我可以很自豪得说我没有作弊过，每一门课程我都有下功夫去学，我的学业从来没有中断或者荒废过，正是曾经的努力，使我有农民般淳朴刻苦踏实的品质。\n当前的生活水平已经大大改善，不过远远称不上大富大贵，但是对于满足我个人寡淡的物质需求来说已经绰绰有余。小时候有一个梦想是每天吃香蕉，我现在每天牛奶鸡蛋都没有什么问题。我本身不好吃不好喝，面包牛奶，鸡蛋水果，再有些鱼肉和零食，也没有下馆子的习惯，也没有多么广博的社交圈，基本也满足我的营养所需了。至于兴趣爱好，我现在可以花400块买到小时候梦寐以求的高端德生二次变频收音机，花几千大洋买一个富士相机玩摄影，可以想买什么书就买什么书，想买什么会员就买什么会员，相比较儿时精神食粮的匮乏，现在可谓丰裕充足。Emmm, what\u0026rsquo;s next？最近几年，互联网上非常流行财务自由，年薪百万，创业敲钟，但是对我没有太大的吸引力，我接下来要做什么呢？\n目标转变 用更自由的方法站着把钱挣了。最基本要求，照顾好自己的家庭，将儿女抚养成人，为父母养老送终，这就要求有比较坚实的物质基础，所以追求物质财富仍然会是将来的主要任务。这里引出一个问题，我是否可以比较自由得赚更多的钱？就像《财富常识 · 构建我的被动收入》里面提到的，是否可以有被动收入？是否可以通过杠杆来获得指数级的财富增值？何妨不试一试？余生很短，时间有限，如果一直通过出卖自己的时间赚钱，可以预想当这几年达到顶峰之后不会再有什么质的的突破，而且年老力衰之后赚钱的效率肯定会逐年下降，所以需要赚巧钱。之前的刻苦踏实的品质固然好，但是更聪明得生活可以使免于担心失业的恐惧，换一种更自由的方法站着把钱挣了。当然，不能好高骛远，需要结合所处的行业和自身的特点，获得独特的知识，打造个人品牌，过简单的生活，慢慢用实力变富。里面还有一句话，非常有启发，\n任何能通过培训而获得的知识最终都会被人工智能所替代。独特知识可以被学但无法被教。独特知识要么可能与你先天性格有一定的联系，要么与你后天在高度复杂的环境学习有关。\n满足自己的好奇心。之前有一个大学的好朋友聊起来，他问我还在看数学吗？之前高考志愿我本来计划报考数学系（现在回头来看，本科数学 + 研究生计算机是一个非常不错的组合），但是迫于所谓就业的压力放弃了。但是数学依然是我没有放弃的爱好，但是我非常惭愧，基本上把之前购买的数学书籍扔完了。就像《年薪百万的迷惘》里面那个年轻人一样，我之前陷入了迷茫，但是作者的这段话，点醒了我\n但我的状态就和你完全不一样，我感觉生活的大幕才刚刚拉开，未知的东西正在等待着我去发现。在几乎没什么压力的情况下，我身体依然健康强壮，积累了 20 年的工作经验，认知升级，操作系统更新换代，除了做产品、创作，还喜欢拍胶片，听黑胶唱机，打羽毛球，玩滑板，旅行，读书……可以做的事情真的太多了，所以我开了个公司，方便自己继续自由自在的做这些事情。\n从本质上看，我的状态仅仅是对这个世界比你多一点好奇心和激情。这可能来自人的天性，也可能来自我读了很多与金钱、技能提升无关的书籍，也就是「无用之书」。对我来说读书总是让人平静和愉悦，读好书其实是和现存或已经离开这世界的优秀作者对话，对话内容往往是他几年几十年的经历和思考成果。多读书吧。\n所以，物质丰裕，精力旺盛的当下才是真正探索的开始，继续保持健康，呵护好没有泯灭的好奇心，肆意发展爱好，去体验这个世界吧。\n保持健康和乐观。这一条是上一条接下来的要讲的，健康是人生的基本盘，如果发生问题，会大大影响对于世界的体验。去菊厂的第一年我斥巨资买了健身课程，坚持核心肌肉训练，虽然价格有点小贵，但是以之前加班的高强度我的身体没有出现大问题，健身功不可没。而且，按照当前科技发展的水平，人口的老龄化时代已然来临，我预感生活到八九十岁会成为常态，但是如何保证那时候是有质量得健康的生活，就需要从现在开始注意身体健康的维护。这几天在系统研究营养学，看了几本书，受益匪浅，后面会通过饮食、运动和睡眠改善自己和家人的健康。keep fit, keep moving。\n总结与展望 回顾之前走过的路，总结下。\n做对的那些事 刻苦踏实诚实，立身之本。 长程的韧性。忍受得了枯燥难磨的工作，渡过困难的时期，但是这一点有时候会变成固执，成为缺点。 坚持搜罗、阅读、吸收可以获得的所有信息。小时候饥渴阅读所有可能的文字材料，包括课本，我小叔留下的课本，各种地摊杂志，得以因为书本走出穷困。有一句话问得挺好，如果没有书本，我们在哪里？那我很可能在某个工厂里。高中时候读杂志听收音机，南周，为学，知道社会上那么多风云人物，知道大学要选985，回头看这些在报刊杂志里获得的信息影响了我后面道路选择的大决定。大学有了图书馆更是一发不可收拾，什么书都读。这件事情虽然没有什么具体的成果，但是却有了甄别好书的眼光，将宝贵的时间用在那些真正的好东西上，才是最佳成长途径。 相信学习的功用。生物要不停适应变化的环境才能使基因世代流传下去，人类适应有一个独有的方法，就是向他人的经验学习，而且这经验借助书籍，视频，互联网，自媒体得以无界传播，如果你会几门外语，那简直就是拥有取之无尽的宝库。人类基数足够大，大到我遇到的绝大部分问题肯定有其他人遇到过，我相信通过学习可以习得解决问题的途径和方法。我现在在学习营养学，学习计算机，借助经典书籍，借助便捷的互联网，这是非常不错的体验。 不浪费时间在没用的事情上。评判是否有用，就看做这件事情是否有正收益。在网上和人吵架，担心某件事但是不采取任何行动，抱怨高昂的房价，抱怨社会的不公，抱怨疫情，后悔之前的某件事，埋怨上司和同事，这些都是没有任何正收益的事情。做这些事情不仅无法改善当下的生活境遇，而且会成为情绪黑洞，不停吞噬能量，习惯于吐槽抱怨，自动放弃改变的努力，所有周围的人最终将离你而去，好运也会离你而去。大家面对的是同样的环境，与其抱怨不如行动，对于无法控制的事情，就像科技爱好者周刊（第 204 期）：如何度过疫情、裁员、还有战争 - 阮一峰的网络日志中所说的，Let it go~ 做错的那些事 目光短浅。上大学时候就应该考驾照，但是觉得所资不菲，直到现在才开始学车，结果发现时间和资金成本都远比上学时高。在资源匮乏的条件下，很容易做出急功近利的决定，而丢失长远的利益，现在考虑事情可以长远些。 缺乏勇气。勇气缺失是对未来的不自信，导致自卑，应对方法就是不停尝试，认真做事，积累自信。改变周遭境遇的勇气，当下仍然有不自由的感觉，最重要的原因是我依然在劳动力市场上作为被挑选的那一个，担心下一个合同期公司不会续约。让自己的技能提升，寻找被动收入，或者换一家公司，所有这些改变都需要勇气。 成长中的新发现 读书研究需要行稳致远，构建底层框架，将知识点缀成网，相信长期主义。技能磨砺是一个长程的过程，逐渐积累前期慢达到一个临界点就会突然爆发。深挖洞，广积粮，缓称王，读书要读深，盖房地基打牢。我现在学习CSAPP，记笔记写博客就是弥补计算机知识的空缺，将其学扎实。去年通过公司级别的可信认证，不间断刷LeetCode，倒逼全面学习c++知识，虽然开始看起来知识点庞杂零碎，但是经过长达一年的练习，现在对这门语言的认识越来越清晰深刻，而且我还在坚持学习中。掌握复杂的知识从来就是艰难的事情，需要长期的耐性，大量的练习。 做事计划周密，步骤可落地，行动果决。这是在华为学到的做事风格，做事情不会漫无边际，拖拖拉拉，紧盯目标，不念其他，凡事都会有真实的可量化的输出。虽然刚开始我很排斥这种冷冰冰的风格，但是回头看确实可以做成很多mission impossible的事情。 相信自己的直觉，尤其是内心深处的担忧。很庆幸四年前我从原公司跳出来，当时的直觉就是工作内容大量重复，技能得不到提升，公司前景黯淡。有段时间我睡眠不足，非常焦虑，公司就像一架即将失速的飞机，继续做下去就是机毁人亡，现在看我的预感是对的。我急切想脱离那个公司，以致于有点饥不择食，很感谢当时的师傅，他跟我说我可以走，但是也要找个比现在更好的选项呀。这是一条非常睿智的建议，不要慌不择路，想好接下来要做什么，再做现在的决定。如果对某件事感到焦虑，那必然在将来的某个时间点成为大麻烦，现在就着手面对它，分析它，如果还无法制定详尽的计划，那至少去了解别人的经验，做一些尝试吧，最愚蠢的做法是忽视它，假装生活如常。 影响我的那些人 一路跌跌撞撞，下面的这些人对我的观念产生了很大的影响（排名不分先后），我到现在还在持续关注他们的动态，而且将他们的博客链接放在了收集有趣好玩的事情的页面上，希望对你有用。\n产品沉思录 · Product Thinking，2020年发现的比较好的产品的网站 ShareTechnote，一个韩国高级工程师搭建的专业知识共享网站 酷壳 – CoolShell.cn，左耳朵耗子的官方博客，对我影响比较大的技术大佬 阮一峰的网络日志，IT圈子中小有名气的大佬，比较喜欢他每周一推的科技爱好者周刊系列 MacTalk-池建强的随想录 | 让创作成为一种生活方式，一个持续创业者 参考资料 年薪百万的迷惘 | MacTalk-池建强的随想录，启发比较大的一篇文章 财富常识 · 构建我的被动收入，或许是未来几年努力的方向 科技爱好者周刊（第 204 期）：如何度过疫情、裁员、还有战争 - 阮一峰的网络日志，面对疫情应该有的态度 凯文·凯利70岁生日写的103条人生忠告（中文翻译） | 枫言枫语 全文完🚀\n","date":"2022-05-03T22:11:19+08:00","image":"https://pic.imgdb.cn/item/627138c109475431290724ef.png","permalink":"https://blog.bugxch.top/p/35%E5%B2%81%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/","title":"35岁的一些思考"},{"content":"这两天研究了下CSAPP中的浮点数的知识，结合这些知识，终于可以解答之前关于float的一些迷思。\nC语言中浮点数相等的比较为什么不能用==? A：浮点数的舍入方法引发的。如果要搞清楚这个问题，需要明白下面的两个知识点。\n计算机判定两个浮点数相等，基于它们的在计算上的二进制的表示的比特位是否相等。 计算机上用有限bit位表示的浮点对应到数学上的实数，表示的不是一个点而是一个区域。仔细考察这个结论，参考信息的表示和处理中关于浮点数舍入部分的描述和之前的浮点数在计算机中的表示，半精度浮点数可以表示的数中有如下的数[126.3, 126.4, 126.44, 126.5]，它们是离散分布在数轴上的，这3个数对应的二进制的表示分别是$[(1.1111100101)_2\\times 2^{6},(1.1111100110)_2\\times 2^{6},(1.1111100111)_2\\times 2^{6}]$，根据之前分析的round to even的舍入规则，所有位于$[(1.11111001011)_2\\times 2^{6},(1.11111001101)_2\\times 2^{6}]$之间的浮点数都会舍入到$(1.1111100110)_2\\times 2^{6}$，换算过来也就是所有位于$[126.34375,126.40625]$区间的实数都会映射到这个值。如果有下面的语句 1 2 3 4 5 float16 a = 126.4; float16 b; if (a == b) { // } 那么b = 126.35或者b = 126.38或者b = 126.3876都是成立的，因为它们都会在浮点数的表示体系下舍入到126.4。数学上不相等，但是在计算机里面是相等的，这就是数学意义和计算机表示意义上的背离，\n浮点数的==和数学意义上严格的相等是不等价的。\n所以为了追求相等的精确性，可以利用$|a-b|\u0026lt;\\epsilon$的方式，将$b$限定在以$a$为中心的很短的绝对值区间上，$\\epsilon$越小，二者的相等程度就越高。所以可以使用下面的代码做一个等价的处理\n1 2 3 4 5 6 #define EPSILON 1e-6 float16 a = 126.4; float16 b; if (fabs(a - b) \u0026lt; EPSILON) { // } 什么是浮点数的“大数吃小数”问题？原理是什么？ A：浮点数在计算中的舍入引发的。在深入理解计算机系统第2章浮点运算的章节，作者提到过\n使用单精度浮点，3.14 + 1e10 - 1e10 = 0.0\n这就是一个大数吃小数的问题，严格来讲，在C语言中，当一个比较大的浮点数与一个相对小很多的浮点数相加时，结果是那个比较大的浮点数，就好像小数被“吃掉”了一样。上面的例子中，3.14 + 1e10 = 1e10，也就是说从计算机的角度来看，3.14 + 1e10的二进制表示与1e10的二进制浮点表示没有区别。这是怎么回事？\n参考信息的表示和处理中的内容，模拟它们的二进制加法就能得到答案。\n按照浮点数的表示法，在计算机中$(3.14)_{10} = (1.10010001111010111000011)_2\\times 2^{1}$，而$(1e10)_{10} = (1.00101010000001011111001)_2\\times 2^{33}$。两个的二进制的小数都是23位 将两个数字的指数对齐，那么$(3.14)_{10} = (1.10010001111010111000011)_2\\times 2^{1} = (0.0000000000000000000000000000000110010001111010111000011)_2\\times 2^{33}$，但是float的小数点精度只能到23位，所以舍入到小数点后23位，结果就是浮点数的0 指数相同，小数相加，1e10的小数加的就是0，所以结果还是1e10。 从上面的分析可以看到，如果两个相加的数字由于指数悬殊，而导致在对齐指数中，较小数的浮点数用有限精度的尾数表示为0的时候，就会发生这样奇怪的事情。\n全文完🚀\n","date":"2022-04-27T16:04:05+08:00","image":"https://pic.imgdb.cn/item/6268f90d239250f7c59e8af0.jpg","permalink":"https://blog.bugxch.top/p/%E5%85%B3%E4%BA%8E%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%BF%B7%E6%80%9D/","title":"关于浮点数的迷思"},{"content":"疫情居家办公，利用时间好好系统学习下CSAPP，年龄大了，好记性不如烂笔头，写写笔记。\n计算机的字长 每一台计算机都有字长，指明指针数据的标称大小，字长决定了的最重要的系统参数是虚拟地址空间的最大大小。\n字长决定了指针的存储大小，32位的字长的指针存储空间是4字节，64位是8个字节； 字长决定了虚拟地址的最大大小，所以32位的寻址空间最大是$2^{32}$Byte = 4GB，64位的是$2^{64}$Byte = 16EB。 典型的C语言的数据类型的大小参考下表\nC声明 32bit 64bit char 1 1 short int 2 2 int 4 4 long int 4 8 long long int 8 8 char * 4 8 float 4 4 double 8 8 查看上面的表格，32bit和64bit的大部分数据类型的字节长度是一样的，仅有两个不同，long int和char *。可以使用下面的代码查看每个不同类型的字节的大小\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; int main() { printf(\u0026#34;size of char is %d\\n\u0026#34;, sizeof(char)); printf(\u0026#34;size of short is %d\\n\u0026#34;, sizeof(short)); printf(\u0026#34;size of int is %d\\n\u0026#34;, sizeof(int)); printf(\u0026#34;size of long is %d\\n\u0026#34;, sizeof(long)); printf(\u0026#34;size of long long is %d\\n\u0026#34;, sizeof(long long)); printf(\u0026#34;size of double is %d\\n\u0026#34;, sizeof(double)); printf(\u0026#34;size of float is %d\\n\u0026#34;, sizeof(float)); printf(\u0026#34;size of char* is %d\\n\u0026#34;, sizeof(char *)); return 0; } 我在自己的64位字长的win10电脑上试了下，除了char *的字节数是4，其他的与上面表格的结果一样。\n整数的表示 整数范围 整数分为无符号和有符号整数，如果表示整数$w$位比特，那么无符号表示的范围是$[0, 2^w-1]$，有符号整数表示的范围是$[-2^{w-1},2^{w-1}-1]$。下面是一些典型值，\n参考下表，可以在自己的PC上可以通过下面的代码，得到上面的值\nMacro Value Description CHAR_BIT 8 Defines the number of bits in a byte. SCHAR_MIN -128 Defines the minimum value for a signed char. SCHAR_MAX +127 Defines the maximum value for a signed char. UCHAR_MAX 255 Defines the maximum value for an unsigned char. CHAR_MIN -128 Defines the minimum value for type char and its value will be equal to SCHAR_MIN if char represents negative values, otherwise zero. CHAR_MAX +127 Defines the value for type char and its value will be equal to SCHAR_MAX if char represents negative values, otherwise UCHAR_MAX. MB_LEN_MAX 16 Defines the maximum number of bytes in a multi-byte character. SHRT_MIN -32768 Defines the minimum value for a short int. SHRT_MAX +32767 Defines the maximum value for a short int. USHRT_MAX 65535 Defines the maximum value for an unsigned short int. INT_MIN -2147483648 Defines the minimum value for an int. INT_MAX +2147483647 Defines the maximum value for an int. UINT_MAX 4294967295 Defines the maximum value for an unsigned int. LONG_MIN -9223372036854775808 Defines the minimum value for a long int. LONG_MAX +9223372036854775807 Defines the maximum value for a long int. ULONG_MAX 18446744073709551615 Defines the maximum value for an unsigned long int. 代码如下\n1 2 3 4 5 6 7 8 9 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;limits.h\u0026gt; int main() { printf(\u0026#34;int max is %d, int min is %d\\n\u0026#34;, INT_MAX, INT_MIN); printf(\u0026#34;char max is %d, char min is %d\\n\u0026#34;, CHAR_MAX, CHAR_MIN); return 0; } 补码表示 $w$bit的有符号整数数学表示如下，\n$$ B 2 T_{w}(\\vec{x}) \\doteq-x_{w-1} 2^{w-1}+\\sum_{i=0}^{w-2} x_{i} 2^{i} $$\n有一个理解的小技巧，与无符号的整数相比，对于这$w$位bit解读差异仅仅在最高位$x_{w-1}$，有符号数的权重是$-2^{w-1}$，无符号数的权重是$2^{w-1}$。这个是理解书本里面内容的技巧。典型数值的补码表示如下所示，\n从上面的表格可以看出，\n相同位宽的无符号整数最大值与有符号整数的-1的底层bit一样； $TMin_w = -TMax_w - 1$。 假如 0xFA是某个2字节数的补码表示，那么它实际表示的数字是十进制的多少？\n这个问题的解答可以通过补码的定义（参考上文）逐位计算，\n$$ B2T_{w}(\\vec{x}) \\doteq-x_{w-1} 2^{w-1}+\\sum_{i=0}^{w-2} x_{i} 2^{i} = -x_{w-1} 2^{w-1}+A $$\n但是还有更简单直观的计算方法，我们知道二进制的无符号整数的定义是\n$$ B2U_{w}(\\vec{x}) \\doteq x_{w-1} 2^{w-1}+\\sum_{i=0}^{w-2} x_{i} 2^{i} = x_{w-1} 2^{w-1}+A $$\n所以，可以得到$B2U_{w}(\\vec{x}) = B2T_{w}(\\vec{x}) + x_{w-1} 2^{w}$，因此，\n如果最高位是0，二者的结果是一样的； 如果最高位是1，那么可以进一步推导 $$ B2T_{w}(\\vec{x}) = B2U_{w}(\\vec{x}) - x_{w-1} 2^{w} = -\\left[(2^{w} - 1) -B2U_{w}(\\vec{x})\\right] - 1 $$\n而$(2^{w} - 1) -B2U_{w}(\\vec{x}) = x按位取反$，所以可以将这个补码的表示理解成unsigned的数，然后减去长度为$w$的全1的二进制比特，再减去1。\n所以，0xFA是情况2，补码表示的是 -(~0xFA) - 1 = -0x05 - 1 = -6。\nC语言中无符号和有符号的转换 位宽一样的无符号和有符号的整数之间的转换，遵循底层的bit不变的原则，互相进行转换，也就是说无论如何转换，仅仅是底层bit的解读方法不同而已。 C语言中的无符号数和有符号数的二元计算，都会将有符号数强制转换为无符号整数进行计算。 整数的扩展和截断 整数的扩展分为无符号扩展和有符号数的扩展，\n无符号数的扩展就往高位bit填充0； 有符号数的扩展方式是符号扩展，即最高位符号位填充空位。 整数截断逻辑很简单，就是底层的bit表示按照目的的位宽直接截断。这一小节有一个技巧，如果是位宽较小的有符号转换成为位宽较宽的无符号数，则是保持符号不变，先改变位宽，再进行转换，比如下面的代码\n1 2 3 short sx = -12345; unsigned uy = sx; printf(\u0026#34;uy = %u: \\t\u0026#34;, uy); 上面的代码中，第2行等价于(unsigned int)(int)sx，先应用符号扩展将short扩展到int，然后再使用等宽bit位的无符号的转换。\n编程建议 在实际的软件开发中，尤其要注意无符号整数和有符号整数的转换，比如下面的代码的第4行\n1 2 3 4 5 6 float sum_element(float a[], unsigned length) { int i; float result = 0.0f; for (i = 0; i \u0026lt; length - 1; ++i) result += a[i]; return result; } 如果length的初始值为0，那么length - 1会是一个非常大的正数，导致对于数组a的越界访问。\n整数计算 这一部分的推导看起来比较复杂，刚开始读比较吃力，但是如果看懂了推导中的原则，理解起来就比较清晰了，作者在这一段的推理非常严谨。\n整数加法 无符号加法很简单，直观来讲，就是逐位相加，超过bit表示范围的高位直接截断。有符号数的加法，推理的原则是有符号数加法补码之和与无符号之和有完全相同的位级表示。\n对于加法的比较直观的理解，无论是无符号还是有符号数，两个数的加法依然需要在特定位宽的bit位上表示出来，也就是说最终的结果肯定是要落在合理的表示区间的。\n如果$w$位宽的无符号数超过表示区间，那么就$\\mod 2^w$，也就是减去$2^w$； 如果$w$位宽的有符号数超过表示区间，同样是$\\mod 2^w$，但是分两种，如果是负溢出，就$+2^w$，如果是负溢出就$-2^w$，举例4bit位宽的（-6）+（-3）= -9，小于-8，所以是负溢出，需要再加16，结果就是7。 需要注意这里没有整数减法章节，但是介绍了逆元的概念，$x-^t_w{y} = x + (-^t_w{y})$，两个数相减相当于加上第二个数的逆元。计算的原则同上面的2，如果超过表示区间，就做模运算。\n补码的逆元，有一种比较巧妙的方法，所有比特位取反，然后最低位+1，累进相加。\n整数乘法 无符号数乘法也很简单，相乘之后取模； 有符号数的乘法，推理的原则是有符号数加法补码之积与无符号之积有完全相同的位级表示。所以可以将有符号数的乘法，先转换成为无符号数的乘法计算，之后再以有符号数的补码解读位级表示即可。 与常数的乘积可以转化成为右移位、加法和减法的组合，时钟周期比单纯的乘法更少。 整数除法 书里面没有介绍整数的通用除法，详细推理了整数除以2的幂的过程，\n无论无符号还是有符号整数，$x\\gg k = \\lfloor {x/2^k}\\rfloor$； 对于有符号整数，$(x + (1\\ll k) - 1)\\gg k = \\lceil x/2^k\\rceil$，这里实际上是一个数学的小技巧，$(m+n-1)/n = \\lceil m/n\\rceil$。 习题2.44是掌握整数运算的试金石。\n浮点数表示 IEEE 754浮点数的表示法 参考浮点数在计算机中的表示。\n舍入（Rounding） 上面的IEEE的浮点数的表示方法解决了二进制bit到浮点数的映射问题，但是如果给定一个任意精度的实数$x$，如果使用给定位宽的浮点数表示这个数呢？这里就要引入舍入的概念。舍入解决了将数学上的任意精度的实数集合到计算机表示的有限元素的浮点数集合的映射问题。从之前的浮点数的表示可以看出，计算机表示的浮点数不可能有无限的精度，将半精度浮点数在数轴上标示出来，它在数轴上的分布是离散的，任意两个离散标示值之间的实数是无穷多的，这些实数如果要用半精度表示就只能通过某种方法舍入到标示的某个值上。以下面的问题为例，\n半精度浮点数有下面的点，[0.01118, 0.011185, 0.01119]，那么0.011183该如何表示成半精度浮点数结果是什么呢？\n十进制的舍入 直觉告诉我，这个数要么就是0.01118，要么就是0.011185，因为这个数字介于二者之间，如果按照误差尽量小的原则，那么可以计算一下与两个备选数字的差的绝对值，然后舍入到绝对值最小的那个上。这个就是C语言当前使用的舍入方法，称为最接近值的舍入（round to nearest)。这里面还有一个特殊的地方，以对于十进制的数字为例，舍入到最近的整数，如果这个数是两个整数的中间的值，也就是X.5的形式，那么舍入到最近的偶数。比如0.5是0和1的中间值，它举例两个数的举例是一样的，舍入到0，3.5是3和4的中间值，舍入到4。这样做可以最小化一组数的舍入误差的均值。因此，这种舍入方法又称为round to even。除此之外，还有如下的舍入方法\n向0舍入，数轴上向着0的方向舍入； 向下舍入，也是向$-\\infty$舍入； 向上舍入，即向$+\\infty$舍入 如下图所示，表示了上面的三种情况， 二进制的舍入 那如何将十进制的舍入类推到二进制的舍入呢？这里包括两个步骤：\n确定舍入的位数，对于某个二进制数$0.001001_{2}$，如果是舍入到小数点后3位，那么这个位数就是3； 确定需要舍入的数是否位于两个数的中间位置。 如果在中间位置，那么向偶数方向舍入，对于二进制来讲，偶数就是最低有效位为0的数； 如果不在中间位置，就向最近的数字舍入。 以上面的数$0.001001_2$为例，就是确认这个数是否在$0.001_2$和$0.010_2$的中间位置，这个位置的数字是$0.0011_2$。很明显$0.001001_2$不是$0.0011_2$，而且小于该值，所以舍入到$0.001_2$。\n可以归纳一下，对于给定小数位的浮点数的舍入，对于形如$x.xxxyxxx_2$的二进制数（x和y是0或者1，而且不同位上的数字相互独立），假如舍入到小数点后4位，那么$y=0$或者$y=1$。\n如果$y=0$，那么可能舍入的两个二进制数是$x.xxx0_{2}$和$x.xxx1_{2}$，两个的中间值是$x.xxx01_2$（逐位相加，左移1个bit）； 如果$y=1$，那么可能舍入的两个二进制数是$x.xxx1_{2}$和$x.xx(x+1)0_{2}$，两个的中间值是$x.xxx11_2$。 所以，无论要舍入的小数位是0或者1，需要舍入的中间值一定是$x.xxxy1_2$形式。\n问题解答 回到最初的问题，$0.01118_{10}$的二进制表示是0010000110111001，按照浮点数的表示法，也就是$1.0110111001_2\\times 2^{-7}$，同样的$0.011185_{10}$的二进制表示是0010000110111010，也就是$1.0110111010_2\\times 2^{-7}$，如果按照精确到二进制小数点后10位（因为半精度浮点数的尾数是用10个bit来表示的），那么这两个数的中间数应该是$1.01101110011_2\\times 2^{-7}$\n$0.011183_{10}$，转换成二进制是$1.0110111001110_2 \\times 2 ^{-7}$，与中间数的二进制相比，明显大于中间数，所以舍入到比较大的$0.011185_{10}$。如果按照十进制的方式来处理也是一样的，$0.01118_{10}$和$0.011185_{10}$的中间数是$0.0111825_{10}$，明显大于这个中间数，也是舍入到较大的数。\n浮点数计算 书本里面没有做详细的计算规则的说明，参考Rounding - CS 357做一下说明。两个浮点数做加法需要完成下面的3个步骤：\n将两个浮点数调整到相同的指数； 做简单的数学的二进制加法； 对结果进行舍入。 以二进制数$a =(1.101)_2$和$b=(1.001)_2\\times 2^{-1}$为例，假设计算机系统表示尾数的只有3bit，那么计算就会是这样 $$ \\begin{aligned} a \u0026amp;=1.101 \\times 2^{1} \\ b \u0026amp;=0.01001 \\times 2^{1} \\ a+b \u0026amp;=1.111 \\times 2^{1} \\end{aligned} $$\n最后的结果以小数点后3位作为舍入精度位。可以看到无论是哪个数，有效的数字为是4位，所以没有有效数字位的丢失。\n全文完🚀\n","date":"2022-04-22T17:13:44+08:00","image":"https://pic.imgdb.cn/item/627703420947543129b87e9a.jpg","permalink":"https://blog.bugxch.top/p/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/","title":"信息的表示和处理"},{"content":"书接上文，使用贝叶斯定理解释著名的Monty Hall问题，思索清楚之后感觉挺有趣，分享下。\n问题描述 參賽者會看見三扇門，其中一扇門的裏面有一輛汽車，選中裏面是汽車的那扇門，就可以贏得該輛汽車，另外兩扇門裏面則都是一隻山羊。當參賽者選定了一扇門，主持人會開啟另一扇是山羊的門；並問：「要不要換一扇門？」\n我想大多数人的答案应该是无论换不换门，结果都是一样，赢得比赛的概率是1/2，但是实际的答案是，换一扇门赢面更大，准确得说换一扇门赢得比赛的概率是不换门的2倍。为什么会是这样呢？\n分析解答 为了对这个问题做精确的解答，我们有必要对问题的描述做更详细的澄清。当前的这个游戏满足如下的条件：\n參賽者在三扇門中挑選一扇。他並不知道內裏有甚麼。 主持人知道每扇門後面有什麼。 主持人必須開啓剩下的其中一扇門，並且必須提供換門的機會。 主持人永遠都會挑一扇有山羊的門。 如果參賽者挑了一扇有山羊的門，主持人必須挑另一扇有山羊的門。 如果參賽者挑了一扇有汽車的門，主持人隨機（概率均勻分佈）在另外兩扇門中挑一扇有山羊的門。 參賽者會被問是否保持他的原來選擇，還是轉而選擇剩下的那一道門。 朴素分析 使用穷举法分析概率，假设3扇门的编号分别是1，2，3，根据最初选择的编号，以及奖品所在门的编号，可以画出下面的表格\n初始选择门编号 奖品所在门编号 不换门结果 换门结果 1 1 赢 输 1 2 输 赢 1 3 输 赢 2 1 输 赢 2 2 赢 输 2 3 输 赢 3 1 输 赢 3 2 输 赢 3 3 赢 输 上面的表格囊括了所有的情况。第一行的结果很明显，第二行的情况是，主持人肯定会打开编号3的门（因为只有这个门的后面不是奖品），所以如果换门肯定就是换到2号门，那么就赢了，其他的情况类似。这时，可以数一数后面两列的结果，换门有6次赢，是不换门的2倍（只有3次赢）。\n贝叶斯定理 参考新冠检测后面的数学定理里面的贝叶斯定理，我们推算下这个令人吊诡的结论是如何产生的。我们假设有三扇门的编号分别是A、B和C。在没有任何其他信息的情况下，你选择了A作为答案。此时\n$$ Pr(A) = Pr(B) = Pr(C) = \\frac{1}{3} $$\n其中\nA表示奖品在A门后的概率 B表示奖品在B门后的概率 C表示奖品在C门后的概率 可以看出此时无论你选择哪一扇门赢得比赛的概率都一样。\n然后，蒙蒂打开了C门，告诉你C门后面没有奖品，所以你知道$Pr(C) = 0$，那此时你对$Pr(A)$和$Pr(B)$的估计还保持原样吗？\n我们令E表示蒙蒂选择C门作为展示门（以表明该门后面没有奖品）这个事件，那么实际上要比较的就是$Pr(A|E)$和$Pr(B|E)$的大小关系。根据贝叶斯定理\n现在已知，$Pr(A) = Pr(B) = Pr(C) = \\frac{1}{3}$，下一步就是推导\n$Pr(E|A) = 1/2$，因为如果奖品在A门后面，那么蒙蒂可能选择B门也可能选择C门作为展示门，那么选择C门作为展示门的概率是1/2； $Pr(E|B) = 1$，因为如果奖品在B门后面，那么蒙蒂只能选择C门作为展示门； $Pr(E|C) = 0$，因为如果奖品在C门后面，那么蒙蒂不可能选择C门作为展示门； 实际上，到这一步已经可以看出来了$Pr(A|E) = \\frac{Pr(B|E)} 2$的结果了。但是，可以更进一步计算\n$$ \\begin{align} Pr(E) \u0026amp;= Pr(A)Pr(E|A) + Pr(B)Pr(E|B) + Pr(C)Pr(E|C)\\ \u0026amp;=\\frac{1}{3}\\times \\frac{1}{2} + \\frac{1}{3}\\times 1 + \\frac{1}{3}\\times 0\\ \u0026amp; = \\frac{1}{2} \\end{align} $$\n带入上面的公式，可以得到$Pr(A|E) = \\frac{1}{3}$和$Pr(B|E) = \\frac{2}{3}$\n为什么会错？ 我们的大脑在分析这个问题时，做了不切实际的假设，并且对这个假设深信不疑。我们习惯于分析相互独立的随机事件，最典型的例子是抛硬币，抛掷一枚硬币正面朝上的概率是0.5，我们得到这个结论的依据是特定结果数量与结果总数的比例，正面的情况是1，总的结果是2，所以概率是1/2。这就是为什么我们认为无论更换与否，赢得的概率一样的原因。但是实际的情况并不是这样的，选择换门与否并不是相互独立随机事件，下面我们做更进一步的说明。\n第一步，随机选择一扇门，这个的确是随机的，无论选择哪一扇门，最终赢得比赛的概率是1/3。但是整个事件的随机独立性在蒙蒂选择打开哪扇门的时候发生了变化，\n他事先不知道没有被你选中的那两扇门后面奖品的情况，他随机选择任意扇门； 他事先知道另外两扇门后面奖品的情况，他故意选择了那一扇没有奖品的门 上面的两种情况的随机独立性完全不同，\n第一种情况，对于蒙蒂来说选择两扇门中的任意一个就像投掷硬币一样，两扇门对于他来讲是平等的选择，他选择任意扇门的概率是1/2。 第二种情况，他倾向于选择没有奖品的那扇门，这次的选择不是随机的，而是有意识的选择，尤其当两扇门中有一扇有奖品的时候，他必然会选择没有奖品的那扇门，此时选择那扇门的概率是1，而不是1/2。这样的选择具有倾向性，而不是随机决策的结果。实际上，他排除了不是奖品的那扇门，所以剩下来的那扇门有奖品的概率更高，而不是和他选择打开的那扇门的概率相同。 这里是另一种分析的思路，初始选择中，假设你选择了A，那么A门有奖品的概率是$\\frac{1}{3}$，B门和C门有奖品的概率是$\\frac{2}{3}$。B门和C门至少有一扇门是没有奖品的，蒙蒂知道奖品的位置，他打开那扇没有奖品的门，假设是C门。那剩下B门有奖品的概率就变成了$\\frac{2}{3}$！蒙蒂帮你排除了没有奖品的那扇门，所以你换门之后赢得的概率一定是$\\frac{2}{3}$！\n问题变种 这个问题的变种是，在你选定门之后，节目组请另一个嘉宾在你没有选定的两扇门里面随机选定一扇门，那扇门后面没有山羊，那么他打开其中任意一扇门，显示是山羊，此时更换选择的赢面是否更大？注意，这个嘉宾事先不清楚奖品在那一扇门后面。\n答案是否，无论是否更换选择，两个的概率都是1/2。参考之前的贝叶斯定理的推理，假设同前，你选了A门，那么此时嘉宾需要在B和C门直接选一个门，\n$Pr(E|A) = 1/2$，因为如果奖品在A门后面，这里的概率分两步，第一步是选择C门，嘉宾选择的概率是1/2，第二步是C门后面是羊的概率，此时是1，所以最终的概率是1/2 * 1 = 1/2； $Pr(E|B) = 1/2$，分析同上； $Pr(E|C) = 0$，第二步C门后面是羊的概率是0，所以按照上面的分析最终的概率是1/2*0 =0。 可以看出无论更换与否，中奖的概率都是一样的。\n参考资料 Monty Hall revisited，问题的数学推导 蒙提霍爾問題 - Wikiwand，维基百科描述 Monty Hall Problem: Solution Explained Simply - Statistics How To，一篇精湛的统计学分析 全文完🚀\n","date":"2022-04-21T20:36:36+08:00","image":"https://cdn.pixabay.com/photo/2018/10/01/13/53/droplet-3716288_960_720.jpg","permalink":"https://blog.bugxch.top/p/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98%E7%B2%BE%E8%A7%A3/","title":"三门问题精解"},{"content":"新冠检测的科学原理。\n混合检测的数学原理 当前居家检测的新冠是10人一组或者20人一组进行混检的，为何不是挨个检测？\n检测现状 英国城市利物浦在2020年11月20日刚结束一场大规模的新冠检测项目，这是英国第一次在一个城市做大规模检测。利物浦是英格兰新冠死亡率最高的地区，每百万人感染率是英格兰平均水平约2倍，所以被选为试点。这个试点项目被看作是全英的希望，要在2021年1月之后在英格兰全境推广。但是进度很不理想，原本的目标是在两周内对利物浦全部50万人口进行检测。但两周结束，目标才达成了一半不到，共检测了约20万人，检出来约2000名阳性，600名无症状感染者。所以检测效率是1.42万人次/天。\n上面是约翰霍普金斯大学的美国每日核酸检测的统计数据，可以看到从2020年4月份到现在，核酸检测的峰值是580万人次/天左右。参考4月4日上海全市核酸检测的速度，2500万人次/天，相差甚远！\n混检效率 如果在27个检测样本中有1个阳性样本，如何以比较少的操作将它检测出来？下面是《自然》杂志给出的新冠病毒几种不同的混检方法\n方法一 这个也是当前上海核酸检测普遍使用的方法，总计检测次数是3 + 9 = 12次。这种方法最早是由哈佛大学经济学家Robert Dorfman在20世纪40年代提出的，当时是用于检测二战士兵中有多少人携带梅毒。后来也常被用于筛查无症状人群有多少人携带比如衣原体和淋病病毒。红十字会也会用这种方法来筛查献血者中是否有人携带乙肝、艾滋病毒等。该方法的特点是操作简单，检测轮数较少。\n方法二 可以称为方法一的改进版，但是与上面相比，总计检测次数是9次，但是真正检出阳性的轮次更多，如果每轮的检测结果都需要等好久，会导致时间拖很长。而且叫人回来检测3次，也有操作上的难度。\n方法三 这个是升维的测试方法，第二轮检测按照行检测3次，再按照列检测3次，总计检测次数是3 + 6 = 9次。但是这个方法实际操作比较复杂，如果有不止一个阳性的时候，需要依靠算法来计算哪些是阳性样本。\n方法四 前几种方法都需要分好几轮，而测第2轮必须要等第1轮结果出来，测第3轮要等到第2轮结果出来。轮次越多，等越久越耽误时间。要比病毒更快，科学家于是研究是否能把轮次压缩到极限？印度理工学院的计算机科学家用数学中的柯克曼三元系（Kirkman triples）来完成“一轮搞定”。上图的例子就是如果测9个人，只需要测6次就能找到唯一阳性。\n方法一的数学最优问题 方法一个问题，如果样本中的阳性不止一个而且不在同一个分组，第一轮检测到就是3组阳性，第二组3组都要分开检测，实际上检测次数就是27+3=30次。所以，方法一有一个最佳混检的问题。\n假如现在有100个人需要检测，使用方法一进行混检，可以5人混检也可以10人混检，更极端的可以1人混检（也就是逐个检测），在给定阳性感染率$p$的前提下，检测的分组的规模多大检测的次数最少？\n这个问题的分析可以使用概率中期望的概念，举例来说，如果你花3块钱买彩票，有3种中奖的面值：第一种是10块，中奖率是1/20，第二种是100块，中奖率1/300，第三种10000块，中奖率是1/60000，那么平均来讲，三张彩票你期望得到中奖的金额是\n$$ 10* 1/20 + 100* 1/300 + 10000 * 1/60000 = 1/2+1/3+1/6 = 1 $$\n所以，用3块钱买了1块钱的期望值，另外两块交了愚人税。将期望值的概念用到这个问题的分析中。假设每次检测$k$个样本为一组，所有样本中的阳性率为$p$，那么使用混检方法一，k个检测样本\n没有阳性的概率是$(1-p)^k$，只需要第一轮检测1次即可； 有阳性的概率是$1-(1-p)^k$，那么两轮一共需要检测$k+1$次 所以，总的检测次数的期望是\n$$ (1-p)^k + (1-(1-p)^k)(k+1) $$\n将这个次数与$k$次相比，如果值小于1，那么说明分组检测有收益，那么问题转化成求\n$$ \\begin{align} f(k) \u0026amp; = \\frac{(1-p)^k + (1-(1-p)^k)(k+1)}{k} \\ \u0026amp; = 1/k+1-(1-p)^k\\ \\end{align} $$\n的最小值的问题。依照微积分的知识，函数的极值一般出现在导数为0的地方，求导数为\n的解就可以求出$k$的数值。另一种近似解的估值可以通过二项式展开的简化得到\n求导得出$k = \\frac{1}{\\sqrt{p}}$。使用软件绘制函数的图像如下 从上面的结果可以看出，在阳性率低于4%时，使用每组5个混检比较合适，但是当阳性率高于20%时，混检已经降低到3个一组，当阳性率为40%时，混检的效率已经不如逐个检测了。\n检测结果为阳性的感染概率 引题 参考蒙提霍尔问题 - Wikiwand， 参赛者会看见三扇门，其中一扇门的里面有一辆汽车，选中里面是汽车的那扇门，就可以赢得该辆汽车，另外两扇门里面则都是一只山羊。当参赛者选定了一扇门，主持人会开启另一扇是山羊的门；并问：“要不要换一扇门？\n感染概率 居住在金桥居家隔离小区全体人员做核酸检测，很不幸小明第一次核酸检测结果就为阳性，那么小明是否一定感染新冠病毒，感染概率有多大？\n这个概率与哪些因素相关？\n活动轨迹经过地或者周围环境的新冠病毒浓度水平，他们去过哪些地方？是否是新冠密接？ 他们是否打过疫苗？自身的免疫力如何？ 检测试剂的质量水平如何？受检测人员的感染时间如何？标本取样时受检测者的配合情况如何？检测人员的流程操作熟练度如何？ 假如有人如下的数据，是否可以得到定量的计算\n每个人在金桥区域在居家隔离期间的感染新冠的概率是1/10000; 没有感染新冠前提下，新冠试剂检测的**灵敏度(sensitivity)和特异度(specificity)**均为99%（具体的定义参考下图，真的感染之后被判定为阳性的概率，和没有感染被判定为阴性的概率，具体的定义可以参考后面的示意图） 推导贝叶斯定理 对于这个问题的计算可以从如下朴素的定义开始，\n受测者检测为阳性后感染新冠的概率，等于检测结果为阳性的感染新冠病毒的人数与所有检测为阳性人数之比\n朴素推导 假如金桥地区有10000个居民，根据感染概率，其中真实感染新冠的有10个，剩下的9990个居民实际是没有感染新冠的，也就是在没有其他信息前提下已知该地区的居民的感染率是1/1000； 在较为理想的情况下，排除其他检测操作不规范的等因素，我们假设试剂检测性能，在100个真实感染病例中可以检测出99个为阴性，1个为阳性（灵敏度是99%），同样的，100个没有真实没有感染的居民中检测出来1个阳性，其他的99个为阴性（特异度是99%) 根据上面的假设，计算\n从上面的公式可以看出假阳性人数占比较高，就会造成检测结果的不准确性，所以要提高阳性检测的准确率就需要尽量降低假阳性的病例，\n提高试剂检测的特异度，如果将特异度提高到100%，那么就不会有没有感染的人被判定为假阳性，准确率是100%； 如果真正感染的人数比例较高，那么真阳性就可以占有比较大的份额，检测结果更可信。 还有一个方法就是重复测试，如果上述条件不变，根据贝叶斯公式推导可以得到，两次复检均为阳性患病的的概率可以提高到90%。\n理论推导 用数学的语言描述就是，如果用事件$D$表示感染新冠，事件$+$表示检测为阳性，那么\n$$ Pr(D|+) = \\frac{Pr(+D)}{Pr(+)} $$\n其中\n$P(D) = \\frac{真正感染的人数}{检测为阳性的人数}$ 表示感染新冠病毒的概率，这里是先验概率，表示在看到化验结果之前的感染的概率，称为先验概率，这个值的大小与金桥地区的感染人数，受测者在金桥地区的活动轨迹，受测者自身是否佩戴口罩等环境与受测者自身的因素相关，测算一般比较复杂，可以通过历史统计或者理论推理得到，这里的值就是前面的1/10000 $P(D|+)$表示检测阳性的情况下，感染新冠的概率，也是需要估算的目标值 $Pr(+D) = \\frac{真正感染并且检测为阳性的人数}{总人数}$ 表示感染新冠，并且检测是阳性的概率 $Pr(+) = \\frac {真正感染并且检测为阳性的人数 + 没有感染并且检测为阳性的人数}{总人数}$表示所有受测者检测为阳性的概率 根据全概率公式\n$$ Pr(AB) = Pr(A|B)Pr(B) $$\n可以得到$Pr(+D) = Pr(+|D)Pr(D)$，带入到上面的式子可以得到\n$$ \\begin{align} Pr(D|+) \u0026amp; = \\frac{Pr(+D)}{Pr(+)} \\ \u0026amp; = \\frac{Pr(+|D)Pr(D)}{Pr(+)} \\ \\end{align} $$\n这个就是贝叶斯定理。\n继续上面公式的推算过程，\n$$ \\begin{align} Pr(D|+) \u0026amp; = \\frac{Pr(+D)}{Pr(+)} \\ \u0026amp; = \\frac{Pr(+|D)Pr(D)}{Pr(+)} \\end{align} $$\n其中，$Pr(+|D)$表示感染新冠的情况下被检测出为阳性的概率，也就是检测试剂的灵敏度，这个值是0.99，一般这一项称为$+$的后验概率。\n对于$Pr(+)$可以继续使用全概率公式$Pr(+) = Pr(+|D)Pr(D) + Pr(+|\\bar D)P(\\bar D)$，检测阳性的人数比例，等于感染新冠的人数的检测阳性的概率与没有感染新冠的检测阳性的概率，所以最终的结果是\n其中，\n$Pr(+|\\bar D)$ 表示未感染新冠的情况下被检测出为阳性的概率，这个值是0.01，是1 - 灵敏度的概率。 $Pr(\\bar D)$就是在金桥地区不会感染的概率，为1 - 1/10000 = 9999 / 10000 理解贝叶斯定理 可以参考理解贝叶斯定理的文章。\n参考资料 蒙提霍尔问题 - Wikiwand 核酸检测准确率有多高？为什么阴性结果有效期定在7天之内？ [法] 黄黎原著,方弦译.贝叶斯的博弈：数学、思维与人工智能.人民邮电出版社.2010:32. 得到电子书：https://d.dedao.cn/Dx3bkkZw5l51Et9R 七种国产新型冠状病毒核酸检测试剂盒的一致性和检出能力评价研究 - 中华检验医学杂志 灵敏度和特异度 - Wikiwand 这些因素或导致“假阳、假阴”，新冠防控利器如何更精准|RNA_新浪财经_新浪网 2019新型冠状病毒特异抗体检测 \u0026quot;假阳性 \u0026quot;原因分析及对策 - 中华检验医学杂志 搜索天蝎号核潜艇 Bayesian search theory - Wikiwand David L. Wallace, statistician who helped identify Federalist Papers authors, 1928-2017 【科普】核酸检测的原理到底是什么？为什么会出现假阴性？_图片新闻_汕头市卫生健康局（中医药局） 全文完🚀\n","date":"2022-03-23T20:13:15+08:00","permalink":"https://blog.bugxch.top/p/%E6%96%B0%E5%86%A0%E6%A3%80%E6%B5%8B%E5%90%8E%E9%9D%A2%E7%9A%84%E6%95%B0%E5%AD%A6%E5%AE%9A%E7%90%86/","title":"新冠检测后面的数学定理"},{"content":"git的一些技术的分支操作笔记。\n分支操作总览 下面的表格是git分支操作的总结表格\n命令 说明 git branch X/git checkout -b X 第1个命令仅仅创建分支但不切换，第2个命令创建并切换到新分支 git branch 查看当前所有分支列表 git log --oneline --decorate --graph --all 列出当前所有分支及其提交的分支图 git branch -v 查看所有的分支及其最后一次提交 git branch --merged/git branch --no-merged 查看已经合并或者没有合并的分支 git checkout X 切换到分支X git branch -d X/git branch -D X 删除分支X，强行删除分支X（即使暂存区有代码） 分支工作流 参考Git分支简介中的介绍，想象一种典型的工作流，看看如何使用git的分支管理进行操作。想象如下的一个典型开发场景：小王所在的团队基于master管理代码，小王参与了一个新特性的开发，需要基于master分支开发新的任务，与此同时他有时需要修复master分支上的一些小bug。现在小王需要完成如下的操作\n创建开发分支iss53，并在该分支上开发代码； 紧急修复主线上的问题，创建hotfix分支，并在上面修复代码； 将hotfix的修复代码合并到主线上，并上传到主线； 切换回iss53分支，继续完成新功能开发，开发完成后将该分支的所有修改提交到master分支 新建分支 创建分支iss53，并在该分支上工作，你在该分支上做了部分提交和修改\n1 2 git branch -b iss53 #创建并切换到iss53分支 vim test3.txt #修改文件 切换分支 此时发现主干需要修改紧急bug，于是将iss53分支的修改提交之后切换到master\n1 2 3 4 git commit -a -m \u0026#34;iss53 push\u0026#34; #在iss53上做提交 git checkout master #切换到master分支 git branch hotfix #基于master分支新建hotfix的分支 git checkout hotfix #切换到hotfix分支 需要注意，在切换到master分支之前需要将iss53分支上的修改提交，或者使用git stash命令将这些没有提交的还存在在暂存区的修改处理干净。继续在hotfix分支操作，基于这个分支修改代码，\n1 2 vim test3.txt #修改代码 git commit -a -m \u0026#34;add a new modification on iss53 branch\u0026#34; #提交 合并分支1 在hotfix上修复代码之后，需要将修复之后的代码合入到master分支，\n1 2 git checkout master #在合并修复之前，需要切换到master分支 git merge hotfix #将hotfix的修复合入到master分支 删除分支 如上图所示，此时hotfix分支和master分支的代码合并，hotfix的问题已经修复，所以需要删除hotfix的分支\n1 git branch -d hotfix #删除hotfix分支 注意，如果hotfix的暂存区仍然有代码，可能使用上面的命令无法删除，需要使用下面的代码删除分支\n1 git branch -D hotfix 继续开发 删除hotfix分支之后，继续返回iss53分支开发，\n1 2 3 git checkout iss53 vim test3.txt git commit -a -m \u0026#34;develop push\u0026#34; 合并分支2 假设在C5这个快照的节点，iss53的开发任务完成，需要将开发分支的代码回合到master分支，操作与之前切换到master，然后合并，与之前的合并分支1的操作一样\n1 2 git checkout master git merge iss53 合并分支之前的图如下所示\n此次合并与之前的合并分支1不同，iss53当前节点的父节点向上追溯无法追溯到C4这个节点，所以git在此处做了一个合并提交，它新建了一个commit的节点C6，将C4和C5的快照进行比较之后合并到C6，合并后的节点如下图所示\n如果没有发生冲突，那么一切ok，删除iss53即可，任务完成。\n合并分支之冲突解决 对于上面的合并分支2的情况，如果C4和后面的C5修改了同一个文件的同一行，那么会有冲突发生。以下为例，可以git接冲突的方法解决后合并。\n冲突如下\n其中上半部分是当前的master分支的情况，下面的iss53的情况的，可以手动解决冲突后继续合并\n可以看到新建了校验和为b700510的节点，master和iss53分支均合入到该节点。\n全文完🚀\n","date":"2022-03-15T09:20:00+08:00","permalink":"https://blog.bugxch.top/p/git%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C/","title":"Git分支操作"},{"content":"卡片笔记写作法的学习总结，部署实践。\n基本思想及原理 最近在阅读卡片笔记写作法，在正式出版差不多一周的时间，这本书登上了豆瓣的非虚构图书排行榜的No.2，评分高达8.0，\n顺藤摸瓜，我花了几天时间仔细搜罗了相关的资料文档，发现这是非常好的达到长期主义知识复利的工具，总结下资料，写个博客记录下。卢曼卡片盒笔记法介绍 (Introduction to the Zettelkasten Method) • Zettelkasten Method是翻译的比较权威的阐述卡片笔记写作法精髓的文章。\n笔记软件及部署 我选择使用Obsidian +坚果云 +FolderSync作为PC与安卓手机的笔记系统。\n全平台笔记软件 Obsidian当前的版本是v0.12.12，我上周发现的宝藏笔记软件，最大的特点\n非常私密和安全。所有的资料和文档都保存在本地PC和手机，如果需要同步文档可以付费或者通过其他的同步软件实现； 个人免费。 支持md文档，支持笔记双向链接，支持Windows/Linux/Mac/Android/ios客户端。 这个软件的介绍文档和资料已经很多了，可以参考下面的链接进行学习\n持续更新44集全网最全obsidian教程|搬运分享非原创_哔哩哔哩_bilibili，B站上推荐非常多视频教程； Obsidian：目前我们眼中最美最好用的免费笔记/知识管理软件_哔哩哔哩_bilibili，B站上的另一个比较简单的介绍视频，时长比较短； 玩转 Obsidian | 基础设置篇 - 少数派，比较早介绍该款软件的文章 2021年新教程 - Obsidian中文教程 - Obsidian Publish，官方中文教程，也是使用obsidian发布的，可以从中看到笔记的链接图。 安卓手机与PC同步 具体参考如何使用FolderSync在安卓手机上同步文件夹到坚果云？，按照文章的步骤设置使用即可。\n辅助技能 Obsidian 使用篇一：使用 markdown-clipper 全文保存网页 | Verne in GitHub，这篇文章介绍了两个非常好用插件，可以通过chrome或者edge将网页的信息摘录到本地的闪念笔记里面，也可以通过插件将网页的内容转换成为md保存在本地。\n全文完🚀\n","date":"2021-08-11T22:31:58+08:00","image":"https://pic.imgdb.cn/item/6113da595132923bf8329013.png","permalink":"https://blog.bugxch.top/p/%E5%88%9D%E8%AF%86%E5%8D%A1%E7%89%87%E7%AC%94%E8%AE%B0%E5%86%99%E4%BD%9C%E6%B3%95/","title":"初识卡片笔记写作法"},{"content":"最近在准备考试，做了一些二分搜索的题目，感觉有点意思，记录下做题的心得😁。\n文章目标 通过阅读本文，可以彻底搞懂二分查找的基本原理及各种变体，可以独立完成下面的力扣题目\n力扣题目 考查点 374. 猜数字大小 基本模板 69. x 的平方根 基本模板 278. 第一个错误的版本 查找左边界 153. 寻找旋转排序数组中的最小值 寻找旋转数组中的目标值（无重复元素） 154. 寻找旋转排序数组中的最小值 II 寻找旋转数组中的目标值（包含重复元素） 34. 在排序数组中查找元素的第一个和最后一个位置 查找左右边界 基本原理 在计算机科学中，二分搜索又被成为半区间搜索，对数搜索或者二分chop，它用于在排序数列中找到目标值的位置。算法不断比较数列中间元素与目标值，\n如果目标值与中间元素匹配，那直接返回中间的位置； 如果目标值比中间元素小，继续搜索低半边的数列； 如果目标值比中间元素大，那么继续搜索高半边 注意到每次在比较元素之后搜索的区间会减少一半（去掉目标值不可能在的那一半区间），所以在最坏的情况下，算法的复杂度是$O(logn)$。下面是二分搜索与线性搜索的比较示意图，以严格单调增且无重复元素的序列为例，查找目标值为37的序列值。\n序列长度是17，\n二分查找第一次寻找整个搜索区间的中间的index（从0开始计数）为(0 + 16) / 2 = 8的数字23，23比37小，所以更新查找区间为[9,16]； 查找新区间的中间index = (9 + 16) /2 = 12，结果是数字41，比37大，更新查找区间为[9, 11]; 查找新区间的中间index = (9 + 11) / 2 = 10，结果是数字31，比37大，继续更新查找区间为[11, 11]，此时中间元素就是第11号元素，即37，找到目标值，查找结束。 根据以上算法步骤，很顺利就可以写出下面的伪代码，\n1 2 3 4 5 6 7 8 9 10 11 12 13 // basic template function binary_search(A, n, T) is L := 0 R := n − 1 while L ≤ R do m := floor((L + R) / 2) if A[m] \u0026lt; T then L := m + 1 else if A[m] \u0026gt; T then R := m − 1 else: return m return unsuccessful 使用上面的基本模板我们就可以解答文章开始列出的第一道题目了，374. 猜数字大小题目，给出二分查找的基本模板。这道题目就是最传统的猜大小的谜题，标准的解答模板的代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Forward declaration of guess API. * @param num your guess * @return -1 if num is lower than the guess number *\t1 if num is higher than the guess number * otherwise return 0 * int guess(int num); */ class Solution { public: int guessNumber(int n) { int left = 1; int right = n; while (left \u0026lt;= right) { // detail 1 int mid = left + ((right - left) \u0026gt;\u0026gt; 1); // detail 2 int rlt = guess(mid); if (rlt == 0) { return mid; } // detail 3 if (rlt == -1) { right = mid - 1; } else { left = mid + 1; } } return -1; } }; 关键技术细节 Although the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky \u0026ndash; Donald Knuth\n就像高德纳所说，二分法的思想简单且易于理解，但是二分法的细节却藏了很多坑，魔鬼就在细节中。为了透彻理解二分法的实现，有必要对上面的代码的下面3个技术细节（标记为detail注释的地方）进行深究。\n循环的入口条件 代码16行，为什么循环的入口条件是left \u0026lt;= right？\n无论何时$[left, right]$表示可能包含目标值的搜索区间\n注意这是个左闭右闭的闭区间，单纯从数学角度出发，这个区间最短的长度就是1，也就是$left = right$的时候。如果$left \u0026gt; right$了，那$[left, right]$就是空集，这个集合肯定不包含目标值，也就没有继续搜索的必要了，所以循环退出。\n中点计算 为什么是mid = left + ((right - left) \u0026gt;\u0026gt; 1)，也就是数学的$floor((left + right) / 2)$? 这里的中点转换成数学表示就是 $$ \\begin{align} mid = \\left \\lfloor\\frac{left + right}{2} \\right \\rfloor \\end{align} $$ 其实，我们还有另外一种选择，将中间值定为 $$ \\begin{align} mid = \\left \\lceil\\frac{left + right}{2} \\right \\rceil \\end{align} $$ 第2种方式的中点值的选择是否可行？从后面的分析，**其实是可行的。**那这两个计算公式有什么区别？最大的区别在于$right = left + 1$的时候，也就是搜索区间长度为2左右端点挨着的时候，如下图所示，下一次循环计算mid，第1个公式结果是$mid = 4$，而第2个公式的结果是$mid = 5$，\n，第1个公式$mid = \\left \\lfloor\\frac{left + right}{2} \\right \\rfloor = \\left \\lfloor\\frac{left + left + 1}{2} \\right \\rfloor = left$，而第2个公式$mid = \\left \\lceil\\frac{left + right}{2} \\right \\rceil = \\left \\lceil\\frac{left + left + 1}{2} \\right \\rceil = left + \\lceil 0.5\\rceil = left + 1 = right$，请记住这个重要的结论。\n当搜索区间的左右两端点挨着的时候（即$right = left + 1)$，floor函数计算的中点mid是left，ceil函数计算的中点mid是right\n请记住这个特殊的区间情况，至于为何基础模板选择floor而没有选择ceil，在后面的变化类型一节很关键。\n搜索区间调整 在每次判断与target的差距之后，搜索区间为什么是这么调整的？ 二分法另一个容易搞错的问题是区间调整，$left$和$right$好像可以选择$mid$的3个边界值$mid, mid - 1, mid + 1$中的任意一个，其实调整的原则很简单，\n排除target不可能存在的区间，保留可能存在的区间 保证任意判断分支为true时最后都可以跳出循环，尤其当$right = left + 1$时 先看第1条原则，基础模板中，根据mid的值与目标值的差距，搜索区间$[left, right]$的调整有3个判断分支：\n如果和目标值相同$A[mid] = A[target]$，直接跳出循环，返回mid(代码第21行)； 如果比目标值大$A[mid] \u0026gt; A[target]$，那么肯定$target \u0026lt; mid$，所以$target \\le mid - 1$，因此$target$位于区间$[left, mid - 1]$上，更新$right = mid - 1$； 如果比目标值小$A[mid] \u0026lt; A[target]$，那么肯定$target \u0026gt; mid$，所以$target \\ge mid + 1$，因此$target$位于区间$[mid + 1， right]$上更新$left = mid + 1$。 区间的调整仅仅保留了$target$可能存在的部分。\n分支3的调整情况，看如下图示\n考察第2条原则，是否可以退出循环？这个循环的退出条件是$left \u0026gt; right$。对照上面的3个判断分支分别为true的情况：\n第1个判断分支直接退出循环，符合条件； 同理，第2个判断分支每次判断之后$right$在变小，所以必然在若干次之后比$left$小，直至退出循环 第3个判断分支每次调整之后$left$在变大，所以所以必然在若干次之后比$right$大，直至退出循环 所以随着区间的调整，必然会在某一步满足退出的条件。特别的，当$right = left + 1$时，$mid = left$；\n第2个判断分支，$right = mid - 1 = left - 1 = right - 2 \u0026lt; left = right - 1$，跳出循环 第3个判断分支，$left = mid + 1 = left + 1 = right$，再次进入循环，此时$mid = left = right$，$left = mid + 1 = right + 1 \u0026gt; right$，可以看到在迭代2次之后也退出循环 第2条原则满足。\n结合上面的分析，二分法的步骤包括：\n从$A[mid]$与$target$的大小判断入手，判断它们的各种大小关系分支，确定每个判断分支的区间调整策略，需要满足下面的两条原则\n排除target不可能存在的区间，保留可能存在的区间 保证任意判断分支为true时最后都可以跳出循环，尤其当$right = left + 1$时 深入探究 上一小节讨论了3个关键技术细节，循环入口条件、中点计算和搜索区间调整，下面可以看到在满足上面的原则基础上，它们都可以变化。\n分支合并 当前的基础代码有3个判断分支，是否可以将3个分支合并成2个呢？下面的基础模板就可以。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int guessNumber(int n) { int left = 1; int right = n; while (left \u0026lt; right) { // 退出条件变了 int mid = left + ((right - left) \u0026gt;\u0026gt; 1); // 调整策略的分支从3个变成了2个 if (guess(mid) \u0026lt;= 0) { right = mid; } else { left = mid + 1; } } // 返回的条件也变了 if (guess(left) == 0) { return left; } return -1; } }; 再仔细考察一下，上面的代码，3个地方发生变化（已经在注释种标出）依然可以通过测试，其实还是按照上面的2个原则来看。\n每次调整区间，排除target不可能存在的区间，保留可能存在的区间\n重新分析之前的3个判断分支，比较特殊是第1点，如果$A[mid] = A[target]$，那么$mid = target$，很明显\n判断分支1与判断分支2合并，当$A[mid] \\ge A[target]$，$target \\le mid$，所以$target$可能位于$[left, mid]$区间，调整$right = mid$，注意此处$right \\ne mid -1$ 判断分支1与判断分支3合并，当$A[mid] \\le A[target]$，$target \\ge mid$，所以$target$可能位于$[mid, right]$区间，调整$left = mid$，注意此处$left \\ne mid +1$ 这两个策略看起来似乎都可以，结合其他两种情况，如果将3个分支合并为2个，应该有2种调整策略\n1 2 3 4 5 6 7 8 9 10 11 12 13 # solution 1，另一种正确的方案 function binary_search_alternative(A, n, T) is L := 0 R := n − 1 while L \u0026lt; R do m := floor((L + R) / 2) if A[m] \u0026gt;= T then R := m else: L := m + 1 if A[L] = T then return L return unsuccessful 或者\n1 2 3 4 5 6 7 8 9 10 11 12 13 # solution 2，错误示范 function binary_search_alternative(A, n, T) is L := 0 R := n − 1 while L \u0026lt; R do m := floor((L + R) / 2) if A[m] \u0026lt;= T then L := m else: R := m - 1 if A[L] = T then return L return unsuccessful 保证任意判断分支为true时最后都可以跳出循环，尤其当$right = left + 1$时\n我们再看上面的两种伪代码，退出的条件是$left \u0026gt;= right$，直接考察$left = right -1$的情况，如果在搜索的若干步之后搜索的区间变成下面的情况\n下一步搜索的$mid = 4$，按照方案2，如果此时\n第2个判断分支为true，$right = mid - 1 = 3 \u0026lt; left$，退出循环； 第1个判断分支为true（代码第7~8行），那么调整$left = mid = 4$，再次进入之后会发现陷入死循环，核心原因在于中点的选择上，因为使用的是floor函数，导致left永远恒等于mid，换句或说，$left$永远不再增加，而且也进不到更新$right$的分支，陷入死循环，考察方案1就没有这种情况。 所以方案2的结果是错的。\n中点计算变更 上面的方案2，因为不满足第2条原则而失败，那有没有办法通过改变其他部分而满足原则呢？第1个判断分支如果为true，当$right = left + 1$时，根据代码第6行，$mid = left$，所以进入分支之后$left = mid = left$，那可以将第6行的代码改成下面这样，\n1 2 3 4 5 6 7 8 9 10 11 12 13 # solution 3，solution 2的改造 function binary_search_alternative(A, n, T) is L := 0 R := n − 1 while L \u0026lt; R do m := ceil((L + R) / 2) # ceil取代floor函数 if A[m] \u0026lt;= T then L := m else: R := m - 1 if A[L] = T then return L return unsuccessful 再考察一下上面的搜索区间左右端点相邻的情况，下一次搜索的$mid = 5$，无论走哪一个判断分支，最终$left = right$，跳出循环，所以对于第2条原则需要补充\n可以通过调整中点的计算方式，满足原则2，从而避免死循环\n判断条件变更 需要注意，其他2个的模板的循环条件为$left \u0026lt; right$，当$left \\ge right$时退出，如果$left = right$，那么搜索的区间只剩下一个元素，跳出循环之后别忘了要检查这个元素是否满足条件。如果最后的这个元素依然不是target，那么所有的元素也不是了，所以在最后我们加了一个判断，\n1 2 3 if A[L] = T then return L return unsuccessful 变种题目 理解上面的分析过程之后，进入进阶版的二分法题目。\n重复元素左边界 参考278. 第一个错误的版本，从某个版本开始，版本就已经不可用了，但是在这个版本之前，所有的版本均可用，需要找出第一个不可用的版本。假如说，我们有100个版本，从第70个版本开始不用，那么怎么快速找到70呢？如下所示\n题目要找到最左边第一个true对应的下标70，也是找到重复的true区间的左边界。初始化$left = 0, right = 100$，我们还是从判断分支入手，\n如果$A[mid] = true$，那么$target$可能位于$[mid + 1, right]$区间，调整$left = mid + 1$； 如果$A[mid] = false$，$mid$可能是$target$，但是$mid + 1$不会是$target$（因为我们要找的是最左边的那个FALSE），那么$target$可能位于$[left, mid]$区间，调整$right = mid$ 结合中点的计算原则$mid = floor((left + right)/ 2)$，判断$right = left + 1$时候，2个判断分支最终都可以跳出循环。最终代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // The API isBadVersion is defined for you. // bool isBadVersion(int version); class Solution { public: int firstBadVersion(int n) { int left = 1; int right = n; while (left \u0026lt; right) { mid = left + ((right - left) \u0026gt;\u0026gt; 1); if (isBadVersion(mid) == false) { left = mid + 1; } else { right = mid; } } return left; } }; 更一般的，假如我们要查找序列$[1,2,3,4,4,5,6,6,7,7,9,10,10,10]$中的最左边的10的index，该如何处理？从分支判断入手，\n如果$A[mid] \\lt 10$，那么10可能位于区间$[mid + 1, right]$区间，调整$left = mid + 1$； 如果$A[mid] = 10$，那么10可能位于区间$[left, mid]$区间，调整$right = mid$； 如果$A[mid] \\gt 10$，那么10可能位于区间$[left, mid - 1]$区间，调整$right = mid - 1$ 合并分支2和分支3，变成\n如果$A[mid] \\lt 10$，那么10可能位于区间$[mid + 1, right]$区间，调整$left = mid + 1$； 如果$A[mid] \\ge 10$，那么10可能位于区间$[left, mid]$区间，调整$right = mid$ 判断当$left = right - 1$时，两个分支都可以顺利退出。代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int CheckVal(int n) { int left = 1; int right = n; while (left \u0026lt; right) { mid = left + ((right - left) \u0026gt;\u0026gt; 1); if (A[mid] \u0026lt; 10) { left = mid + 1; } else { right = mid; } } if (A[left] == 10) { return left; } return -1; } }; 重复元素右边界 假如我们要查找序列$[1,2,3,4,4,5,6,6,7,7,9,10,10,10]$中的最右边的10的index，该如何处理？从分支判断入手，\n如果$A[mid] \\lt 10$，那么最右边的10可能位于区间$[mid + 1, right]$区间，调整$left = mid + 1$； 如果$A[mid] = 10$，这个$A[mid]$可能是最右边的10，也可能不是，但是$A[mid - 1]$肯定不是最右边的10了，所以目标值可能位于区间$[mid, right]$区间，调整$left = mid$； 如果$A[mid] \\gt 10$，那么最右边的10可能位于区间$[left, mid - 1]$区间，调整$right = mid - 1$ 合并分支1和分支2，变成\n如果$A[mid] \\le 10$，那么10可能位于区间$[mid, right]$区间，调整$left = mid$； 如果$A[mid] \\gt 10$，那么10可能位于区间$[left, mid - 1]$区间，调整$right = mid - 1$ 判断当$left = right - 1$时，按照floor函数计算，第1个分支会陷入死循环，所以需要调整中点的计算方式为ceil，判断两个分支都可以顺利退出，所以代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int CheckVal(int n) { int left = 1; int right = n; while (left \u0026lt; right) { mid = left + ((right - left) \u0026gt;\u0026gt; 1) + 1; if (A[mid] \u0026lt;= 10) { left = mid; } else { right = mid - 1; } } if (A[left] == 10) { return left; } return -1; } }; 旋转数组（无重复元素） 来做文章目标中的153. 寻找旋转排序数组中的最小值这道题，具体看看示例2中的题目怎么做\n具体的值和index的分布如下所示\n初始化搜索范围，$left = 0, right = n - 1 = 6$；\n$mid = 3$，从判断$A[3] = 7$与$target$的值入手，但是比较棘手的是$target$是多少呢（我们不知道最小值是0，仅仅知道这是一个旋转序列）？那我们根据什么判断$target$存在的可能区间呢？注意下面这幅图 这个旋转数组分为前后两个区间，前面区间每一个数字都比后面区间的数字大（因为没有重复数字），分别称为高半区间和低半区间。很明显，\n最小值一定在低半区间，且位于低半区间的起始点上； 我们不知道低半区间的起始点在哪里，也不知道高半区间的终点在哪里； 我们可以根据当前元素与数组最后一个元素（想想为什么不是第一个元素）的大小确认出具体位于哪个半区间，如果$A[id] \u0026gt; A[n - 1]$，那么在高半区间，否则在低半区间。 那这个和判断$target$所在区间有什么关系呢？如果$mid$位于高半区间，那么可以肯定最小值肯定不在$[left, mid]$中，更新$left = mid + 1$，如果位于低半区间，可以肯定$[mid+ 1, right]$不可能是最小值，更新$right = mid$。于是有下面的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int findMin(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (nums.size() == 1) return nums[0]; int left = 0; int right = nums.size() - 1; while (left \u0026lt; right) { int mid = left + ((right - left) \u0026gt;\u0026gt; 1); if (nums[mid] \u0026gt; nums[nums.size() - 1]) { left = mid + 1; } else { right = mid; } } return nums[left]; } }; 判断是否在$right = left +1$时，每个分支可以跳出循环，可以👍，完毕。 旋转数组（ 包含重复元素）左边界 再来看154. 寻找旋转排序数组中的最小值 II - 力扣（LeetCode），这个题目与上面有点区别，就是它有重复元素，如下图\n看起来可以按照上面的题目如法炮制，判断$A[mid]$与$A[n -1]$的大小，\n如果$A[mid] \u0026gt; A[n -1]$，$mid$位于高半区间，则最小值肯定不在$[left, mid]$里面，更新$left = mid + 1$；\n如果$A[mid] \u0026lt; A[n -1]$，$mid$位于低半区间，则最小值肯定不在$[mid +1, right]$里面，更新$right = mid$；\n如果$A[mid] = A[n-1]$，这个时候就说不清楚$mid$是在高区间还是低区间了。因为可能有下面的情况\n再仔细想想，其实在这一步，我们不需要知道我们位于哪个区间，我们要清楚$mid$跟最小值的index的关系，参考下面的图\n考虑数组中的最后一个元素$A[right]$，在最小值右侧的元素，它们的值一定都小于等于$A[right]$；而在最小值左侧的元素，它们的值一定都大于等于 $A[right]$。假定中点为$pilot$，比较$A[pilot]$与$A[right]$的大小，可以间接判断出$pilot$和$target$的位置关系。\n第一种情况，$A[pilot]\u0026lt;A[high]$，说明此时最小的点位于$pilot$的左边，所以更新$right = pilot$；\n第二种情况，$A[pilot]\u0026gt;A[high]$，说明此时最小的点位于$pilot$的右边，所以更新$left = pilot + 1$；\n第三种情况，$A[pilot]=A[high]$，此时唯一可以确定的是最小值在$high$的左边，所以更新$right = right - 1$\n则有如下的答案\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int findMin(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int low = 0; int high = nums.size() - 1; while (low \u0026lt; high) { int pivot = low + (high - low) / 2; if (nums[pivot] \u0026lt; nums[high]) { high = pivot; } else if (nums[pivot] \u0026gt; nums[high]) { low = pivot + 1; } else { high -= 1; } } return nums[low]; } }; 考察$right = left + 1$时候，三个分支都可以顺利跳出循环，搞定👍\n参考资料 二分查找、二分边界查找算法的模板代码总结 - SegmentFault 思否，给我很多启发的一篇文章 Binary search algorithm，维基百科页面，英文版里面的内容很详尽 ","date":"2021-05-06T22:33:59+08:00","image":"https://pic.imgdb.cn/item/60940147d1a9ae528fdc3a1d.png","permalink":"https://blog.bugxch.top/p/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/","title":"二分查找——从入门到精通"},{"content":"继续之前的设计模式第四弹，这次是大名鼎鼎的工厂方法模式。\n使用情景 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method是创建型模式，使一个类的实例化延迟到其子类。\nFactory有工厂的意思，简单来看，这个模式利用到了上一篇的Template Method模式用来生成具体的实例，说得更清楚一点，工厂方法模式将创建对象的过程延迟到子类实现，其他的父类的步骤保持完整。\n问题引入 想象一个养殖业的农民，他刚开始仅仅在养马场养马，每个马都需要养殖长大之后在市面出售，后来他获得足够的利润之后，扩展业务也养牛，但是在牛场养牛，每头牛也是需要养殖长大之后在市面出售的。在刚开始的时候，我们需要记录每只马的养殖过程，后面还要记录它的售价。如果你前面只有养马的程序（包括生产、饲养、销售的过程），比如下面这样\n1 2 3 4 5 6 7 8 class Farm { public: CreateHorse(); FeedHorse(); SellHorse(); private: Horse horse_; } 需要添加金养牛的程序，那么大多数情况会出现一个switch的分支，随着饲养的品种越来越多，最后会在生产、饲养和售卖的各个过程中出现多个switch分支。如果我是农场主，代码会陷入“分支瘫痪”，对维护这一套代码感到厌烦。比如下面这样\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Farm { public: CreateAnimal() { if (animaltype == \u0026#34;horse\u0026#34;) { // create horse } else if (animaltype == \u0026#34;cow\u0026#34;) { // ceate cow } ... else { // create others } } FeedAnimal() { if (animaltype == \u0026#34;horse\u0026#34;) { // feed horse } else if (animaltype == \u0026#34;cow\u0026#34;) { // feed cow } ... else { // feed others } } SellAnimal() { if (animaltype == \u0026#34;horse\u0026#34;) { // sell horse } else if (animaltype == \u0026#34;cow\u0026#34;) { // sell cow } ... else { // sell others } } private: int animaltype; 这样的方案有什么明显的缺点呢？\n高耦合，这个大类中的函数有一处需要添加分支，每个函数就都需要变化，但是每个函数实际是售卖动物的不耦合的步骤（生产不影响饲养，饲养不影响售卖），这些步骤之间耦合太紧，导致“霰弹式修改”； 分支瘫痪，添加的类别越多，代码的if/else/switch的分支越多，最后陷入分支瘫痪的状态。 解决方案 按照《设计模式解析》中的原则，设计模式需要遵循如下的一些原则：\n考虑设计中什么应该是可变的； 对变化的概念进行封装； 优先使用对象聚集而不是类继承 在上面的例子中，有两个基本要素——农场和动物，每一个类应该对自己的职责负责，\n农场负责生产和饲养动物，不同种类的动物生产和饲养的方式都不同； 动物被售卖，不同的动物售卖的价格均不同； 可以看出可以将之前的方案拆解成两个类Farm和Animal，而且生产、饲养和售卖的方式都是可变的，所以这些方法都是虚方法。对于具体的动物，生成具体的农场和动物。\nUML表示及其代码 参考解决方案的内容，我们画出这些类的UML的图，如下所示\n具体的代码如下所示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;iostream\u0026gt; using namespace std; class Animal { public: virtual void Sell() = 0; Animal(int price = 5, int id = 0) :price_(price), id_(id) {}; protected: int price_; int id_; }; class Horse : public Animal { public: void Sell() { cout \u0026lt;\u0026lt; id_ \u0026lt;\u0026lt; \u0026#34;: Horse sell \u0026#34; \u0026lt;\u0026lt; price_ \u0026lt;\u0026lt; \u0026#34; yuan\\n\u0026#34;; } Horse(int price = 5, int id = 0) : Animal(price, id) {}; }; class Cow : public Animal { public: void Sell() { cout \u0026lt;\u0026lt; id_ \u0026lt;\u0026lt; \u0026#34;: Cow sell \u0026#34; \u0026lt;\u0026lt; price_ \u0026lt;\u0026lt; \u0026#34; yuan\\n\u0026#34;; } Cow(int price = 5, int id = 0) : Animal(price, id) {}; }; class Farm { public: virtual Animal* Create(int id, int price) = 0; }; class HorseFarm : public Farm { public: Animal* Create(int id, int price) { return new Horse(price, id); } }; class CowFarm : public Farm { public: Animal* Create(int id, int price) { return new Cow(price, id); } }; int main() { Farm* factory = new HorseFarm(); Animal* horse = factory-\u0026gt;Create(1, 32); horse-\u0026gt;Sell(); factory = new CowFarm(); Animal* cow = factory-\u0026gt;Create(0, 12); cow-\u0026gt;Sell(); delete factory; delete horse; delete cow; return 0; } ","date":"2021-05-02T21:43:54+08:00","image":"https://pic.imgdb.cn/item/608eae16d1a9ae528f502e1a.png","permalink":"https://blog.bugxch.top/p/factory-method%E6%A8%A1%E5%BC%8F%E7%B2%BE%E8%A7%A3c-%E7%89%88%E6%9C%AC/","title":"Factory Method模式精解（C++版本）"},{"content":"设计模式第三弹，设计模式行为型模式中的模板方法，也比较简单。\n使用情景 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method是行为型模式，使得子类可以不改变算法的结构（步骤）即可重定义该算法的某些特定步骤。\n模板方法将整个算法转换为一系列独立的步骤， 以便子类能对其进行扩展， 同时还可让超类中所定义的结构保持完整。可以设想我们上学时候临摹毛笔字，你可以使用墨汁沿着田字格中的汉字临摹，也可以使用红墨水临摹，无论用哪种颜色的墨水，最后完成的字的形状是一样的。\n汉字的字形就是模板，每个学生使用不同的工具或者墨水按照模板习字，就是模板方法。\n问题引入 Template Method就是带有模板功能的模式，它有下面的特点：\n组成模板的方法被定义在父类中，但是这些方法是抽象方法，具体的方法实现由各个子类实现； 父类中定义了处理流程的框架，这个流程由上面定义的这些方法按照特定的步骤完成。 打一个比方，如果我们村里的每个人盖一座房子，无论是谁都需要完成如下的步骤，准备材料，设计图纸，雇佣施工队，开工建设，完成这些步骤之后才能盖起一座完整的房子。但是不同的人使用的材料不同，设计的图纸不同，施工队的质量也不一样，依照主人的品味和资金实力每一个步骤不同的人做就有不同的效果。这里的所有步骤就是模板方法，不同的人就是子类。\nUML表示及代码 参考《图解设计模式》中第三章的例子，UML图及代码如下所示\n每个类的作用如下 AbstractDisplay是抽象类，定义了整个的流程框架，即方法display()，该方法又由3个抽象方法实现open(), print(), close()； CharDisplay和StringDisplay是具体的继承类，它们实现了抽象类中的抽象方法。 仅仅从抽象类看不出来每个抽象方法的具体实现，这些方法由每个类具体负责，上面的所有的类的具体代码如下。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class AbstractDisplay { public: virtual void open() = 0; virtual void print() = 0; virtual void close() = 0; virtual void display() final { open(); for (int i = 0; i \u0026lt; 5; i++) { print(); } close(); } }; class CharDisplay: public AbstractDisplay { public: CharDisplay(char ch = \u0026#39;h\u0026#39;) : ch_(ch) {}; void open() override { cout \u0026lt;\u0026lt; \u0026#34;\u0026lt;\u0026lt;\u0026#34;; } void close() override { cout \u0026lt;\u0026lt; \u0026#34;\u0026gt;\u0026gt;\\n\u0026#34;; } void print() override { cout \u0026lt;\u0026lt; ch_; } private: char ch_; }; class StringDisplay : public AbstractDisplay { public: StringDisplay(string str = \u0026#34; \u0026#34;, int width = 10) :width_(width), str_(str) {}; void open() override { printLine(); } void print() override { cout \u0026lt;\u0026lt; \u0026#34;|\u0026#34; \u0026lt;\u0026lt; str_ \u0026lt;\u0026lt; \u0026#34;|\\n\u0026#34;; } void close() override { printLine(); } private: string str_; int width_; void printLine() const { cout \u0026lt;\u0026lt; \u0026#34;+\u0026#34;; for (int i = 0; i \u0026lt; width_; i++) { cout \u0026lt;\u0026lt; \u0026#34;-\u0026#34;; } cout \u0026lt;\u0026lt; \u0026#34;+\\n\u0026#34;; } }; int main() { AbstractDisplay* display = new CharDisplay(\u0026#39;H\u0026#39;); display-\u0026gt;display(); delete display; display = new StringDisplay(\u0026#34;Hello World!\u0026#34;); display-\u0026gt;display(); delete display; display = new StringDisplay(\u0026#34;Hello haha!\u0026#34;); display-\u0026gt;display(); delete display; return 0; } 运行结果如下，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;\u0026lt;HHHHH\u0026gt;\u0026gt; +----------+ |Hello World!| |Hello World!| |Hello World!| |Hello World!| |Hello World!| +----------+ +----------+ |Hello haha!| |Hello haha!| |Hello haha!| |Hello haha!| |Hello haha!| +----------+ ","date":"2021-04-30T19:52:15+08:00","image":"https://pic.imgdb.cn/item/608bef5dd1a9ae528f268767.png","permalink":"https://blog.bugxch.top/p/template-method%E6%A8%A1%E5%BC%8F%E7%B2%BE%E8%A7%A3c-%E7%89%88%E6%9C%AC/","title":"Template Method模式精解（C++版本）"},{"content":"本篇是设计模式第二篇，适配器模式，比较好理解。\n使用情景 适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。\n如果你有出国的经验，那么在出国前肯定会在淘宝买一个电源的转接插头带在身上，在国外旅行时为手机或者PC充电。为什么需要这个东西？参考这篇国际旅行电源适配器指南，从文章中可以看出，每个不同的国家和地区的电源插座的形状和电压都不同，比如中国家用交流电是220V，而印度是230V，从电压的角度出发，你也需要一个东西将230V的电源转换成为稳定的220V，才能给电脑供电。\n问题引入 那我们的问题自然就是如果我去印度旅行，如何使用工具将230V的电源转换成220V呢？\n解决方案 解决方案也很简单，使用一个电源适配器即可，它负责将230V电源转换成为220V供我使用。\nUML表示及代码 参考《图解设计模式》的章节，我们有两种适配器模式。\n基于继承的适配器模式 上面的图示中，Banner就是印度的230V电源，PrintBanner是电源适配器，Print表示我的电脑插头，Main函数是我自己。具体的C++代码如下所示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; class Banner { public: Banner(std::string str = \u0026#34;\u0026#34;) : str_(str) {} void showWithParen() const { std::cout \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; str_ \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; std::endl; } void showWithAster() const { std::cout \u0026lt;\u0026lt; \u0026#34;*\u0026#34; \u0026lt;\u0026lt; str_ \u0026lt;\u0026lt; \u0026#34;*\u0026#34; \u0026lt;\u0026lt; std::endl; } private: std::string str_; }; class Print { public: virtual void printWeak() = 0; virtual void printStrong() = 0; }; class PrintBanner : public Print, Banner { public: PrintBanner(std::string str) : Banner(str) {} void printWeak() override { showWithParen(); } void printStrong() override { showWithAster(); } }; using namespace std; int main() { auto printBanner = new PrintBanner(\u0026#34;hello\u0026#34;); printBanner-\u0026gt;printWeak(); printBanner-\u0026gt;printStrong(); delete printBanner; return 0; } 基于委托的适配器模式 另外一种形式是基于委托的模式，这里的“委托”意思是我将本来需要我自己做的事情，交给别人来做，适配器PrintBanner将接口的功能委托给Banner去做。\n具体的程序代码如下（与基于继承的代码仅仅在PrintBanner的类中的内容不同）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class PrintBanner : public Print { public: PrintBanner(std::string str = \u0026#34;\u0026#34;) { banner_ = new Banner(str); } void printWeak() override { banner_-\u0026gt;showWithParen(); } void printStrong() override { banner_-\u0026gt;showWithAster(); } ~PrintBanner() { if (banner_ != nullptr) { delete banner_; } } private: Banner* banner_; }; ","date":"2021-04-29T22:39:41+08:00","image":"https://pic.imgdb.cn/item/608ac85bd1a9ae528fde126e.png","permalink":"https://blog.bugxch.top/p/adapter%E6%A8%A1%E5%BC%8F%E7%B2%BE%E8%A7%A3c-%E7%89%88%E6%9C%AC/","title":"Adapter模式精解（C++版本）"},{"content":"从本文章开始，参考结城浩的《图解设计模式》写23种设计模式的系列介绍文章，结合网络上其他的设计模式的内容，使用C++的语言编写这些设计模式，记录自己的设计模式的心得。\n设计模式分类 在开始设计模式的系列文章之前，先对设计模式的分类做一个说明，下面的说明摘选自GoF 的 23 种设计模式的分类和功能。\n设计模式有两种分类方法，即根据模式的目的来分和根据模式的作用的范围来分。\n根据目的来分 根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。\n创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。 结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。 行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。 根据作用范围来分 根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。\n类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。 一般都选用第一种设计模式的分类方法，总结如下\n使用情景 迭代器模式是一种行为设计模式， 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象内部表示。\nC++中比较典型类似与std的vector的前向迭代器begin()和end()，以及后向迭代器rbegin()和rend()。\n问题引入 可以设想元素聚合成集合的方式，最简单的方式是顺序存储的数组或者列表，但是也有例如树、图和其他复杂的数据结构。所以，如果要遍历集合中的元素，有下面的两个问题需要解决：\n如何在不改变元素的前提下，遍历各种不同的集合？ 同一个集合如果有不同的遍历方式（比如树有前中后序3种不同的遍历顺序），如果在不改变集合的前提下，比较容易扩展这些功能呢？ 解决方案 为了满足开闭原则，我们将定义一个迭代器的类，将迭代从集合种抽象出来，作为一个行为的迭代器处理。如下图所示，对于一个树结构，我们定义了两个迭代器的类，DFS和BFS两个迭代器，这样可以将元素遍历和树本身进行解耦。\nUML表示 我们以《图解设计模式》中遍历书架中的书本为例，有如下的UML图\n对上面的这幅图做进一步的说明，\nAggregate表示集合的接口，书架实现该接口，所以书架必须要有迭代器的方法； Iterator表示集合的迭代器的接口，书架的迭代器实现它； 需要说明的是，此处的迭代器只有一种前向的迭代器，也可以定义后向遍历的迭代器。 C++代码 我们使用C++按照上面的UML图片实现这个设计模式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 #include \u0026lt;iostream\u0026gt; using namespace std; enum State { RIGHT = 0, WRONG, RESERVED = 22 }; // 书本的类 class Book { public: Book(std::string name = \u0026#34;\u0026#34;) : name_(name) {}; std::string getName() const { return name_; }; ~Book() = default; private: std::string name_; }; // 抽象的迭代器类，包括获得下一本书，以及是否有下一本书的判断 class Iterator { public: virtual Book Next() = 0; virtual bool HasNext() const = 0; virtual ~Iterator() = default; }; // 抽象的聚合类，该类有创建迭代器、取得某个位置的书本，弹出书本，计数，加入书本等功能 class Aggregate { public: virtual Iterator* CreateIterator() = 0; virtual State getBookAt(const int index, Book\u0026amp; book) = 0; virtual int Count() const = 0; virtual ~Aggregate() = default; }; // 书架的具体迭代器，实现上面的抽象类的虚函数 class BookShelfIterator : public Iterator { public: BookShelfIterator(Aggregate* aggregate) : aggregate_(aggregate), loc_(0) {}; ~BookShelfIterator() { if (aggregate_ != nullptr) { delete aggregate_; aggregate_ = nullptr; } loc_ = 0; } Book Next() { Book book; aggregate_-\u0026gt;getBookAt(loc_, book); loc_++; return book; } bool HasNext() const { return loc_ \u0026lt; aggregate_-\u0026gt;Count(); } private: int loc_; Aggregate* aggregate_; }; // 具体的聚合类——书架，实现上面的功能 class BookShelf : public Aggregate { public: BookShelf(const int maxSize) :maxSize_(maxSize), count_(0), iterator_(nullptr) { books_.clear(); } Iterator* CreateIterator() { if (iterator_ == nullptr) { iterator_ = new BookShelfIterator(this); } return iterator_; } State getBookAt(const int index, Book\u0026amp; book) { if (index \u0026gt;= count_) { std::cout \u0026lt;\u0026lt; \u0026#34;Wrong index\\n\u0026#34;; return WRONG; } book = books_[index]; return RIGHT; } void Pop() { books_.pop_back(); count_--; } int Count() const { return count_; } void Push(const Book\u0026amp; book) { if (count_ == maxSize_) { std::cout \u0026lt;\u0026lt; \u0026#34;bookshelf is full\\n\u0026#34;; return; } books_.push_back(book); count_++; } ~BookShelf() { if (iterator_ != nullptr) { delete iterator_; iterator_ = nullptr; } maxSize_ = 0; count_ = 0; books_.clear(); } private: int maxSize_; int count_; std::vector\u0026lt;Book\u0026gt; books_; Iterator* iterator_; }; // client int main() { BookShelf* myShelf = new BookShelf(5); myShelf-\u0026gt;Push(Book(\u0026#34;《重构》\u0026#34;)); myShelf-\u0026gt;Push(Book(\u0026#34;《图解设计模式》\u0026#34;)); myShelf-\u0026gt;Push(Book(\u0026#34;《黎曼猜想》\u0026#34;)); Iterator* iter = myShelf-\u0026gt;CreateIterator(); cout \u0026lt;\u0026lt; \u0026#34;书架上有\u0026#34; \u0026lt;\u0026lt; myShelf-\u0026gt;Count() \u0026lt;\u0026lt; \u0026#34;本书：\\n\u0026#34;; while (iter-\u0026gt;HasNext() == true) { cout \u0026lt;\u0026lt; iter-\u0026gt;Next().getName() \u0026lt;\u0026lt; endl; } return 0; } 具体的运行结果如下\n1 2 3 4 书架上有3本书： 《重构》 《图解设计模式》 《黎曼猜想》 分析角色 这个模式有实际上由两个角色，集合以及集合的迭代器，这两个事物由分为抽象和具体两种。我们所举的例子中\nBookShelf就是具体的集合，它实现自抽象的集合接口Aggregate； BookShelfIterator是具体的迭代器，它实现自抽象的迭代器接口Iterator。 迭代器接口中定义了迭代器的遍历的所有方法，HasNext以及Next。 这里需要注意的是，在C++的版本里面集合的接口中不仅定义了创建迭代器的方法CreateIterator，而且定义了集合的个数Count和集合获取当前元素的方法getBookAt，这是因为迭代器中的方法实现依赖这些接口。\n扩展修改 大家可以思考一下为什么我们需要这个模式呢？设计模式的初衷是实现代码的复用和可扩展，这个模式体现在哪里呢？\n遍历方法和集合本身解耦 迭代器模式的重要作用是将集合的遍历和实现分离开来，换句话说，无论实现如何变化，我依然可以使用原来的方法进行遍历，也就是说遍历这个动作本身不会因为书架的实现发生变化而变化，所以下面的代码是不变的\n1 2 3 while (iter-\u0026gt;HasNext() == true) { cout \u0026lt;\u0026lt; iter-\u0026gt;Next().getName() \u0026lt;\u0026lt; endl; } 我们依然仅仅依靠HasNext以及Next接口就可以完成对于书架本身的遍历。\n遍历需求易于扩展 不妨设想一下，假如我们需要在原来的书架上新增一种遍历方式，从后向前实现后向遍历，这个代码该怎么修改呢？应该完成如下的工作：\n在原来的书架类中新增后向遍历的iter指针； 书架类中包含创建后向迭代器的方法； 后向迭代器继承自迭代器类别，实现后向迭代器 然后就可以继续使用原来的遍历方式遍历集合了，具体的代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 enum State { RIGHT = 0, WRONG, RESERVED = 22 }; // concrete book class Book { public: Book(std::string name = \u0026#34;\u0026#34;) : name_(name) {}; std::string getName() const { return name_; }; ~Book() = default; private: std::string name_; }; class Iterator { public: virtual Book Next() = 0; virtual bool HasNext() const = 0; virtual ~Iterator() = default; }; class Aggregate { public: virtual Iterator* CreateForwardIterator() = 0; virtual Iterator* CreateBackwardIterator() = 0; virtual State getBookAt(const int index, Book\u0026amp; book) = 0; virtual int Count() const = 0; virtual ~Aggregate() = default; }; class BookShelfBackwardIterator : public Iterator { public: BookShelfBackwardIterator(Aggregate* aggregate) : aggregate_(aggregate) { loc_ = aggregate_-\u0026gt;Count() - 1; }; ~BookShelfBackwardIterator() { if (aggregate_ != nullptr) { aggregate_ = nullptr; } loc_ = -1; } Book Next() { Book book; aggregate_-\u0026gt;getBookAt(loc_, book); loc_--; return book; } bool HasNext() const { return loc_ \u0026gt;= 0; } private: int loc_; Aggregate* aggregate_; }; class BookShelfForwardIterator : public Iterator { public: BookShelfForwardIterator(Aggregate* aggregate) : aggregate_(aggregate), loc_(0) {}; ~BookShelfForwardIterator() { if (aggregate_ != nullptr) { aggregate_ = nullptr; } loc_ = -1; } Book Next() { Book book; aggregate_-\u0026gt;getBookAt(loc_, book); loc_++; return book; } bool HasNext() const { return loc_ \u0026lt; aggregate_-\u0026gt;Count(); } private: int loc_; Aggregate* aggregate_; }; class BookShelf : public Aggregate { public: BookShelf(const int maxSize) :maxSize_(maxSize), count_(0), iterator_(nullptr), backiter_(nullptr) { books_.clear(); } Iterator* CreateBackwardIterator() { if (backiter_ == nullptr) { backiter_ = new BookShelfBackwardIterator(this); } return backiter_; } Iterator* CreateForwardIterator() { if (iterator_ == nullptr) { iterator_ = new BookShelfForwardIterator(this); } return iterator_; } State getBookAt(const int index, Book\u0026amp; book) { if (index \u0026gt;= count_) { std::cout \u0026lt;\u0026lt; \u0026#34;Wrong index\\n\u0026#34;; return WRONG; } book = books_[index]; return RIGHT; } void Pop() { books_.pop_back(); count_--; } int Count() const { return count_; } void Push(const Book\u0026amp; book) { if (count_ == maxSize_) { std::cout \u0026lt;\u0026lt; \u0026#34;bookshelf is full\\n\u0026#34;; return; } books_.push_back(book); count_++; } ~BookShelf() { if (iterator_ != nullptr) { delete iterator_; iterator_ = nullptr; } if (backiter_ != nullptr) { delete backiter_; backiter_ = nullptr; } maxSize_ = 0; count_ = 0; books_.clear(); } private: int maxSize_; int count_; std::vector\u0026lt;Book\u0026gt; books_; Iterator* iterator_; Iterator* backiter_; }; using namespace std; // book class int main() { BookShelf* myShelf = new BookShelf(5); myShelf-\u0026gt;Push(Book(\u0026#34;《重构》\u0026#34;)); myShelf-\u0026gt;Push(Book(\u0026#34;《图解设计模式》\u0026#34;)); myShelf-\u0026gt;Push(Book(\u0026#34;《黎曼猜想》\u0026#34;)); Iterator* iter = myShelf-\u0026gt;CreateForwardIterator(); cout \u0026lt;\u0026lt; \u0026#34;前向遍历\u0026#34; \u0026lt;\u0026lt; myShelf-\u0026gt;Count() \u0026lt;\u0026lt; \u0026#34;本书：\\n\u0026#34;; while (iter-\u0026gt;HasNext()) { cout \u0026lt;\u0026lt; iter-\u0026gt;Next().getName() \u0026lt;\u0026lt; endl; } iter = nullptr; iter = myShelf-\u0026gt;CreateBackwardIterator(); cout \u0026lt;\u0026lt; \u0026#34;后向遍历\u0026#34; \u0026lt;\u0026lt; myShelf-\u0026gt;Count() \u0026lt;\u0026lt; \u0026#34;本书：\\n\u0026#34;; while (iter-\u0026gt;HasNext()) { cout \u0026lt;\u0026lt; iter-\u0026gt;Next().getName() \u0026lt;\u0026lt; endl; } return 0; } 运行效果如下\n1 2 3 4 5 6 7 8 前向遍历3本书： 《重构》 《图解设计模式》 《黎曼猜想》 后向遍历3本书： 《黎曼猜想》 《图解设计模式》 《重构》 参考资料 图说设计模式 — Graphic Design Patterns 图灵程序设计丛书 图解设计模式，图解设计模式的pdf下载地址 设计模式目录：22种设计模式，乌克兰的某个程序员写的设计模式的网页，非常不错 ","date":"2021-04-10T22:15:09+08:00","image":"https://pic.imgdb.cn/item/6086d967d1a9ae528f307ce1.jpg","permalink":"https://blog.bugxch.top/p/iterator%E6%A8%A1%E5%BC%8F%E7%B2%BE%E8%A7%A3c-%E7%89%88%E6%9C%AC/","title":"Iterator模式精解（C++版本）"},{"content":"这是一篇转载，点击查看原文链接。\n数据压倒一切。如果选择了正确的数据结构并把一切组织的井井有条，正确的算法就不言自明。编程的核心是数据结构，而不是算法. \u0026ndash; Rob Pike\n本文基于这样的认识：数据是易变的，逻辑是稳定的。本文例举的编程实现多为代码片段，但不影响描述的完整性。本文例举的编程虽然基于C语言，但其编程思想也适用于其他语言。此外，本文不涉及语言相关的运行效率讨论。\n概念提出 所谓表驱动法(Table-Driven Approach)简而言之就是用查表的方法获取数据。此处的“表”通常为数组，但可视为数据库的一种体现。根据字典中的部首检字表查找读音未知的汉字就是典型的表驱动法，即以每个字的字形为依据，计算出一个索引值，并映射到对应的页数。相比一页一页地顺序翻字典查字，部首检字法效率极高。\n具体到编程方面，在数据不多时可用逻辑判断语句(if…else或switch…case)来获取值；但随着数据的增多，逻辑语句会越来越长，此时表驱动法的优势就开始显现。例如，用36进制(A表示10，B表示11，…)表示更大的数字，逻辑判断语句如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 if(ucNum \u0026lt; 10) { ucNumChar = ConvertToChar(ucNum); } else if(ucNum == 10) { ucNumChar = \u0026#39;A\u0026#39;; } else if(ucNum == 11) { ucNumChar = \u0026#39;B\u0026#39;; } else if(ucNum == 12) { ucNumChar = \u0026#39;C\u0026#39;; } //... ... else if(ucNum == 35) { ucNumChar = \u0026#39;Z\u0026#39;; } 当然也可以用switch…case结构，但实现都很冗长。而用表驱动法(将numChar存入数组)则非常直观和简洁。如：\n1 2 CHAR aNumChars[] = {\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, /*3~9*/\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, /*D~Y*/\u0026#39;Z\u0026#39;}; CHAR ucNumChar = aNumChars[ucNum % sizeof(aNumChars)]; 像这样直接将变量当作下数组下标来读取数值的方法就是直接查表法。注意，如果熟悉字符串操作，则上述写法可以更简洁：\n1 CHAR ucNumChar = \u0026#34;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;[ucNum]; 使用表驱动法时需要关注两个问题：一是如何查表，从表中读取正确的数据；二是表里存放什么，如数值或函数指针。前者参见1.1节“查表方式”内容，后者参见1.2节“实战示例”内容。\n查表方式 常用的查表方式有直接查找、索引查找和分段查找等。\n直接查找 即直接通过数组下标获取到数据。如果熟悉哈希表的话，可以很容易看出这种查表方式就是哈希表的直接访问法。如获取星期名称，逻辑判断语句如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 if(0 == ucDay) { pszDayName = \u0026#34;Sunday\u0026#34;; } else if(1 == ucDay) { pszDayName = \u0026#34;Monday\u0026#34;; } //... ... else if(6 == ucDay) { pszDayName = \u0026#34;Saturday\u0026#34;; } 而实现同样的功能，可将这些数据存储到一个表里：\n1 2 CHAR *paNumChars[] = {\u0026#34;Sunday\u0026#34;, \u0026#34;Monday\u0026#34;, \u0026#34;Tuesday\u0026#34;, \u0026#34;Wednesday\u0026#34;, \u0026#34;Thursday\u0026#34;, \u0026#34;Friday\u0026#34;, \u0026#34;Saturday\u0026#34;}; CHAR *pszDayName = paNumChars[ucDay]; 类似哈希表特性，表驱动法适用于无需有序遍历数据，且数据量大小可提前预测的情况。对于过于复杂和庞大的判断，可将数据存为文件，需要时加载文件初始化数组，从而在不修改程序的情况下调整里面的数值。\n有时，访问之前需要先进行一次键值转换。如表驱动法表示端口忙闲时，需将槽位端口号映射为全局编号。所生成的端口数目大小的数组，其下标对应全局端口编号，元素值表示相应端口的忙闲状态。\n索引查找 有时通过一次键值转换，依然无法把数据(如英文单词等)转为键值。此时可将转换的对应关系写到一个索引表里，即索引访问。\n如现有100件商品，4位编号，范围从0000到9999。此时只需要申请一个长度为100的数组，且对应2位键值。但将4位的编号转换为2位的键值，可能过于复杂或没有规律，最合适的方法是建立一个保存该转换关系的索引表。采用索引访问既节省内存，又方便维护。比如索引A表示通过名称访问，索引B表示通过编号访问。\n分段查找 通过确定数据所处的范围确定分类(下标)。有的数据可分成若干区间，即具有阶梯性，如分数等级。此时可将每个区间的上限(或下限)存到一个表中，将对应的值存到另一表中，通过第一个表确定所处的区段，再由区段下标在第二个表里读取相应数值。注意要留意端点，可用二分法查找，另外可考虑通过索引方法来代替。如根据分数查绩效等级：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #define MAX_GRADE_LEVEL (INT8U)5 DOUBLE aRangeLimit[MAX_GRADE_LEVEL] = {50.0, 60.0, 70.0, 80.0, 100.0}; CHAR *paGrades[MAX_GRADE_LEVEL] = {\u0026#34;Fail\u0026#34;, \u0026#34;Pass\u0026#34;, \u0026#34;Credit\u0026#34;, \u0026#34;Distinction\u0026#34;, \u0026#34;High Distinction\u0026#34;}; static CHAR* EvaluateGrade(DOUBLE dScore) { INT8U ucLevel = 0; for(; ucLevel \u0026lt; MAX_GRADE_LEVEL; ucLevel++) { if(dScore \u0026lt; aRangeLimit[ucLevel]) return paGrades[ucLevel]; } return paGrades[0]; } 上述两张表(数组)也可合并为一张表(结构体数组)，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 typedef struct{ DOUBLE aRangeLimit; CHAR *pszGrade; }T_GRADE_MAP; T_GRADE_MAP gGradeMap[MAX_GRADE_LEVEL] = { {50.0, \u0026#34;Fail\u0026#34;}, {60.0, \u0026#34;Pass\u0026#34;}, {70.0, \u0026#34;Credit\u0026#34;}, {80.0, \u0026#34;Distinction\u0026#34;}, {100.0, \u0026#34;High Distinction\u0026#34;} }; static CHAR* EvaluateGrade(DOUBLE dScore) { INT8U ucLevel = 0; for(; ucLevel \u0026lt; MAX_GRADE_LEVEL; ucLevel++) { if(dScore \u0026lt; gGradeMap[ucLevel].aRangeLimit) return gGradeMap[ucLevel].pszGrade; } return gGradeMap[0].pszGrade; } 该表结构已具备的数据库的雏形，并可扩展支持更为复杂的数据。其查表方式通常为索引查找，偶尔也为分段查找；当索引具有规律性(如连续整数)时，退化为直接查找。\n使用分段查找法时应注意边界，将每一分段范围的上界值都考虑在内。找出所有不在最高一级范围内的值，然后把剩下的值全部归入最高一级中。有时需要人为地为最高一级范围添加一个上界。同时应小心不要错误地用“\u0026lt;”来代替“\u0026lt;=”。要保证循环在找出属于最高一级范围内的值后恰当地结束，同时也要保证恰当处理范围边界。\n实战示例 本节多数示例取自实际项目。表形式为一维数组、二维数组和结构体数组；表内容有数据、字符串和函数指针。基于表驱动的思想，表形式和表内容可衍生出丰富的组合。\n字符统计 问题：统计用户输入的一串数字中每个数字出现的次数。普通解法主体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 INT32U aDigitCharNum[10] = {0}; /* 输入字符串中各数字字符出现的次数 */ INT32U dwStrLen = strlen(szDigits); INT32U dwStrIdx = 0; for(; dwStrIdx \u0026lt; dwStrLen; dwStrIdx++) { switch(szDigits[dwStrIdx]) { case \u0026#39;1\u0026#39;: aDigitCharNum[0]++; break; case \u0026#39;2\u0026#39;: aDigitCharNum[1]++; break; //... ... case \u0026#39;9\u0026#39;: aDigitCharNum[8]++; break; } } 这种解法的缺点显而易见，既不美观也不灵活。其问题关键在于未将数字字符与数组aDigitCharNum下标直接关联起来。以下示出更简洁的实现方式：\n1 2 3 4 for(; dwStrIdx \u0026lt; dwStrLen; dwStrIdx++) { aDigitCharNum[szDigits[dwStrIdx] - \u0026#39;0\u0026#39;]++; } 上述实现考虑到0也为数字字符。该解法也可扩展至统计所有ASCII可见字符。\n月天校验 问题：对给定年份和月份的天数进行校验(需区分平年和闰年)。普通解法主体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 switch(OnuTime.Month) { case 1: case 3: case 5: case 7: case 8: case 10: case 12: if(OnuTime.Day\u0026gt;31 || OnuTime.Day\u0026lt;1) { CtcOamLog(FUNCTION_Pon,\u0026#34;Don\u0026#39;t support this Day: %d(1~31)!!!\\n\u0026#34;, OnuTime.Day); retcode = S_ERROR; } break; case 2: if(((OnuTime.Year%4 == 0) \u0026amp;\u0026amp; (OnuTime.Year%100 != 0)) || (OnuTime.Year%400 == 0)) { if(OnuTime.Day\u0026gt;29 || OnuTime.Day\u0026lt;1) { CtcOamLog(FUNCTION_Pon,\u0026#34;Don\u0026#39;t support this Day: %d(1~29)!!!\\n\u0026#34;, OnuTime.Day); retcode = S_ERROR; } } else { if(OnuTime.Day\u0026gt;28 || OnuTime.Day\u0026lt;1) { CtcOamLog(FUNCTION_Pon,\u0026#34;Don\u0026#39;t support this Day: %d(1~28)!!!\\n\u0026#34;, OnuTime.Day); retcode = S_ERROR; } } break; case 4: case 6: case 9: case 11: if(OnuTime.Day\u0026gt;30 || OnuTime.Day\u0026lt;1) { CtcOamLog(FUNCTION_Pon,\u0026#34;Don\u0026#39;t support this Day: %d(1~30)!!!\\n\u0026#34;, OnuTime.Day); retcode = S_ERROR; } break; default: CtcOamLog(FUNCTION_Pon,\u0026#34;Don\u0026#39;t support this Month: %d(1~12)!!!\\n\u0026#34;, OnuTime.Month); retcode = S_ERROR; break; } 以下示出更简洁的实现方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #define MONTH_OF_YEAR 12 /* 一年中的月份数 */ /* 闰年：能被4整除且不能被100整除，或能被400整除 */ #define IS_LEAP_YEAR(year) ((((year) % 4 == 0) \u0026amp;\u0026amp; ((year) % 100 != 0)) || ((year) % 400 == 0)) /* 平年中的各月天数，下标对应月份 */ INT8U aDayOfCommonMonth[MONTH_OF_YEAR] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; INT8U ucMaxDay = 0; if((OnuTime.Month == 2) \u0026amp;\u0026amp; (IS_LEAP_YEAR(OnuTime.Year))) ucMaxDay = aDayOfCommonMonth[1] + 1; else ucMaxDay = aDayOfCommonMonth[OnuTime.Month-1]; if((OnuTime.Day \u0026lt; 1) || (OnuTime.Day \u0026gt; ucMaxDay) { CtcOamLog(FUNCTION_Pon,\u0026#34;Month %d doesn\u0026#39;t have this Day: %d(1~%d)!!!\\n\u0026#34;, OnuTime.Month, OnuTime.Day, ucMaxDay); retcode = S_ERROR; } 名称构造 问题：根据WAN接口承载的业务类型(Bitmap)构造业务类型名称字符串。普通解法主体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void Sub_SetServerType(INT8U *ServerType, INT16U wan_servertype) { if ((wan_servertype \u0026amp; 0x0001) == 0x0001) { strcat(ServerType, \u0026#34;_INTERNET\u0026#34;); } if ((wan_servertype \u0026amp; 0x0002) == 0x0002) { strcat(ServerType, \u0026#34;_TR069\u0026#34;); } if ((wan_servertype \u0026amp; 0x0004) == 0x0004) { strcat(ServerType, \u0026#34;_VOIP\u0026#34;); } if ((wan_servertype \u0026amp; 0x0008) == 0x0008) { strcat(ServerType, \u0026#34;_OTHER\u0026#34;); } } 以下示出C语言中更简洁的实现方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #define GET_BIT(var, bit) (((var) \u0026gt;\u0026gt; (bit)) \u0026amp; 0x1) /* 获取var变量第bit位，编号从右至左 */ const CHAR* paSvrNames[] = {\u0026#34;_INTERNET\u0026#34;, \u0026#34;_TR069\u0026#34;, \u0026#34;_VOIP\u0026#34;, \u0026#34;_OTHER\u0026#34;}; const INT8U ucSvrNameNum = sizeof(paSvrNames) / sizeof(paSvrNames[0]); VOID SetServerType(CHAR *pszSvrType, INT16U wSvrType) { INT8U ucIdx = 0; for(; ucIdx \u0026lt; ucSvrNameNum; ucIdx++) { if(1 == GET_BIT(wSvrType, ucIdx)) strcat(pszSvrType, paSvrNames[ucIdx]); } } 新的实现将数据和逻辑分离，维护起来非常方便。只要逻辑(规则)不变，则唯一可能的改动就是数据(paSvrNames)。\n值名解析 问题：根据枚举变量取值输出其对应的字符串，如PORT_FE(1)输出“Fe”。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 //值名映射表结构体定义，用于数值解析器 typedef struct{ INT32U dwElem; //待解析数值，通常为枚举变量 CHAR* pszName; //指向数值所对应解析名字符串的指针 }T_NAME_PARSER; /****************************************************************************** * 函数名称: NameParser * 功能说明: 数值解析器，将给定数值转换为对应的具名字符串 * 输入参数: VOID *pvMap :值名映射表数组，含T_NAME_PARSER结构体类型元素 VOID指针允许用户在保持成员数目和类型不变的前提下， 定制更有意义的结构体名和/或成员名。 INT32U dwEntryNum :值名映射表数组条目数 INT32U dwElem :待解析数值，通常为枚举变量 INT8U* pszDefName :缺省具名字符串指针，可为空 * 输出参数: NA * 返回值 : INT8U *: 数值所对应的具名字符串 当无法解析给定数值时，若pszDefName为空，则返回数值对应的16进制格式 字符串；否则返回pszDefName。 ******************************************************************************/ INT8U *NameParser(VOID *pvMap, INT32U dwEntryNum, INT32U dwElem, INT8U* pszDefName) { CHECK_SINGLE_POINTER(pvMap, \u0026#34;NullPoniter\u0026#34;); INT32U dwEntryIdx = 0; for(dwEntryIdx = 0; dwEntryIdx \u0026lt; dwEntryNum; dwEntryIdx++) { T_NAME_PARSER *ptNameParser = (T_NAME_PARSER *)pvMap; if(dwElem == ptNameParser-\u0026gt;dwElem) { return ptNameParser-\u0026gt;pszName; } //ANSI标准禁止对void指针进行算法操作；GNU标准则指定void*算法操作与char*一致。 //若考虑移植性，可将pvMap类型改为INT8U*，或定义INT8U*局部变量指向pvMap。 pvMap += sizeof(T_NAME_PARSER); } if(NULL != pszDefName) { return pszDefName; } else { static INT8U szName[12] = {0}; //Max:\u0026#34;0xFFFFFFFF\u0026#34; sprintf(szName, \u0026#34;0x%X\u0026#34;, dwElem); return szName; } } 以下给出NameParser的简单应用示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //UNI端口类型值名映射表结构体定义 typedef struct{ INT32U dwPortType; INT8U* pszPortName; }T_PORT_NAME; //UNI端口类型解析器 T_PORT_NAME gUniNameMap[] = { {1, \u0026#34;Fe\u0026#34;}, {3, \u0026#34;Pots\u0026#34;}, {99, \u0026#34;Vuni\u0026#34;} }; const INT32U UNI_NAM_MAP_NUM = (INT32U)(sizeof(gUniNameMap)/sizeof(T_PORT_NAME)); VOID NameParserTest(VOID) { INT8U ucTestIndex = 1; printf(\u0026#34;[%s]\u0026lt;Test Case %u\u0026gt; Result: %s!\\n\u0026#34;, __FUNCTION__, ucTestIndex++, strcmp(\u0026#34;Unknown\u0026#34;, NameParser(gUniNameMap, UNI_NAM_MAP_NUM, 0, \u0026#34;Unknown\u0026#34;)) ? \u0026#34;ERROR\u0026#34; : \u0026#34;OK\u0026#34;); printf(\u0026#34;[%s]\u0026lt;Test Case %u\u0026gt; Result: %s!\\n\u0026#34;, __FUNCTION__, ucTestIndex++, strcmp(\u0026#34;DefName\u0026#34;, NameParser(gUniNameMap, UNI_NAM_MAP_NUM, 0, \u0026#34;DefName\u0026#34;)) ? \u0026#34;ERROR\u0026#34; : \u0026#34;OK\u0026#34;); printf(\u0026#34;[%s]\u0026lt;Test Case %u\u0026gt; Result: %s!\\n\u0026#34;, __FUNCTION__, ucTestIndex++, strcmp(\u0026#34;Fe\u0026#34;, NameParser(gUniNameMap, UNI_NAM_MAP_NUM, 1, \u0026#34;Unknown\u0026#34;)) ? \u0026#34;ERROR\u0026#34; : \u0026#34;OK\u0026#34;); printf(\u0026#34;[%s]\u0026lt;Test Case %u\u0026gt; Result: %s!\\n\u0026#34;, __FUNCTION__, ucTestIndex++, strcmp(\u0026#34;Pots\u0026#34;, NameParser(gUniNameMap, UNI_NAM_MAP_NUM, 3, \u0026#34;Unknown\u0026#34;)) ? \u0026#34;ERROR\u0026#34; : \u0026#34;OK\u0026#34;); printf(\u0026#34;[%s]\u0026lt;Test Case %u\u0026gt; Result: %s!\\n\u0026#34;, __FUNCTION__, ucTestIndex++, strcmp(\u0026#34;Vuni\u0026#34;, NameParser(gUniNameMap, UNI_NAM_MAP_NUM, 99, NULL)) ? \u0026#34;ERROR\u0026#34; : \u0026#34;OK\u0026#34;); printf(\u0026#34;[%s]\u0026lt;Test Case %u\u0026gt; Result: %s!\\n\u0026#34;, __FUNCTION__, ucTestIndex++, strcmp(\u0026#34;Unknown\u0026#34;, NameParser(gUniNameMap, UNI_NAM_MAP_NUM, 255, \u0026#34;Unknown\u0026#34;)) ? \u0026#34;ERROR\u0026#34; : \u0026#34;OK\u0026#34;); printf(\u0026#34;[%s]\u0026lt;Test Case %u\u0026gt; Result: %s!\\n\u0026#34;, __FUNCTION__, ucTestIndex++, strcmp(\u0026#34;0xABCD\u0026#34;, NameParser(gUniNameMap, UNI_NAM_MAP_NUM, 0xABCD, NULL)) ? \u0026#34;ERROR\u0026#34; : \u0026#34;OK\u0026#34;); printf(\u0026#34;[%s]\u0026lt;Test Case %u\u0026gt; Result: %s!\\n\u0026#34;, __FUNCTION__, ucTestIndex++, strcmp(\u0026#34;NullPoniter\u0026#34;, NameParser(NULL, UNI_NAM_MAP_NUM, 0xABCD, NULL)) ? \u0026#34;ERROR\u0026#34; : \u0026#34;OK\u0026#34;); } gUniNameMap在实际项目中有十余个条目，若采用逻辑链实现将非常冗长。\n取值映射 问题：不同模块间同一参数枚举值取值可能有所差异，需要适配。此处不再给出普通的switch…case或if…else if…else结构，而直接示出以下表驱动实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 typedef struct{ PORTSTATE loopMEState; PORTSTATE loopMIBState; }LOOPMAPSTRUCT; static LOOPMAPSTRUCT s_CesLoop[] = { {NO_LOOP, e_ds1_looptype_noloop}, {PAYLOAD_LOOP, e_ds1_looptype_PayloadLoop}, {LINE_LOOP, e_ds1_looptype_LineLoop}, {PON_LOOP, e_ds1_looptype_OtherLoop}, {CES_LOOP, e_ds1_looptype_InwardLoop}}; PORTSTATE ConvertLoopMEStateToMIBState(PORTSTATE vPortState) { INT32U num = 0, ii; num = ARRAY_NUM(s_CesLoop); for(ii = 0; ii \u0026lt; num; ii++) { if(vPortState == s_CesLoop[ii].loopMEState) return s_CesLoop[ii].loopMIBState; } return e_ds1_looptype_noloop; } 相应地，从loopMIBState映射到loopMEState需要定义一个ConvertLoopMIBStateToMEState函数。更进一步，所有类似的一对一映射关系都必须如上的映射(转换)函数，相当繁琐。事实上，从抽象层面看，该映射关系非常简单。提取共性后定义带参数宏，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /********************************************************** * 功能描述：进行二维数组映射表的一对一映射，用于参数适配 * 参数说明：map -- 二维数组映射表 elemSrc -- 映射源，即待映射的元素值 elemDest -- 映射源对应的映射结果 direction -- 映射方向字节，表示从数组哪列映射至哪列。 高4位对应映射源列，低4位对应映射结果列。 defaultVal -- 映射失败时置映射结果为缺省值 * 示例： ARRAY_MAPPER(gCesLoopMap, 3, ucLoop, 0x10, NO_LOOP); 则ucLoop = 2(LINE_LOOP) **********************************************************/ #define ARRAY_MAPPER(map, elemSrc, elemDest, direction, defaultVal) do{\\ INT8U ucMapIdx = 0, ucMapNum = 0; \\ ucMapNum = sizeof(map)/sizeof(map[0]); \\ for(ucMapIdx = 0; ucMapIdx \u0026lt; ucMapNum; ucMapIdx++) \\ { \\ if((elemSrc) == map[ucMapIdx][((direction)\u0026amp;0xF0)\u0026gt;\u0026gt;4]) \\ { \\ elemDest = map[ucMapIdx][(direction)\u0026amp;0x0F]; \\ break; \\ } \\ } \\ if(ucMapIdx == ucMapNum) \\ { \\ elemDest = (defaultVal); \\ } \\ }while(0) 参数取值转换时直接调用统一的映射器宏，如下：\n1 2 3 4 5 6 7 8 static INT8U gCesLoopMap[][2] = { {NO_LOOP, e_ds1_looptype_noloop}, {PAYLOAD_LOOP, e_ds1_looptype_PayloadLoop}, {LINE_LOOP, e_ds1_looptype_LineLoop}, {PON_LOOP, e_ds1_looptype_OtherLoop}, {CES_LOOP, e_ds1_looptype_InwardLoop}}; ARRAY_MAPPER(gCesLoopMap, tPara.dwParaVal[0], dwLoopConf, 0x01, e_ds1_looptype_noloop); 另举一例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #define CES_DEFAULT_JITTERBUF (INT32U)2000 /* 默认jitterbuf为2000us，而1帧=125us */ #define CES_JITTERBUF_STEP (INT32U)125 /* jitterbuf步长为125us，即1帧 */ #define CES_DEFAULT_QUEUESIZE (INT32U)5 #define CES_DEFAULT_MAX_QUEUESIZE (INT32U)7 #define ARRAY_NUM(array) (sizeof(array) / sizeof((array)[0])) /* 数组元素个数 */ typedef struct{ INT32U dwJitterBuffer; INT32U dwFramePerPkt; INT32U dwQueueSize; }QUEUE_SIZE_MAP; /* gCesQueueSizeMap也可以(JitterBuffer / FramePerPkt)值为索引，更加紧凑 */ static QUEUE_SIZE_MAP gCesQueueSizeMap[]= { {1,1,1}, {1,2,1}, {2,1,2}, {2,2,1}, {3,1,3}, {3,2,1}, {4,1,3}, {4,2,1}, {5,1,4}, {5,2,3}, {6,1,4}, {6,2,3}, {7,1,4}, {7,2,3}, {8,1,4}, {8,2,3}, {9,1,5}, {9,2,4}, {10,1,5}, {10,2,4}, {11,1,5}, {11,2,4}, {12,1,5}, {12,2,4}, {13,1,5}, {13,2,4}, {14,1,5}, {14,2,4}, {15,1,5}, {15,2,4}, {16,1,5}, {16,2,4}, {17,1,6}, {17,2,5}, {18,1,6}, {18,2,5}, {19,1,6}, {19,2,5}, {20,1,6}, {20,2,5}, {21,1,6}, {21,2,5}, {22,1,6}, {22,2,5}, {23,1,6}, {23,2,5}, {24,1,6}, {24,2,5}, {25,1,6}, {25,2,5}, {26,1,6}, {26,2,5}, {27,1,6}, {27,2,5}, {28,1,6}, {28,2,5}, {29,1,6}, {29,2,5}, {30,1,6}, {30,2,5}, {31,1,6}, {31,2,5}, {32,1,6}, {32,2,5}}; /********************************************************** * 函数名称： CalcQueueSize * 功能描述： 根据JitterBuffer和FramePerPkt计算QueueSize * 注意事项： 配置的最大缓存深度 * = 2 * JitterBuffer / FramePerPkt * = 2 * N Packet = 2 ^ QueueSize * JitterBuffer为125us帧速率的倍数， * FramePerPkt为每个分组的帧数， * QueueSize向上取整，最大为7。 **********************************************************/ INT32U CalcQueueSize(INT32U dwJitterBuffer, INT32U dwFramePerPkt) { INT8U ucIdx = 0, ucNum = 0; //本函数暂时仅考虑E1 ucNum = ARRAY_NUM(gCesQueueSizeMap); for(ucIdx = 0; ucIdx \u0026lt; ucNum; ucIdx++) { if((dwJitterBuffer == gCesQueueSizeMap[ucIdx].dwJitterBuffer) \u0026amp;\u0026amp; (dwFramePerPkt == gCesQueueSizeMap[ucIdx].dwFramePerPkt)) { return gCesQueueSizeMap[ucIdx].dwQueueSize; } } return CES_DEFAULT_MAX_QUEUESIZE; } 版本控制 问题：控制OLT与ONU之间的版本协商。ONU本地设置三比特控制字，其中bit2(MSB)~bit0(LSB)分别对应0x21、0x30和0xAA版本号；且bitX为0表示上报对应版本号，bitX为1表示不上报对应版本号。其他版本号如0x20、0x13和0x1必须上报，即不受控制。最初的实现采用if…else if…else结构，代码非常冗长，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 pstSendTlv-\u0026gt;ucLength = 0x1f; if (gOamCtrlCode == 0) { vosMemCpy(pstSendTlv-\u0026gt;aucVersionList, ctc_oui, 3); pstSendTlv-\u0026gt;aucVersionList[3] = 0x30; vosMemCpy(\u0026amp;(pstSendTlv-\u0026gt;aucVersionList[4]), ctc_oui, 3); pstSendTlv-\u0026gt;aucVersionList[7] = 0x21; vosMemCpy(\u0026amp;(pstSendTlv-\u0026gt;aucVersionList[8]), ctc_oui, 3); pstSendTlv-\u0026gt;aucVersionList[11] = 0x20; vosMemCpy(\u0026amp;(pstSendTlv-\u0026gt;aucVersionList[12]), ctc_oui, 3); pstSendTlv-\u0026gt;aucVersionList[15] = 0x13; vosMemCpy(\u0026amp;(pstSendTlv-\u0026gt;aucVersionList[16]), ctc_oui, 3); pstSendTlv-\u0026gt;aucVersionList[19] = 0x01; vosMemCpy(\u0026amp;(pstSendTlv-\u0026gt;aucVersionList[20]), ctc_oui, 3); pstSendTlv-\u0026gt;aucVersionList[23] = 0xaa; } else if (gOamCtrlCode == 1) { vosMemCpy(pstSendTlv-\u0026gt;aucVersionList, ctc_oui, 3); pstSendTlv-\u0026gt;aucVersionList[3] = 0x30; vosMemCpy(\u0026amp;(pstSendTlv-\u0026gt;aucVersionList[4]), ctc_oui, 3); pstSendTlv-\u0026gt;aucVersionList[7] = 0x21; vosMemCpy(\u0026amp;(pstSendTlv-\u0026gt;aucVersionList[8]), ctc_oui, 3); pstSendTlv-\u0026gt;aucVersionList[11] = 0x20; vosMemCpy(\u0026amp;(pstSendTlv-\u0026gt;aucVersionList[12]), ctc_oui, 3); pstSendTlv-\u0026gt;aucVersionList[15] = 0x13; vosMemCpy(\u0026amp;(pstSendTlv-\u0026gt;aucVersionList[16]), ctc_oui, 3); pstSendTlv-\u0026gt;aucVersionList[19] = 0x01; } //此处省略gOamCtrlCode == 2~6的处理代码 else if (gOamCtrlCode == 7) { vosMemCpy(\u0026amp;(pstSendTlv-\u0026gt;aucVersionList), ctc_oui, 3); pstSendTlv-\u0026gt;aucVersionList[3] = 0x20; vosMemCpy(\u0026amp;(pstSendTlv-\u0026gt;aucVersionList[4]), ctc_oui, 3); pstSendTlv-\u0026gt;aucVersionList[7] = 0x13; vosMemCpy(\u0026amp;(pstSendTlv-\u0026gt;aucVersionList[8]), ctc_oui, 3); pstSendTlv-\u0026gt;aucVersionList[11] = 0x01; } 以下示出C语言中更简洁的实现方式(基于二维数组)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /********************************************************************** * 版本控制字数组定义 * gOamCtrlCode: Bitmap控制字。Bit-X为0时上报对应版本，Bit-X为1时屏蔽对应版本。 * CTRL_VERS_NUM: 可控版本个数。 * CTRL_CODE_NUM: 控制字个数。与CTRL_VERS_NUM有关。 * gOamVerCtrlMap: 版本控制字数组。行对应控制字，列对应可控版本。 元素值为0时不上报对应版本，元素值非0时上报该元素值。 * Note: 该数组旨在实现“数据与控制隔离”。后续若要新增可控版本，只需修改 -- CTRL_VERS_NUM -- gOamVerCtrlMap新增行(控制字) -- gOamVerCtrlMap新增列(可控版本) **********************************************************************/ #define CTRL_VERS_NUM 3 #define CTRL_CODE_NUM (1\u0026lt;\u0026lt;CTRL_VERS_NUM) u8_t gOamVerCtrlMap[CTRL_CODE_NUM][CTRL_VERS_NUM] = { /* Ver21 Ver30 VerAA */ {0x21, 0x30, 0xaa}, /*gOamCtrlCode = 0*/ {0x21, 0x30, 0 }, /*gOamCtrlCode = 1*/ {0x21, 0, 0xaa}, /*gOamCtrlCode = 2*/ {0x21, 0, 0 }, /*gOamCtrlCode = 3*/ { 0, 0x30, 0xaa}, /*gOamCtrlCode = 4*/ { 0, 0x30, 0 }, /*gOamCtrlCode = 5*/ { 0, 0, 0xaa}, /*gOamCtrlCode = 6*/ { 0, 0, 0 } /*gOamCtrlCode = 7*/ }; #define INFO_TYPE_VERS_LEN 7 /* InfoType + Length + OUI + ExtSupport + Version */ u8_t verIdx = 0; u8_t index = 0; for(verIdx = 0; verIdx \u0026lt; CTRL_VERS_NUM; verIdx++) { if(gOamVerCtrlMap[gOamCtrlCode][verIdx] != 0) { vosMemCpy(\u0026amp;pstSendTlv-\u0026gt;aucVersionList[index], ctc_oui, 3); index += 3; pstSendTlv-\u0026gt;aucVersionList[index++] = gOamVerCtrlMap[gOamCtrlCode][verIdx]; } } vosMemCpy(\u0026amp;pstSendTlv-\u0026gt;aucVersionList[index], ctc_oui, 3); index += 3; pstSendTlv-\u0026gt;aucVersionList[index++] = 0x20; vosMemCpy(\u0026amp;pstSendTlv-\u0026gt;aucVersionList[index], ctc_oui, 3); index += 3; pstSendTlv-\u0026gt;aucVersionList[index++] = 0x13; vosMemCpy(\u0026amp;pstSendTlv-\u0026gt;aucVersionList[index], ctc_oui, 3); index += 3; pstSendTlv-\u0026gt;aucVersionList[index++] = 0x01; pstSendTlv-\u0026gt;ucLength = INFO_TYPE_VERS_LEN + index; 消息处理 问题：终端输入不同的打印命令，调用相应的打印函数，以控制不同级别的打印。\n这是一段消息(事件)驱动程序。本模块接收其他模块(如串口驱动)发送的消息，根据消息中的打印级别字符串和开关模式，调用不同函数进行处理。常见的实现方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 void logall(void) { g_log_control[0] = 0xFFFFFFFF; } void noanylog(void) { g_log_control[0] = 0; } void logOam(void) { g_log_control[0] |= (0x01 \u0026lt;\u0026lt; FUNCTION_Oam); } void nologOam(void) { g_log_control[0] \u0026amp;= ~(0x01 \u0026lt;\u0026lt; FUNCTION_Oam); } //... ... void logExec(char *name, INT8U enable) { CtcOamLog(FUNCTION_Oam,\u0026#34;log %s %d\\n\u0026#34;,name,enable); if (enable == 1) /*log*/ { if (strcasecmp(name,\u0026#34;all\u0026#34;) == 0) { /*字符串比较，不区分大小写*/ logall(); } else if (strcasecmp(name,\u0026#34;oam\u0026#34;) == 0) { logOam(); } else if (strcasecmp(name,\u0026#34;pon\u0026#34;) == 0) { logPon(); //... ... } else if (strcasecmp(name,\u0026#34;version\u0026#34;) == 0) { logVersion(); } else if (enable == 0) /*nolog*/ { if (strcasecmp(name,\u0026#34;all\u0026#34;) == 0) { noanylog(); } else if (strcasecmp(name,\u0026#34;oam\u0026#34;) == 0) { nologOam(); } else if (strcasecmp(name,\u0026#34;pon\u0026#34;) == 0) { nologPon(); //... ... } else if (strcasecmp(name,\u0026#34;version\u0026#34;) == 0) { nologVersion(); } else { printf(\u0026#34;bad log para\\n\u0026#34;); } } 以下示出C语言中更简洁的实现方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 typedef struct{ OAM_LOG_OFF = (INT8U)0, OAM_LOG_ON = (INT8U)1 }E_OAM_LOG_MODE; typedef FUNC_STATUS (*OamLogHandler)(VOID); typedef struct{ CHAR *pszLogCls; /* 打印级别 */ E_OAM_LOG_MODE eLogMode; /* 打印模式 */ OamLogHandler fnLogHandler; /* 打印函数 */ }T_OAM_LOG_MAP; T_OAM_LOG_MAP gOamLogMap[] = { {\u0026#34;all\u0026#34;, OAM_LOG_OFF, noanylog}, {\u0026#34;oam\u0026#34;, OAM_LOG_OFF, nologOam}, //... ... {\u0026#34;version\u0026#34;, OAM_LOG_OFF, nologVersion}, {\u0026#34;all\u0026#34;, OAM_LOG_ON, logall}, {\u0026#34;oam\u0026#34;, OAM_LOG_ON, logOam}, //... ... {\u0026#34;version\u0026#34;, OAM_LOG_ON, logVersion} }; INT32U gOamLogMapNum = sizeof(gOamLogMap) / sizeof(T_OAM_LOG_MAP); VOID logExec(CHAR *pszName, INT8U ucSwitch) { INT8U ucIdx = 0; for(; ucIdx \u0026lt; gOamLogMapNum; ucIdx++) { if((ucSwitch == gOamLogMap[ucIdx].eLogMode) \u0026amp;\u0026amp; (!strcasecmp(pszName, gOamLogMap[ucIdx].pszLogCls)); { gOamLogMap[ucIdx].fnLogHandler(); return; } } if(ucIdx == gOamLogMapNum) { printf(\u0026#34;Unknown LogClass(%s) or LogMode(%d)!\\n\u0026#34;, pszName, ucSwitch); return; } } 这种表驱动消息处理实现的优点如下：\n增强可读性，消息如何处理从表中一目了然。 增强可扩展性。更容易修改，要增加新的消息，只要修改数据即可，不需要修改流程。 降低复杂度。通过把程序逻辑的复杂度转移到人类更容易处理的数据中来，从而达到控制复杂度的目标。 主干清晰，代码重用。 若各索引为顺序枚举值，则建立多维数组(每维对应一个索引)，根据下标直接定位到处理函数，效率会更高。 注意，考虑到本节实例中logOam/logPon或nologOam/nologPon等函数本质上是基于打印级别的比特操作，因此可进一步简化。以下例举其相似实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 /* 日志控制类型定义 */ typedef enum { LOG_NORM = 0, /* 未分类日志，可用于通用日志 */ LOG_FRM, /* Frame，OMCI帧日志 */ LOG_PON, /* Pon，光链路相关日志 */ LOG_ETH, /* Ethernet，Layer2以太网日志 */ LOG_NET, /* Internet，Layer3网络日志 */ LOG_MULT, /* Multicast，组播日志 */ LOG_QOS, /* QOS，流量日志 */ LOG_CES, /* Ces，TDM电路仿真日志 */ LOG_VOIP, /* Voip，语音日志 */ LOG_ALM, /* Alarm，告警日志 */ LOG_PERF, /* Performance，性能统计日志 */ LOG_VER, /* Version，软件升级日志 */ LOG_XDSL, /* xDsl日志 */ LOG_DB, /* 数据库操作日志 */ //新日志类型在此处扩展，共支持32种日志类型 LOG_ALL = UINT_MAX /* 所有日志类型 */ }E_LOG_TYPE; /***************************************************************************** * 变量名称：gOmciLogCtrl * 作用描述：OMCI日志控制字，BitMap格式(比特编号从LSB至MSB依次为Bit0-\u0026gt;BitN)。 * Bit0~N分别对应E_LOG_TYPE各枚举值(除LOG_ALL外)。 * BitX为0时关闭日志类型对应的日志功能，BitX为1时则予以打开。 * 变量范围：该变量为四字节整型静态全局变量，即支持32种日志类型。 * 访问说明：通过GetOmciLogCtrl/SetOmciLogCtrl/OmciLogCtrl函数访问/设置控制字。 *****************************************************************************/ static INT32U gOmciLogCtrl = 0; //日志类型字符串数组，下标为各字符串所对应的日志类型枚举值。 static const INT8U* paLogTypeName[] = { \u0026#34;Norm\u0026#34;, \u0026#34;Frame\u0026#34;, \u0026#34;Pon\u0026#34;, \u0026#34;Ethernet\u0026#34;, \u0026#34;Internet\u0026#34;, \u0026#34;Multicast\u0026#34;, \u0026#34;Qos\u0026#34;, \u0026#34;Ces\u0026#34;, \u0026#34;Voip\u0026#34;, \u0026#34;Alarm\u0026#34;, \u0026#34;Performance\u0026#34;, \u0026#34;Version\u0026#34;, \u0026#34;Xdsl\u0026#34;, \u0026#34;Db\u0026#34; }; static const INT8U ucLogTypeNameNum = sizeof(paLogTypeName) / sizeof(paLogTypeName[0]); static VOID SetGlobalLogCtrl(E_LOG_TYPE eLogType, INT8U ucLogSwitch) { if(LOG_ON == ucLogSwitch) gOmciLogCtrl = LOG_ALL; else gOmciLogCtrl = 0; } static VOID SetSpecificLogCtrl(E_LOG_TYPE eLogType, INT8U ucLogSwitch) { if(LOG_ON == ucLogSwitch) SET_BIT(gOmciLogCtrl, eLogType); else CLR_BIT(gOmciLogCtrl, eLogType); } VOID OmciLogCtrl(CHAR *pszLogType, INT8U ucLogSwitch) { if(0 == strncasecmp(pszLogType, \u0026#34;All\u0026#34;, LOG_TYPE_CMP_LEN)) { SetGlobalLogCtrl(LOG_ALL, ucLogSwitch); return; } INT8U ucIdx = 0; for(ucIdx = 0; ucIdx \u0026lt; ucLogTypeNameNum; ucIdx++) { if(0 == strncasecmp(pszLogType, paLogTypeName[ucIdx], LOG_TYPE_CMP_LEN)) { SetSpecificLogCtrl(ucIdx, ucLogSwitch); printf(\u0026#34;LogType: %s, LogSwitch: %s\\n\u0026#34;, paLogTypeName[ucIdx], (1==ucLogSwitch)?\u0026#34;On\u0026#34;:\u0026#34;Off\u0026#34;); return; } } OmciLogHelp(); } 掩码表 参见采用掩码方式简化产品国家地区支持能力的表示 - clover_toeic - 博客园一文。该例实现中用到消息、掩码、函数指针等概念。\n编程思想 表驱动法属于数据驱动编程的一种，其核心思想在《Unix编程艺术》和《代码大全2》中均有阐述。两者均认为人类阅读复杂数据结构远比复杂的控制流程容易，即相对于程序逻辑，人类更擅长于处理数据。本节将由Unix设计原则中的“分离原则”和“表示原则”展开。\n分离原则：策略同机制分离，接口同引擎分离\n机制即提供的功能；策略即如何使用功能。策略的变化要远远快于机制的变化。将两者分离，可以使机制相对保持稳定，而同时支持策略的变化。代码大全中提到“隔离变化”的概念，以及设计模式中提到的将易变化的部分和不易变化的部分分离也是这个思路。\n表示原则：把知识叠入数据以求逻辑质朴而健壮\n即使最简单的程序逻辑让人类来验证也很困难，但就算是很复杂的数据，对人类来说，还是相对容易推导和建模的。数据比编程逻辑更容易驾驭。在复杂数据和复杂代码中选择，宁可选择前者。更进一步，在设计中，应该主动将代码的复杂度转移到数据中去(参考“版本控制”)。\n在“消息处理”示例中，每个消息处理的逻辑不变，但消息可能是变化的。将容易变化的消息和不容易变化的查找逻辑分离，即“隔离变化”。此外，该例也体现消息内部的处理逻辑(机制)和不同的消息处理(策略)分离。\n数据驱动编程可以应用于：\n函数级设计，如本文示例。 程序级设计，如用表驱动法实现状态机。 系统级设计，如DSL。 注意，数据驱动编程不是全新的编程模型，只是一种设计思路，在Unix/Linux开源社区应用很多。数据驱动编程中，数据不但表示某个对象的状态，实际上还定义程序的流程，这点不同于面向对象设计中的数据“封装”。\n附录 网友观点 (以下观点摘自博客园网友“七心葵”的回帖，非常具有启发性。)\nBooch的《面向对象分析与设计》一书中，提到所有的程序设计语言大概有3个源流：结构化编程、面向对象编程、数据驱动编程。我认为数据驱动编程的本质是“参数化抽象”的思想，不同于OO的“规范化抽象”的思想。\n数据驱动编程在网络游戏开发过程中很常用，但是少有人专门提到这个词。数据驱动编程有很多名字：元编程，解释器/虚拟机，LOP/微语言/DSL等。包括声明式编程、标记语言、甚至所见即所得的拖放控件，都算是数据驱动编程的一种吧。\n数据驱动编程可以帮助处理复杂性，和结构化编程、OO 均可相容。(正交的角度)将变和不变的部分分离，策略和机制分离，由此联想到的还有：(数据和代码的分离，微语言和解释器的分离，被生成代码和代码生成器的分离)；更近一步：(微内核插件式体系结构)。\n元编程应该说是更加泛化的数据驱动编程，元编程不是新加入一个间接层，而是退居一步，使得当前的层变成一个间接层。元编程分为静态元编程(编译时)和动态元编程(运行时)，静态元编程本质上是一种代码生成技术或者编译器技术；动态元编程一般通过解释器(或虚拟机)加以实现。\n数据驱动编程当然也不应该说是“反抽象的”，但的确与“OO抽象”的思维方式是迥然不同，泾渭分明的，如TAOUP一书中所述：“在Unix的模块化传统和围绕OO语言发展起来的使用模式之间，存在着紧张的对立关系”应该说数据驱动编程的思路与结构化编程和OO是正交的，更类似一种“跳出三界外，不在五行中”的做法。\n编程和人的关系 人类心智的限制，一切的背后都有人的因素作为依据：\n人同时关注的信息数量：7+-2 (所以要分模块)\n人接收一组新信息的平均时间5s(所以要简单，系统总的模块数不要太多)\n人思维的直观性(人的视觉能力和模糊思维能力)，这意味这两点：\n“直”——更善于思考自己能直接接触把玩的东西；(所以要“浅平透”、使用具象的设计，要尽量代码中只有顺直的流程); “观”——更善于观图而不是推算逻辑；(所以要表驱动法，数据驱动编程，要UML，要可视化编程——当然MDA是太理想化了) 人不能持续集中注意力(人在一定的代码行数中产生的bug数量的比例是一定的，所以语言有具有表现力，要体现表达的经济性)，所以要机制与策略分离，要数据和代码分离(数据驱动编程)，要微语言，要DSL，要LOP……\n人是有创造欲，有现实利益心的(只要偶可能总是不够遵从规范，或想创造规范谋利——只要成本能承受，在硬件领域就不行)\n另外，开一个有意思的玩笑，Unix编程艺术艺术的英文缩写为TAOUP，我觉得可以理解为UP之TAO——向上抛出之道——将复杂的易变的逻辑作为数据或更高层代码抛给上层！\n函数指针 “消息处理”一节示例中的函数指针有点插件结构的味道。可对这些插件进行方便替换，新增，删除，从而改变程序的行为。而这种改变，对事件处理函数的查找又是隔离的(隔离变化)。\n函数指针非常有用，但使用时需注意其缺陷：无法检查参数(parameter)和返回值(return value)的类型。因为函数已经退化成指针，而指针不携带这些类型信息。缺少类型检查，当参数或返回值不一致时，可能会造成严重的错误。\n例如，定义三个函数，分别具有两个参数：\n1 2 3 int max(int x, int y) { return x \u0026gt; y ? x : y; } int min(int x, int y) { return x \u0026lt; y ? x: y; } int add(int x, int y) { return x + y; } 而处理函数却定义为：\n1 int process(int x, int y, int (*f)()) { return (*f)(x, y); } 其中，第三个参数是一个没有参数且返回int型变量的函数指针。但后面却用 process(a,b,max)的方式进行调用，max带有两个参数。若编译器未检查出错误，而又不小心将 return (*f)(x,y);写成 return (*f)(x);，那么后果可能很严重。\n因此在C语言中使用函数指针时，一定要小心类型陷阱。\n注：夹带一些私货，最近上下班会用耳机后台听tinyfool的一些视频，下面这个是关于学习曲线和规律的，启发比较大。如果要成为一个高手，需要在某个领域有一个合理的学习曲线（视频中所说的乐学者的学习曲线），认真练习和总结，持续学习，总会有所小成。因为这个讲座，最近开始阅读之前买了一直没看的《思考，快与慢》和《异类》这两本书，等读完了写个读书笔记。视频见下方\n","date":"2021-01-22T08:07:14+08:00","image":"https://pic.imgdb.cn/item/600a17e53ffa7d37b3da9d49.jpg","permalink":"https://blog.bugxch.top/p/%E8%BD%AC%E8%BD%BD%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B3%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/","title":"[转载]表驱动法代码实践"},{"content":"每个人的一生由记忆组成，但是记忆会随着时间模糊甚至消逝，幸好我们有相机，回望这一年，在人生的长河里给它打个鲜亮的标签。\n看到Question2020 - 笨方法学写作的这篇文章，有感而发，我也写一篇2020的年终总结。文章里面写下的答案都是凭第一感觉，每个人的记忆都会有偏差，但是在2021年初的这个当下它们是我此时脑中真实的反应。\n问题清单 在过去的一年里，你的什么观念发生了改变？ 以可信考试为例，有四点感触比较深。\n第一，如果想要在某个技能上有所突破，必须以咬定青山不放松的毅力持续投入有效的时间和精力，这意味着为了将技能磨练到足够高的水平，必须有足量有效的投入，甚至在必要的时候放弃休息娱乐的时间。比如因为公司的可信考试，我投入大量时间刷leetcode题目，从之前不知道c++的stl为何物，到现在也能熟练完成中等题目，甚至有勇气参加周赛挑战自己，靠的是8月份以来连续3个月的持续不断的刷题。下图就是今年的力扣的年度总结，当前leetcode的排名是全球27000名左右，希望今年还能更进一层，进入到5000以内吧。\n第二，工作之后的学习与学生时代不同，白天大部分时间用于完成日常的工作，而且没有整块的时间预留给你做持续深入的学习，但是又要面临持续提升工作技能的压力，以我学习C++的经历体会，最有效的方法是“以考促训，预留不被打扰的两小时”。如果要想有效精进，每天一定要预留不被打扰的整段时间用于练习，最好是早起后上班前或者下班后睡觉前，腾出时间好好学习和思考。\n第三，相信功不唐捐。持续的微小的积累达到一定的程度之后，往往会发生质变。技能训练尤为明显，借用《为学》的那一段\n天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。人之为学有难易乎？学之，则难者亦易矣；不学，则易者亦难矣。 不问年龄，不求结果，持续投入，水平必然会有提升。\n第四，做一件事情要达到极致，你做到level B是不够的，下定决心之后一定要做到level A。职场上只有惊艳到给别人留下深刻的印象，晋升的机会才会更青睐于你，平平凡凡虽然也没有错，但是如果真的笃定升职，全力以赴做到顶尖才是效率最高的方法。比如，如果要你想给人技术很厉害的印象，那么可信考试科目一做出来两道题是不够的，必须3道全部完成，只有这样的shock才能让别人在心里留下“编程NB”的印象。\n你的生活有什么大的变化吗？最大的幸福感来自哪里?\n应该说从2019年开始，有两件事情，养育小孩和拥有属于自己的房子。\n在有小孩之前，老婆觉得生小孩就是完成女性的生育任务，她的人生是金融界大佬、保代人和投行精英，哪成想生下果果的那一刻起就母性大发，现在恨不得辞职在家天天在家带娃，果果带给我们的快乐确实很多，小孩子天真烂漫，成长中的小趣事能解大人的多重烦忧啊。果果带给我很多惊奇时刻，现在回想起来有两件事情我印象深刻。今年过年之后他第一次回上海，那时候大概14个月大刚学着走路，不会说话，当时我、丫丫和妈妈都在卧室，妈妈问果果“哪个是妈妈呀？”，我以为他不知道，结果他指着丫丫，然后又问“哪个是爸爸？”，他又指着我，问“谁是奶奶？”，指着妈妈。那一刻我直接被shock了，虽然他不会说话，但是实际上已经可以分清楚爸爸、妈妈和奶奶了。\n5月份，14个月大的果果 今年6月底回湖北最多只能说两个词，9月份回到上海的时候就已经是成天指着这个问“这个是什么？”的好奇宝宝了，耳朵也异常灵敏，听到洗衣机运转的声音就会问，“什么东西响呀？”。我惊叹于人类小孩大脑发育的速度之快，短短几个月语言功能就发展到惊人的程度，有一次他自己在沙发上玩小汽车，玩弄了半天终于把车门打开了，顺口说出“终于打开了”，“终于”这个词语之前没有人跟他提起过，就算是他无意间听到了，也没人教他什么意思怎么用，他正确无误得把这个词语用得恰到好处，我和丫丫、妈妈觉得又可爱又惊讶。\n9月份，在家乐福，三代同框 我小时候因为照片很少，不能知道自己小时候的样子，非常遗憾。我现在随手会给果果拍照片或者录视频，他不会有第2个2岁、3岁和5岁，人生就是一把开弓离弦的箭，不断奔向时间的前方，他长大后回看这些曾经的照片视频，应该是很有意思的一件事情。初步计划会在我的公众号给他开一个专栏，就叫果果成长记系列，不定期更新他的照片和视频，将来就是给他最好的礼物之一。打个广告，请扫描文末的二维码关注我的公众号。\n买房子之后最大的幸福感来自于可以敞开钱包购置自己想买的那些大件商品，比如一个好床垫，一个好书桌，一台好电视。\n5月份，逛小区 我们在3月份签订了购房居间合同，按照正常的流程应该在贷款下来之后就可以交接入住了，但是房东由于坐月子所以延迟两个月交房，中间我会突然兴起去看小区，经常想着入住之后的样子，幸好房东近两年刚装修完，而且装修风格简洁明快，风格不错，有自己的小窝感觉还是很幸福的。交接之后，我们去宜家挑了书桌、床垫和餐桌，购置了新冰箱，双十一换了新燃气热水器，房子虽小，好好收拾了下书房，不过当下住着还是蛮舒服的。 9月份，书房刚收拾好时的样子 你有哪些有意思的发现？比如公众号，综艺节目或者一本书？\n在之前我有一个习惯，发现有意思的网站，都会放在我博客的杂记的页面，2018年收集了很多，但是后来博客迁来迁去丢失了，现在又在慢慢攒。当前我时常浏览的博客就是下面几个，\n产品沉思录 · Product Thinking，2020年发现的比较好的\u0026gt; 产品的网站 LoveIt，当前网站的主题介绍文章，可以参考文章插入图片、视频和音乐 ShareTechnote，一个韩国高级工程师搭建的专业知识共享网站 酷壳 – CoolShell.cn，左耳朵耗子的官方博客，对我影响比较大的技术大佬 科学空间|Scientific Spaces，非常不错的后生，天文、数学、AI、竞赛，博文质量极高，在这么小的年龄以十年的尺度更新不辍，非常难得 阮一峰的网络日志，IT圈子中小有名气的大佬，比较喜欢他每周一推的科技爱好者周刊系列 推荐搞IT的同学关注。 另外，推荐腾讯视频的《十三邀》节目，当前最新一期是去年的五条人乐队，这些访谈采访比较随意，不通过制造噱头可以拉高收视率，率真自然，推荐观看。去年没怎么看书，依然推荐老六的《读库》系列，最近好像涨价了，不过品质一直没变。我最近有强烈的感受，现在我已经对之前大学时期的偏文学社科的书目不太感兴趣了，更多的将精力投入到职业技能的提升上，我去年C++的书籍买了一堆，计划今年攻克这些大部头，愚公移山，犹未为晚也。 今年完整看过极力推荐的两部电视剧都改编自紫金陈的小说，隐秘的角落 (豆瓣)和沉默的真相 (豆瓣)，第二部豆瓣给出了9.2的高分，国产电视剧能到8.0以上就值得花时间看了，第二部我是在国庆的客厅沙发上几乎通宵追完的，为此还买了一个月的爱奇艺会员，确实值得。不过今年有一部好剧烂尾了，改编自孙皓晖的《大秦帝国》的终章《大秦赋 》，情节冗长拖沓，剧本被资方改得七零八碎，追了大概20集弃剧了，不建议入坑。 你买到了什么好东西，可以推荐给大家吗？\n今年最大支出是房子，这个就不多谈了，我在设备更新上花钱比较多，年中给我的整体升级了我的小黑硬件配置\n500大洋的三星（SAMSUNG）500GB SSD固态硬盘 SATA3.0接口 860 EVO（MZ-76E500B）把原来的机械硬盘换到固态硬盘 200大洋将当前的内存从4G升级到16G，三星SAMSUNG内存条4g8g16g32g ddr4 ddr3l 仅仅700大洋，之前的电脑卡死现象改善明显，开始时间由原来的1分钟降到10秒钟，打开大型文档或者多任务并行也不卡了，电脑体验的大幅改善肉眼可见，幸福感爆棚，建议大家也早点升级自己的硬件装备，早买早享受。 老婆将自己原来的T460电脑给了岳父，我转手4000大洋在公司内购了一台华为的2019 MateBook 14，内存小了点（8G），512G的固态硬盘，对于老婆这种重文档处理的情景用起来也足够，打开文档嗖嗖快。 我现在在用公司内测机的Mate 30 Pro，之前一直用iphone SE，今年上半年还曾动过买iphone SE 2的念头，不过现在完全喜欢上手上的这部手机了，华为手机最大优点是续航，但是别的方便做的也不错，很结实耐用，真的是钢铁直男做出来的手机，如果内测机折价卖给我，那肯定就这部了。 1600大洋，8月份手痒买了《极客时间》的算法训练营课程，现在想来稍微有点贵，因为他视频的课程在3个月之后是要失效的，不能永久保存，上这门课最大的收获是养成了正确的算法练习方法，这个可以再单独写一篇感想。 剩下的大件就是购置新家的家具，零零碎碎加上电器购置下来也有1w大洋左右了，主要选宜家，这里推荐宜家，质量和售后有保证，9月份买的床垫短了，我在12月份退掉买了个新的，过程有点波折，但是总体感受还可以。 在消费上，在满足自己需求的条件下，我坚持下面两个原则， 不看贵贱，买价格和价值最匹配的，有可能这个东西比较贵，但是如果他贵的有道理，那就值得它的价格； 对于长期需要使用的商品，在可承受的范围之内，我宁可买个贵而且好用的，也不会将就买便宜的，比如床垫，冰箱，键盘。 你的养成了什么好习惯或者坏习惯？\n最大的好习惯包括坚持刷题，勤耕不辍，题目做不出来茶饭不思。 坏习惯包括，\n喜欢躺在床上看手机，这个既对颈椎不好而且晚上看久了也影响第二天工作的精力，必须改； 没有坚持健身，今年体检就有脂肪肝了，问题比往年要多一些，今年也要改善，老婆买了划船机也要定期用起来。 之前使用随手记记账的习惯也丢了，去年因为买房所以花销肯定比较大，今年从元旦开始重新记账。 你最大的变化是什么？来年你期待有什么变化？\n相信努力的效果，在强手如林的我司，尤其是我们团队，相信自己能精进技能而且可以找到自己的定位。来年期待可以花更多精力在育儿上，果果慢慢大了，到了狗都嫌的2岁了，现在性格有些胆小，虽然不知道什么原因，但是我发现只要我陪伴多一点他就快乐胆大些。多读些育儿书籍，多与果果互动。还有一个，加强锻炼，已经到了不投入时间健身疾病就会找上门来的年龄了，以长远计，健康的体魄是迎接挑战享受日后人生的保障那~\n年度照片 下面是我的年度照片，每个月挑选1到2张有代表性的意思一下（右键 -\u0026gt; 在新标签页中打开图片可以看到高清大图，博客不知道为什么不能显示最大的清晰度），\n1月下旬，因为新冠爆发，我和丫丫只能在上海过年，家乐福购物归来 2月份，work at home，自制办公桌，后来不小心把显示器掉下来摔坏右上角 2月份，疫情期间在家坚持学习的易老师 2月份，第一个上班日，公司严正以待 2月份，同上，连按压取水都要用纸巾衬着 3月份，与易老师去高行看房，拍照留念小发卡 4月份，老树发新芽的博兴路 5月份，不记得在哪里拍的了 5月份，一家人逛滨江大道 5月份，有起床气的某宝宝 5月份，有了自己的房子 6月份，不肯睡觉喜欢玩妈妈化妆品的某宝宝 7月份，疫情期间装修停滞的西西弗书店金桥国际店开了 8月份，和易老师骑行黄浦滨江，美哉 8月份，易老师骑行黄浦滨江的曼妙身影 8月份，搬离最后的出租屋，迁入新家 9月份，新家阳台所摄，很喜欢满眼的绿色，远处是上海中心大厦 9月份，和易老师到杨浦宜家购置新家具 10月份，爸爸第一次来上海，祖孙三代合影 12月份，初冬的博兴路 ","date":"2021-01-02T22:26:25+08:00","image":"https://cdn.pixabay.com/photo/2020/12/10/09/21/face-mask-5819709_960_720.jpg","permalink":"https://blog.bugxch.top/p/%E8%AF%B7%E5%9B%9E%E7%AD%942020/","title":"请回答2020"},{"content":"上周五考试没有过，其中专业级第二题是关于区间的问题，在leetcode上找到类似的题目，总结复习下。\n引子 先看这道题，1109. 航班预订统计，题目是这样的\n这里有n 个航班，它们分别从 1 到 n 进行编号。\n我们这儿有一份航班预订表，表中第 i 条预订记录 bookings[i] = [i, j, k] 意味着我们在从 i 到 j 的每个航班上预订了 k 个座位。\n请你返回一个长度为 n 的数组 answer，按航班编号顺序返回每个航班上预订的座位数。参考示例如下，\n1 2 输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5 输出：[10,55,45,25,25] 解题思路 将这道题的示例画一张表格表示一下，就是下面的结果\nbooking 1 2 3 4 5 1 10 10 0 0 0 2 0 20 20 0 0 3 0 25 25 25 25 total 10 55 45 25 25 常规思路就是以航班号为基本坐标，计算每一个航班增加的座位数，然后逐项汇总相加即可。\n设置初始结果vector\u0026lt;int\u0026gt; res(n, 0); 遍历bookings，每次取其中的航班的预定数，添加到res对应的数组中，比如第1个booking，那么res[0]+=10; res[1]+=10，依次类推，直到遍历截止。 上面的算法比较简单直观，但是可以分析发现，算法的复杂度有点高，两层遍历算法时间复杂度是$O(n^2)$，空间复杂度是$O(n)$不甚理想。\n有没有复杂度更简单的思路呢？这里有一个类比公交站的思路，可以将航班号码比作公交站牌，比如1号公交站，2号公交站，假定这些公交站是依次按顺序分布在一条直线公路上，第i个航班的飞机的预定数目就是公交车在第i个公交站发车时候的乘客数目（包括了上车和下车的乘客数）。\n举例说明，第1行表示，第1站交车上人数是10，说明公交车行驶到第1站时上车10人，到第2站时候车上的乘客仍然是10人，说明没有乘客上下车，到第3站时候车上乘客0人，说明此时有10人下车。如果使用长度为N的数组count表示每一站上下乘客的变化量(count[i] 表示第i + 1站上下车的乘客变化量），\n对于booking = [i,j,k]，\n表示在公交站第i站上车k人，count[i - 1] += k； 第i + 1站直到第j站都没有乘客上下车，count[i],...,count[j - 1]无操作； 在第j + 1站下车k人，所以count[j] -= k 为了方便起见，我们缩小问题的规模，以具体的数字代替抽象的代数字母，假如我们就只有3个公交站，取示例中的前2行，\n公交车刚开始上的人数是0，vector\u0026lt;int\u0026gt; count(4, 0)； 读取第1行，到达第1站，公交车上10人，说明上车10人，无人下车，count[0]+= 10，到达第2站公交车上依然是10人，说明也无人上车和下车，到达第3站，公交车上0人，说明10人下车，count[2] -= 10； 读取第2行，公交车到达第2站，公交车上20人，说明上车20人无人下车，count[1] += 20，第3站车上20人，说明无人下车，第4站车上0人，说明有20人下车, count[3]-=20。 遍历结束，得到count = {10, 20, -10，-20}，那么最后每个站点的乘客数就很清楚了，到达第1站前车上乘客0人，到达后上车10人，所以第1站发车前车上10人，第2站到站后上车20人，所以第2站发车前车上乘客10 + 20 = 30人，第3站到站后下车10人，所以发车前车上乘客 30 - 10 = 20人。意思搞清楚之后，代码就很好写了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 vector\u0026lt;int\u0026gt; corpFlightBookings(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; bookings, int n) { vector\u0026lt;int\u0026gt; res(n, 0); vector\u0026lt;int\u0026gt; counter(n + 1, 0); for (auto \u0026amp;booking : bookings) { int start = booking[0]; int end = booking[1]; // 记录每个booking的开始和结尾即可，中间的站点人数无变化 counter[start - 1] += booking[2]; // start站上车 counter[end] -= booking[2]; // end + 1站下车 } res[0] = counter[0]; for (int i = 1; i \u0026lt; n; i++) { res[i] = res[i - 1] + counter[i]; } return res; } 时间复杂度为$O(n)$。\n通用框架 「待补充」\n典型题目 「待补充」\nNo. 986 区间列表交集 题目的链接参考986. 区间列表的交集 - 力扣（LeetCode），\nNo. 452 引爆气球 题目链接参考452. 用最少数量的箭引爆气球 - 力扣（LeetCode），这道题目使用贪心法，将气球的坐标放在坐标轴上，然后从0开始从左到右逐气球扫描，查看是否有交集，图示如下。\n参考资料 「待补充」\n","date":"2020-08-16T22:31:31+08:00","image":"https://cdn.pixabay.com/photo/2013/07/18/20/26/sea-164989_960_720.jpg","permalink":"https://blog.bugxch.top/p/leetcode%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","title":"LeetCode区间问题总结"},{"content":"公司认证的leetcode题目中经常会用到sort函数，不是很熟悉，今天系统学习总结下。\n总述 下面是C++的stl中的排序的所有函数，这个系列的博客会逐一介绍，这次的博客先关注最常用的sort函数。\n函数名 用法 sort (first, last) 对容器或普通数组中 [first, last) 范围内的元素进行排序，默认进行升序排序。 stable_sort (first, last) 和 sort() 函数功能相似，不同之处在于，对于 [first, last) 范围内值相同的元素，该函数不会改变它们的相对位置。 partial_sort (first, middle, last) 从 [first,last) 范围内，筛选出 muddle-first 个最小的元素并排序存放在 [first，middle) 区间中。 partial_sort_copy (first, last, result_first, result_last) 从 [first, last) 范围内筛选出 result_last-result_first 个元素排序并存储到 [result_first, result_last) 指定的范围中。 is_sorted (first, last) 检测 [first, last) 范围内是否已经排好序，默认检测是否按升序排序。 is_sorted_until (first, last) 和 is_sorted() 函数功能类似，唯一的区别在于，如果 [first, last) 范围的元素没有排好序，则该函数会返回一个指向首个不遵循排序规则的元素的迭代器。 void nth_element (first, nth, last) 找到 [first, last) 范围内按照排序规则（默认按照升序排序）应该位于第 nth 个位置处的元素，并将其放置到此位置。同时使该位置左侧的所有元素都比其存放的元素小，该位置右侧的所有元素都比其存放的元素大。 sort函数 使用范围 C++ STL 标准库中的 sort() 函数，本质就是一个模板函数。正如表 1 中描述的，该函数专门用来对容器或普通数组中指定范围内的元素进行排序，排序规则默认以元素值的大小做升序排序，除此之外我们也可以选择标准库提供的其它排序规则（比如std::greater\u0026lt;T\u0026gt;降序排序规则），甚至还可以自定义排序规则。\n需要注意的是，sort() 函数受到底层实现方式的限制，它仅适用于普通数组和部分类型的容器。换句话说，只有普通数组和具备以下条件的容器，才能使用 sort() 函数：\n容器支持的迭代器类型必须为随机访问迭代器。这意味着，sort() 只对 array、vector、deque 这 3 个容器提供支持； 如果对容器中指定区域的元素做默认升序排序，则元素类型必须支持\u0026lt;小于运算符；同样，如果选用标准库提供的其它排序规则，元素类型也必须支持该规则底层实现所用的比较运算符； sort() 函数在实现排序时，需要交换容器中元素的存储位置。这种情况下，如果容器中存储的是自定义的类对象，则该类的内部必须提供移动构造函数和移动赋值运算符。 局限 sort函数不保证排序的稳定性，即如果被排序的序列中有多个相同值的元素，并不能保证排序之后他们的相对位置保持不变。\n使用方法 值得一提的是，sort() 函数位于\u0026lt;algorithm\u0026gt;头文件中，因此在使用该函数前，程序中应包含如下语句：\n1 #include \u0026lt;algorithm\u0026gt; sort() 函数有 2 种用法，其语法格式分别为：\n1 2 3 4 //对 [first, last) 区域内的元素做默认的升序排序 void sort (RandomAccessIterator first, RandomAccessIterator last); //按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序 void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp); 其中，first 和 last 都为随机访问迭代器，它们的组合 [first, last) 用来指定要排序的目标区域；另外在第 2 种格式中，comp 可以是 C++ STL 标准库提供的排序规则（比如 std::greater），也可以是自定义的排序规则。比如，如果需要做降序排序，那么可以使用std::less\u0026lt;T\u0026gt;，也可以自己写一个降序的函数。具体的用法如下所示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; // std::cout #include \u0026lt;algorithm\u0026gt; // std::sort #include \u0026lt;vector\u0026gt; // std::vector //以普通函数的方式实现自定义排序规则 bool mycomp(int i, int j) { return (i \u0026lt; j); } //以函数对象的方式实现自定义排序规则 class mycomp2 { public: bool operator() (int i, int j) { return (i \u0026lt; j); } }; int main() { std::vector\u0026lt;int\u0026gt; myvector{ 32, 71, 12, 45, 26, 80, 53, 33 }; //调用第一种语法格式，对 32、71、12、45 进行排序 std::sort(myvector.begin(), myvector.begin() + 4); //(12 32 45 71) 26 80 53 33 //调用第二种语法格式，利用STL标准库提供的其它比较规则（比如 greater\u0026lt;T\u0026gt;）进行排序 std::sort(myvector.begin(), myvector.begin() + 4, std::greater\u0026lt;int\u0026gt;()); //(71 45 32 12) 26 80 53 33 //调用第二种语法格式，通过自定义比较规则进行排序 std::sort(myvector.begin(), myvector.end(), mycomp2()); // 80 71 53 45 33 32 26 12 sort(myvector.begin() + 4, myvector.end(), mycomp); // 80 71 53 45 12 26 32 33 //输出 myvector 容器中的元素 for (std::vector\u0026lt;int\u0026gt;::iterator it = myvector.begin(); it != myvector.end(); ++it) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } return 0; } 再探自定义比较函数 一元谓词和二元谓词 sort的自定义比较函数在C++中成为谓词，在泛型编程中作为参数使用。按照接受参数的个数不同，谓词分为一元谓词和二元谓词两种。\n一元谓词，比如for_each中使用，因为该算法是顺序遍历容器中的每个元素，对每个元素进行操作，所以是一元谓词，如下面的代码片段\n1 2 3 4 5 6 vector\u0026lt;string\u0026gt; str = { \u0026#34;i\u0026#34;, \u0026#34;love\u0026#34;, \u0026#34;leetcode\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;love\u0026#34;, \u0026#34;coding\u0026#34; }; void printEle(string str) { cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } for_each(str.begin(), str.end(), printEle) // printEle是一元谓词 二元谓词，sort算法是对容器的两个元素进行比较，所以接受两个参数，比如上面的mycomp函数。\nlambda表达式与可调用对象 谓词就是一个可调用对象(callable object)，在C++中可调用对象包括4种类型：函数、函数指针、重载函数调用符的类（可以像函数一样使用的类）以及lambda表达式。其实在上面的代码片段中，已经在sort算法中使用过函数以及重载函数调用符的类。此处重点介绍一下lambda表达式。lambda表达式的介绍很多，此处直接贴出来参考资料3中的总结表格\n从表格中可以看出捕获的类型，分为不捕获局部变量、按值捕获、按引用捕获，混合捕获这几种。参考std::sort参考手册中的代码，sort的用法如下所示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;array\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::array\u0026lt;int, 10\u0026gt; s = {5, 7, 4, 2, 8, 6, 1, 9, 0, 3}; // 用默认的 operator\u0026lt; 排序 std::sort(s.begin(), s.end()); for (auto a : s) {〔方案選單〕 std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 用标准库比较函数对象排序 std::sort(s.begin(), s.end(), std::greater\u0026lt;int\u0026gt;()); for (auto a : s) { std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 用自定义函数对象排序 struct { bool operator()(int a, int b) const { return a \u0026lt; b; } } customLess; std::sort(s.begin(), s.end(), customLess); for (auto a : s) { std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 用 lambda 表达式排序 std::sort(s.begin(), s.end(), [](int a, int b) { return b \u0026lt; a; }); for (auto a : s) { std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 输出\n1 2 3 4 0 1 2 3 4 5 6 7 8 9 9 8 7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7 8 9 9 8 7 6 5 4 3 2 1 0 表示了3种谓词，标准库、函数对象和lambda表达式。这里的二元谓词，告诉了sort，当比较其中两个元素的时候该如何处理两个元素的位置。\n1 2 3 4 5 6 struct { bool operator()(int a, int b) const { return a \u0026lt; b; } } customLess; 当上面的函数返回为true时候，那么将a排在b的前面，上面的代码种当a \u0026lt; b时结果为true，所以小的元素排在前面，下面通过做题来示例它的用法。\n具体题目 参考1366. 通过投票对团队排名 - 力扣（LeetCode），具体的代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public: Solution() = default; string rankTeams(vector\u0026lt;string\u0026gt;\u0026amp; votes) { unordered_map\u0026lt;char, vector\u0026lt;int\u0026gt;\u0026gt; ranks; for (auto\u0026amp; vote : votes[0]) { ranks[vote].resize(votes[0].size()); } for (auto\u0026amp; vote : votes) { for (int i = 0; i \u0026lt; vote.size(); i++) { ranks[vote[i]][i]++; } } using PCV = pair\u0026lt;char, vector\u0026lt;int\u0026gt;\u0026gt;; vector\u0026lt;PCV\u0026gt; ranking; for (auto iter = ranks.begin(); iter != ranks.end(); iter++) { ranking.push_back({ iter-\u0026gt;first, iter-\u0026gt;second }); } // lambda表达式 sort(ranking.begin(), ranking.end(), [](PCV\u0026amp; a, PCV\u0026amp; b) { int i = 0; while (i \u0026lt; a.second.size()) { if (a.second[i] != b.second[i]) { return a.second[i] \u0026gt; b.second[i]; } i++; } return a.first \u0026lt; b.first; }); string res; for (int i = 0; i \u0026lt; ranking.size(); i++) { res += ranking[i].first; } return res; } }; 以题目中的示例1分析题意\n第一名得票 第二名得票 第三名得票 A 5 0 2 B 0 2 3 C 0 3 0 有5个人投票，如果给ABC的3人，从第一名到第三名依次唱票，\n如果第一名决出胜者，那么该选手获得第一名，剩下的选手角逐第二名； 如果第二名决出胜者，那么该选手获得第一名，剩下的选手就是第三名。 如果参选人数超过3人，那么依此类推，直到所有名次所有人都占用为止。这里有一种特殊情况，如果有若干人在所有名次获得相同的选票，那么以人名的字母排序。比如，如果A和B都得了第一名，那么排序A在前，B在后。注意上面的26行~36行的代码。它表示从第一名到最后一名排序，\n如果两个选手的在第i个名次上票数相同，那么在第i个名次上不做任何操作（我们认为他们的名次是不分先后的），继续下一个名次i++的比较（第33行）； 如果两个选手在第i个名次上票数不同，那么以票数多者优先排序，退出循环，后面的名次不需要再比较了（第31行）； 如果在两个选手在所有的名次上票数均相同，那么最后按照人名排序（第35行） 这里的代码告诉了sort函数该如何对当前所有选手中的两个选手的名次进行排序，它会将其中的两两进行比较给出答案（如何两两比较，我们不用关心），从微观层面告诉sort函数的两个元素的操作方法，它就能将所有的选手按照这个方法排好序，这个就是lambda表达式的意义。\n参考资料 C++ sort()排序函数用法详解，c语言中文网的介绍 std::sort() in C++ STL - GeeksforGeeks，国外的网站介绍 C++ Primer 中文版中的10.3节 ","date":"2020-08-15T21:25:46+08:00","image":"https://pic.imgdb.cn/item/6002ed073ffa7d37b305c866.jpg","permalink":"https://blog.bugxch.top/p/c-%E4%B8%AD%E7%9A%84sort%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/","title":"C++中的sort函数详解"},{"content":"总结一下广度优先搜索的原理和用法。\n引子 先看这道题104. 二叉树的最大深度，题目中给出一个二叉树，求这个二叉树的最大深度。例子中给出下面的二叉树\n1 2 3 4 5 3 / \\ 9 20 / \\ 15 7 这个如何解决呢？肉眼可见，最大深度是3。\n构建二叉树 首先为了便于调试，需要构建一颗二叉树，题目中的给出的是二叉树的层序遍历的结果，我们用INT_MAX代替null，使用如下函数构造二叉树\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 void ConstructBinTree(vector\u0026lt;int\u0026gt; \u0026amp;nodes, TreeNode *root) { if (nodes.size() == 0 || nodes[0] == INT_MAX) { root = nullptr; return; } queue\u0026lt;TreeNode *\u0026gt; iq; int id = 0; root-\u0026gt;val = nodes[id++]; iq.emplace(root); while (!iq.empty() \u0026amp;\u0026amp; id \u0026lt; nodes.size()) { TreeNode *node = iq.front(); iq.pop(); // check vectors for left node if (nodes[id] != INT_MAX) { TreeNode *leftNode = new TreeNode; leftNode-\u0026gt;val = nodes[id]; node-\u0026gt;left = leftNode; iq.emplace(leftNode); } else { node-\u0026gt;left = nullptr; } id++; // add right node if (nodes[id] != INT_MAX) { TreeNode *rightNode = new TreeNode; rightNode-\u0026gt;val = nodes[id]; node-\u0026gt;right = rightNode; iq.emplace(rightNode); } else { node-\u0026gt;right = nullptr; } id++; } return; } 下面是中序遍历二叉树\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void ScanBinMiddle(TreeNode *tree) { if (tree == nullptr) { return; } // handle value cout \u0026lt;\u0026lt; tree-\u0026gt;val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; if (tree-\u0026gt;left) { ScanBinMiddle(tree-\u0026gt;left); } if (tree-\u0026gt;right) { ScanBinMiddle(tree-\u0026gt;right); } } 递归解法 二叉树的比较普遍的解法是使用递归，我们需要找出递归的关系式，然后用程序写出来。递归解决问题的思路包括下面两点\n描述变量 我们有一个关于目标变量的描述，在这个题目中目标变量是整棵树的最大深度，放弃整体的概念，假设你站在根节点往下看，会看到它有左右两个子树，每棵树又有自己的节点和深度。所以假定推导的变量是\nmaxdepth[node]表示以node为根节点的树的最大深度\n递归关系式 查看这个值和左右子树的关系是什么？3这个node的最大深度是9这个node最大深度和20这个node的最大深度的最大值 + 1，重新表述下就是下面的关系式maxD[node] = max(maxD[node-\u0026gt;left], maxD[node-\u0026gt;right]) + 1。\n终止条件 终止条件比较简单，在访问到null节点的时候返回0即可，因为以这个节点为根的树是不存在的，所以深度为0。于是有下面的代码\n1 2 3 4 5 6 7 8 9 int maxDepth(TreeNode* root) { // 终止条件 if (root == nullptr) { return 0; } // 关系式 return max(maxDepth(root-\u0026gt;left), maxDepth(root-\u0026gt;right)) + 1; } 广度优先搜索算法（BFS） 不使用递归，还有另一种解法，一层层观察整棵树，第一层1个节点，第二层2个节点，第三层2个节点。每一层的节点之间使用左右子树联系起来，所以根据第1层的节点可以访问第2层的节点，根据第2层的节点可以访问第3层的节点，所以可以这么做。记录整棵树最深的深度是maxdepth = 0，\n访问第一层的根节点，如果非空则maxdepth++，否则返回； 查看第一层的根节点是否有左右子树，有的话再分别访问左子树和右子树，maxdepth++； 循环步骤2，直到所有的节点都被访问到。 这里可以使用队列保存需要被访问的节点，如下图所示，分别在头和尾弹出和插入节点，\n结合上面的步骤，depth = 1，将root的根节点添加到队列结尾\n我们一次将一层的节点放入到队列中； 判断当前队列是否为空。 如果当前的队列不为空，那么将队列中的每个节点pop出来之后再考察这个节点的左右子树，如果有就将它们插入到队列的尾巴，depth++； 如果当前队列为空，return 所以有了下面的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int maxDepth(TreeNode* root) { // 如果为空，那么返回0 if (root == nullptr) { return 0; } queue\u0026lt;TreeNode *\u0026gt; qu; int depth = 0; // 添加根节点 qu.push(root); while (!qu.empty()) { int qz = qu.size(); for (int i = 0;i \u0026lt; qz;i++) { // 考察队列中的每个节点，是否有左子树和右子树 TreeNode * node = qu.front(); qu.pop(); // 如果有左右子节点，那么添加到队列中 if (node-\u0026gt;left) { qu.push(node-\u0026gt;left); } if (node-\u0026gt;right) { qu.push(node-\u0026gt;right); } } depth++; } return depth; } 下图是资料3中的图示过程，简单明了。\n数据结构 队列 使用队列保存每一层的节点，如下图所示，队列是先进先出的数据结构，包括如下的属性和方法\n队列头（front），表示队列最开始的元素； 队列尾（rear），表示队列最后加入的元素； 队列长度，当前的队列长度，就是rear - front + 1； 出队（pop），队列头弹出，队列长度-1，front++； 入队（push），队列尾添加元素，队列长度+1，rear++ STL中的queue C++的stl使用queue表示队列，常用的操作和属性如下表所示\nfront()：返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。 back()：返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。 push(const T\u0026amp; obj)：在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。 push(T\u0026amp;\u0026amp; obj)：以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。 pop()：删除 queue 中的第一个元素。 size()：返回 queue 中元素的个数。 empty()：如果 queue 中没有元素的话，返回 true。 emplace()：用传给 emplace() 的参数调用 T 的构造函数，在 queue 的尾部生成对象。 swap(queue\u0026lt;T\u0026gt; \u0026amp;other_q)：将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 典型的使用方法如下，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // CPP program to illustrate // Application of push() and pop() function #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; int main() { int c = 0; // Empty Queue queue\u0026lt;int\u0026gt; myqueue; myqueue.push(5); myqueue.push(13); myqueue.push(0); myqueue.push(9); myqueue.push(4); // queue becomes 5, 13, 0, 9, 4 // Counting number of elements in queue while (!myqueue.empty()) { myqueue.pop(); c++; } cout \u0026lt;\u0026lt; c; } 典型题目 二叉树的右视图 题目链接见199. 二叉树的右视图 - 力扣（LeetCode），如果有了上面题目的框架，这个题目其实很简单，既然每次遍历队列保存的这一层所有节点，而且节点的顺序是从左到右保存的，所以可以在每一层遍历的时候将队列的最后一个node加入到这个vector中，代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 vector\u0026lt;int\u0026gt; rightSideView(TreeNode* root) { vector\u0026lt;int\u0026gt; rlt; // empty rlt for empty tree if (root == nullptr) { return rlt; } queue\u0026lt;TreeNode *\u0026gt; qu; qu.push(root); while (!qu.empty()) { int qz = qu.size(); // add the last node in the current queue rlt.emplace_back(qu.back()-\u0026gt;val); // add nodes of next layer into the queue for (int i = 0;i \u0026lt; qz;i++) { TreeNode * node = qu.front(); qu.pop(); if (node-\u0026gt;left) { qu.push(node-\u0026gt;left); } if (node-\u0026gt;right) { qu.push(node-\u0026gt;right); } } } return rlt; } 二叉树中所有距离为 K 的结点 题目见863. 二叉树中所有距离为 K 的结点 - 力扣（LeetCode），这道题稍微有点复杂，观察给出的例子（如下图），与5的节点距离为2的节点除了4和7之外还有1，如果仅仅给出4和7是比较简单的，只要以5为根节点，记录depth = 1，套用引子中的程序，将depth = K + 1的所有的节点列出来即可。\n但是往上回溯比较难，换一个思路，我们遍历整个二叉树，\n记录每个节点的father节点，left节点和right节点，将二叉树变成图，表示A与这3个节点的任意一个都是连通的； 初始化目标节点的depth = 1，以该节点为圆心，遍历所有的节点，打印出来所有depth = K + 1的节点 第2步实际上是对BFS算法的升维，将二叉树转换为图，代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 vector\u0026lt;int\u0026gt; distanceK(TreeNode *root, TreeNode *target, int K) { unordered_map\u0026lt;TreeNode *, TreeNode *\u0026gt; umap; vector\u0026lt;int\u0026gt; rlt; if (root == nullptr || target == nullptr) { return rlt; } /************ PART 1 ************/ // find the father node of all the nodes in the tree queue\u0026lt;TreeNode *\u0026gt; qu; umap[root] = nullptr; qu.push(root); while (!qu.empty()) { int qz = qu.size(); for (int i = 0; i \u0026lt; qz; i++) { TreeNode *node = qu.front(); qu.pop(); if (node-\u0026gt;left) { qu.push(node-\u0026gt;left); // father node umap[node-\u0026gt;left] = node; } if (node-\u0026gt;right) { qu.push(node-\u0026gt;right); // father node umap[node-\u0026gt;right] = node; } } } /************ PART 2 ************/ // find the node with depth of K queue\u0026lt;TreeNode *\u0026gt; newQ; int depth = 0; unordered_map\u0026lt;TreeNode *, bool\u0026gt; usedmap; usedmap[target] = true; newQ.emplace(target); while (!newQ.empty() \u0026amp;\u0026amp; depth \u0026lt;= K) { int qz = newQ.size(); for (int i = 0; i \u0026lt; qz; i++) { TreeNode *node = newQ.front(); usedmap[node] = true; newQ.pop(); if (depth == K) { rlt.emplace_back(node-\u0026gt;val); continue; } if (node-\u0026gt;left \u0026amp;\u0026amp; (usedmap.count(node-\u0026gt;left) == 0)) { newQ.push(node-\u0026gt;left); } if (node-\u0026gt;right \u0026amp;\u0026amp; (usedmap.count(node-\u0026gt;right) == 0)) { newQ.push(node-\u0026gt;right); } if (umap[node] != nullptr \u0026amp;\u0026amp; (usedmap.count(umap[node]) == 0)) { newQ.push(umap[node]); } } depth++; } //BFS for final rlt return rlt; } 这个程序分为前后两大部分，\n第一部分遍历二叉树的每一个节点，记录每个节点的父节点，这里我们使用了哈希表来保存每个节点和它的父节点； 第二部分就是核心代码，以target为圆心，将二叉树当作图来遍历，如果这个node有左右节点或者父节点，则表示它跟其他的节点之间联通，则使用BFS算法访问整个图网络。这里尤其要注意，遍历图需要标记当前图中的节点是否被访问过，否则会被多次重复遍历而陷入到死循环中，在这个程序里面，使用usedmap来做这件事，其实也可以使用vector\u0026lt;TreeNode *\u0026gt;来记录。 为了方便调试，再补一个寻找target node的程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 TreeNode *FindTargetNode(TreeNode *root, int targetVal) { if (root == nullptr) { return nullptr; } queue\u0026lt;TreeNode *\u0026gt; qu; qu.push(root); while (!qu.empty()) { int qz = qu.size(); for (int i = 0; i \u0026lt; qz; i++) { TreeNode *node = qu.front(); qu.pop(); if (node-\u0026gt;val == targetVal) { return node; } if (node-\u0026gt;left) { qu.push(node-\u0026gt;left); } if (node-\u0026gt;right) { qu.push(node-\u0026gt;right); } } } } 颜色交替的最短路径 题目见1129. 颜色交替的最短路径 - 力扣（LeetCode），这道题难度要大一点，但是后面的方法仍然是BFS，代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 class Solution { enum color {RED, BLUE}; public: vector\u0026lt;int\u0026gt; shortestAlternatingPaths(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; red_edges, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; blue_edges) { // 由于存在自环或者平行边，所以定义哈希表保存每个结点对应的多条边并初始化 unordered_map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; redGraph; unordered_map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; blueGraph; for (auto\u0026amp; red : red_edges) redGraph[red[0]].push_back(red[1]); for (auto\u0026amp; blue : blue_edges) blueGraph[blue[0]].push_back(blue[1]); const int colorNum = 2; const int maxNode = 100; // 由于存在环和平行边，用数组 visit[x][y][color]=true 代表从节点x到节点y的且颜色为color的边被访问过，防止重复访问 // 第三维[2]有两维，第0维代表红色是否访问，第1维代表蓝色是否访问 // 所有的点初始化为0代表为被访问过 bool visited[maxNode][maxNode][colorNum]; memset(visited, false, sizeof(visited)); // step用于记录当前的步长，即从节点0到各节点的步长，从0逐渐+1自增 // res代表节点 0 到节点 X 的最短路径的长度，初始化为最大值 int step = 0; vector\u0026lt;int\u0026gt; res(n, INT_MAX); // 定义队列进行BFS，并进行初始化，pair\u0026lt;int, int\u0026gt;的意思是 \u0026lt;当前节点, 路径上颜色\u0026gt; // 队列初始化先进\u0026lt;0, 1\u0026gt;, 再进\u0026lt;0, 0\u0026gt;，即我们先访问蓝色，再访问红色。 queue\u0026lt;pair\u0026lt;int, color\u0026gt;\u0026gt; myQue; // \u0026lt;node, color\u0026gt; means start from node and select the edge with color myQue.push(make_pair(0, BLUE)); myQue.push(make_pair(0, RED)); while (!myQue.empty()) { int size = myQue.size(); ++step; for (int i = 0; i \u0026lt; size; i++) { // 队首元素出队列，得到其节点，以及颜色 int curNode = myQue.front().first; int curColor = myQue.front().second; myQue.pop(); //若当前已访问的为蓝色边，希望下一个节点的边是红色；反之亦然 if (curColor == BLUE) { // 遍历当前节点每一个相邻的节点，寻找相连的红色边 for (auto\u0026amp; nextNode : blueGraph[curNode]) { // 如果 curNode 和 nextNode 相连的红色边未被访问过，访问并加入队列 // 同时需要更新两点之间的最短路径 if (visited[curNode][nextNode][RED] == false) { res[nextNode] = min(res[nextNode], step); // make_pair\u0026lt;nextNode, 0\u0026gt; 的含义是标记当前访问的边为红色，下次应该访问蓝色的 myQue.push(make_pair(nextNode, RED)); visited[curNode][nextNode][RED] = true; } } } else if (curColor == RED) { // 遍历当前节点每一个相邻的节点，寻找相连的蓝色边 for (auto\u0026amp; nextNode : redGraph[curNode]) { // 如果 curNode 和 nextNode 相连的蓝色边未被访问过，访问并加入队列 // 同时需要更新两点之间的最短路径 if (visited[curNode][nextNode][BLUE] == false) { res[nextNode] = min(res[nextNode], step); // make_pair\u0026lt;nextNode, 1\u0026gt; 的含义是标记当前访问的边为蓝色，下次应该访问红色的 myQue.push(make_pair(nextNode, BLUE)); visited[curNode][nextNode][BLUE] = true; } } } } } // 根据题意，0 到自身的距离为0；在上述操作后，若 0 到其他节点距离仍为INT_MAX，说明不存在符合要求的路径，设置为-1； res[0] = 0; for (int i = 0; i \u0026lt; n; i++) if (res[i] == INT_MAX) res[i] = -1; return res; } }; 从代码可以看出，\n使用blueGraph/redGraph保存图中的节点，数据结构是哈希 + vector，哈希的键是节点，值是和该节点直接相连的其他节点； 使用visited三维数组标识节点是否被访问过的信息； 使用队列myQueue保存BFS中的node，这个队列中的元素是\u0026lt;node, expectColor\u0026gt;，即从node出发，从node起始的边的颜色，如果存在这样的边，那么将这条边的终点node和它的下一条不同颜色的边push进队列，循环往复直到所有的边都被访问到为止。 接雨水 II 题目见407. 接雨水 II - 力扣（LeetCode），「待补充」。\n参考资料 深度优先搜索 - Wikiwand，维基百科介绍 BFS 算法解题套路框架 - labuladong的算法小抄，非常直观富有启发性的介绍文章 【算法16】递归算法的时间复杂度终结篇 - python27 - 博客园，如何评价递归算法的复杂度 图文详解 DFS 和 BFS | 算法必看系列知识二十四-阿里云开发者社区，图解DFS和BFS的过程 ","date":"2020-08-08T11:24:24+08:00","permalink":"https://blog.bugxch.top/p/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E8%AF%A6%E8%A7%A3/","title":"广度优先搜索详解"},{"content":"今天主要刷leetcode的滑动窗口的题目，需要完成如下题目，本文主要记录解题思路和方法，以便加深理解记忆，答案到处都是，只有消化了才是自己的。\n引子 首先来看leetcode中No. 3的无重复字符的最长子串这个题目，参考题目链接，题目很简单\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n1 2 3 输入: \u0026#34;abcabcbb\u0026#34; 输出: 3 解释: 因为无重复字符的最长子串是 \u0026#34;abc\u0026#34;，所以其长度为 3。 拿到题目的第一反应就是暴力解法，\n先暴力穷举所有的子串$S_i = [S[left], S[right])$；\n判断这个子串，如果不含重复字符就记录子串长度$l_i$，此处判断是否有重复字串的时间复杂度是$O(n)$；\n找出所有记录的子串长度的最大值$max_i{l_i}$。 一段伪代码如下，\n1 2 3 4 5 6 7 8 9 int maxlen = -1; for (int left = 0; left \u0026lt; S.length(); left++) for (int right = left + 1; right \u0026lt; S.length(); right++) { if(window[left, right) contain 重复字符) continue; if(right - left \u0026gt; maxlen) { maxlen = right -left; } } return maxlen; 很明显，该方法的时间复杂度是$O(n^3)$，非常费时。这个算法的复杂度主要来自于第一步，仔细想想那个子串伪代码中的第3行有点问题，伪代码可以看作我们用一个窗口截取所有子串，left表示窗口的左边界（包含），right表示窗口的右边界（不包含），如果窗口中含有重复子串，那么不应该继续扩展右边界的，所以right不能一直向右扩展，此时应该向右移动左边界，缩小窗口的长度。以示例中给出的字符串为例，参考下面的示意图\n所以我们有一个更通用的实现框架。\n通用框架 维护一个滑动窗口，\n窗口的边界是$[left, right)$，刚开始窗口的长度为0，即left = right = 0； 维护一个哈希表table，用于记录窗口中的字符的统计情况，比如上面的图一中就table['a'] = 2, table['b'] = 1, table['c'] = 1； 窗口可扩展可收缩， 如果当前窗口中没有重复字符，则窗口扩展，right++，更新哈希表； 如果当前窗口中有重复字符，那么窗口收缩，left++，更新哈希表； 直到right超过需要遍历的字符串的边界为止。 需要注意，上面的扩展和收缩的时机，对于当前的这个程序，如何判断当前的窗口中是否有重复字符呢？一般的想法是遍历每个键的值，如果有大于1的值就认为有重复字符，而且是在窗口位置发生变化的时候触发遍历动作。其实，这里有一个小技巧，键值只有在向右扩展的时候才会增长，刚开始窗口是没有键的，或者即便有也只能是1，所以在窗口扩展的时候，只要去查看新加入的right位置的字符的键值是否超过1即可。通过以上分析，我们有了下面的新的伪代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int left = 0, right = 0; int maxlen = -1; while (right \u0026lt; s.size()) { // 增大窗口 window.add(s[right]); right++; if(window doesnot contain repeat charactor) { maxlen = max(maxlen, right - left); } while (window needs shrink) { // 缩小窗口 window.remove(s[left]); left++; } } return maxlen; 将上面的伪代码翻译成最后的c++代码，列示如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int lengthOfLongestSubstring(string s) { int maxlen = 0; unordered_map\u0026lt;char, int\u0026gt; window; int right = 0, left = 0; while (right \u0026lt; s.length()) { auto rch = s[right]; right++; window[rch]++; if (window[rch] \u0026lt;= 1) { maxlen = max(maxlen, right - left); } else { while (window[rch] \u0026gt; 1) { auto lch = s[left]; left++; window[lch]--; } } } return maxlen; } 类似题目 下面使用上面的框架解答一下其他的滑动窗口的类似题目\n最小覆盖子串 - 力扣（LeetCode） 题目见76. 最小覆盖子串 - 力扣（LeetCode）：给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。\n示例：\n输入: S = \u0026ldquo;ADOBECODEBANC\u0026rdquo;, T = \u0026ldquo;ABC\u0026rdquo; 输出: \u0026ldquo;BANC\u0026rdquo;\n也是同样的做法，但是需要搞清楚几个问题\n何时扩展窗口？ 如果窗口中没有将所有的T中的字符包含，那么向右扩展窗口。\n何时更新长度？ 扩展窗口之后，检查窗口的字符集合。如果当前窗口包含了所有的T中的字符，那么更新子串的起始位置id及长度。\n何时缩减窗口？ 更新长度之后，窗口的左端右移，缩减窗口。于是有了下面的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // No. 76 string minWindow(string s, string t) { int startId = 0; int rightId = 0; int minLen = s.length() + 1; int left = 0, right = 0; int matchCount = 0; // record the only need characters unordered_map\u0026lt;char, int\u0026gt; window; unordered_map\u0026lt;char, int\u0026gt; need; for (auto ch : t) need[ch]++; while (right \u0026lt; s.length()) { auto rch = s[right]; right++; if (need.count(rch)) { // expand window window[rch]++; if (window[rch] == need[rch]) { matchCount++; } } // shrink the window while (matchCount == need.size()) { if (right - left \u0026lt; minLen) { startId = left; rightId = right; minLen = right - left; } auto lch = s[left]; if (need.count(lch)) { window[lch]--; if (window[lch] \u0026lt; need[lch]) { matchCount--; } } left++; } } return rightId - startId \u0026gt; 0 ? s.substr(startId, rightId - startId) : \u0026#34;\u0026#34;; } 上面的写法中，需要注意几个问题\nwindow仅仅记录了[left, right)的子串中的出现在need窗口中的字符的情况，并没有对窗口中所有的字符都做统计，其实也没有必要做，因为我们并不关心其他的字符； minLen用来记录最短的子串长度，刚开始初始化为字符串的长度+1； 我们用matchCount标记匹配的字符的个数，如果匹配了一个字符就加一，否则减一，匹配的标准是该字符的出现次数在window中不少于在need中出现的次数。注意，这个参数在扩展窗口时增加，在缩减窗口时减少，增加或减少之后即刻与need比较判断。 424. 替换后的最长重复字符 题目见424. 替换后的最长重复字符 - 力扣（LeetCode），题目也比较简单，维护滑动窗口，每次在扩展窗口时候检查当前的窗口中的最多的字符的个数与替换的数量k的和是否大于等于窗口的长度？\n如果是，则更新窗口的长度，窗口继续扩展； 如果否，则缩减窗口的长度； 循环往复，直到窗口的右边界超过了字符串的长度。代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: int characterReplacement(string s, int k) { int maxLen = 0; int left = 0, right = 0; unordered_map\u0026lt;char, int\u0026gt; window; while (right \u0026lt; s.length()) { auto rch = s[right]; window[rch]++; right++; // find max count char int maxCount = -1; for (auto iter = window.begin(); iter != window.end(); iter++) { maxCount = max(maxCount, iter-\u0026gt;second); } if (maxCount + k \u0026gt;= right - left) { maxLen = max(right - left, maxLen); } else { auto lch = s[left]; window[lch]--; left++; } } return maxLen; } }; 1004. 最大连续1的个数 III 题目见1004. 最大连续1的个数 III - 力扣（LeetCode），与上一题目类似，直接看代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int longestOnes(vector\u0026lt;int\u0026gt;\u0026amp; A, int K) { int maxLen = 0; int left = 0, right = 0; unordered_map\u0026lt;int, int\u0026gt; window; while (right \u0026lt; A.size()) { auto rnum = A[right]; window[rnum]++; right++; if (window[1] + K \u0026gt;= right - left) { maxLen = max(right - left, maxLen); } else { auto lnum = A[left]; window[lnum]--; left++; } } return maxLen; } }; 可以看出这个代码与上一题目非常相似，通用框架都是默认扩展窗口，如果不满足某些条件再缩减窗口。\n992. K个不同整数的数组 题目见992. K 个不同整数的子数组 - 力扣（LeetCode），这个比上面的两道题要复杂点，两次使用双指针解决，基本思路是：\n维护像之前一样的滑动窗口，如果当前的窗口不满足条件，那么向右扩张； 如果窗口满足条件了，停止向右扩张，右边界不变，左边界向右移动（收缩窗口），开始计算满足条件的窗口数目。注意，这里的动作，在满足条件的窗口上再开一个滑动窗口，但是该窗口的右边界不变，不停右移左边界，遍历满足条件的总数； 如此这般往复循环，直到滑动窗口的右边缘到达字符串的右边界为止。 我第一次提交的代码如下，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 int subarraysWithKDistinct(vector\u0026lt;int\u0026gt;\u0026amp; A, int K) { int left = 0, right = 0; unordered_map\u0026lt;int, int\u0026gt; window; int count = 0; while (right \u0026lt; A.size()) { auto rnum = A[right]; window[rnum]++; right++; // 如果当前的窗口中超过了K个不同的整数，那么需要缩小左边缘（即窗口左移） while (window.size() \u0026gt; K) { auto lnum = A[left]; window[lnum]--; if (window[lnum] == 0) { window.erase(lnum); } left++; } // 当前的窗口有K个不同的整数，移动左边缘，遍历所有满足条件的窗口 if (window.size() == K) { unordered_map\u0026lt;int, int\u0026gt; subWindow(window); int tmpLeft = left; while (subWindow.size() == K) { count++; subWindow[A[tmpLeft]]--; if (subWindow[A[tmpLeft]] == 0) { subWindow.erase(A[tmpLeft]); } tmpLeft++; } } } return count; } 计算结果正确，但是超时了，仔细想想，其实不需要在创建一个subWindow窗口，可以复用原来的窗口，但是遍历完毕需要记得恢复，适当修改代码如下，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int subarraysWithKDistinct(vector\u0026lt;int\u0026gt;\u0026amp; A, int K) { int left = 0, right = 0; unordered_map\u0026lt;int, int\u0026gt; window; int count = 0; while (right \u0026lt; A.size()) { auto rnum = A[right]; window[rnum]++; right++; while (window.size() \u0026gt; K) { auto lnum = A[left]; window[lnum]--; if (window[lnum] == 0) { window.erase(lnum); } left++; } int tmpLeft = left; while (window.size() == K) { count++; window[A[tmpLeft]]--; if (window[A[tmpLeft]] == 0) { window.erase(A[tmpLeft]); } tmpLeft++; } // recover the window while (tmpLeft \u0026gt; left) { window[A[tmpLeft-1]]++; tmpLeft--; } } return count; } 数据结构 哈希表 上面的示例都用到了哈希表，又称为散列表，具体的定义可以参考哈希表。与一般的顺序访问的数组等数据结构不同，哈希表将查询的数据映射到表中的位置来记录，加快了查询的速度（类似于数组的下表和数组的值的映射关系）。一般而言，哈希表的查询，插入和删除的性能是$O(1)$。\nC++ STL 中的哈希表 C++在stl中使用unordered_map的数据结构保存哈希表，基本的用法如下所示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // C++ program to demonstrate functionality of unordered_map #include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_map\u0026gt; // using namespace std; int main() { // Declaring umap to be of \u0026lt;string, int\u0026gt; type // key will be of string type and mapped value will // be of double type unordered_map\u0026lt;string, int\u0026gt; umap; // inserting values by using [] operator umap[\u0026#34;GeeksforGeeks\u0026#34;] = 10; umap[\u0026#34;Practice\u0026#34;] = 20; umap[\u0026#34;Contribute\u0026#34;] = 30; // Traversing an unordered map for (auto x : umap) cout \u0026lt;\u0026lt; x.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x.second \u0026lt;\u0026lt; endl; } 创建一个哈希表格，在哈希表中添加“键-值”对。\nunordered_map和unordered_set有什么区别？\nunordered_set中只保存了键，主要用于查看某元素是否在集合中，不能保存每个键出现的次数。\nunordered_map和map有什么区别？\nmap中的键值是按序保存的，但是unorederd_map的键值是无序保存的；\n二者底层实现的数据结构不同，map使用的是红黑树，操作性能分别是$O(logn)$和$O(1)$\n常见的操作如下面的代码所示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // C++ program to demonstrate functionality of unordered_map #include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_map\u0026gt; using namespace std; int main() { // Declaring umap to be of \u0026lt;string, double\u0026gt; type // key will be of string type and mapped value will // be of double type unordered_map\u0026lt;string, double\u0026gt; umap; // 新增键值对 umap[\u0026#34;PI\u0026#34;] = 3.14; umap[\u0026#34;root2\u0026#34;] = 1.414; umap[\u0026#34;root3\u0026#34;] = 1.732; umap[\u0026#34;log10\u0026#34;] = 2.302; umap[\u0026#34;loge\u0026#34;] = 1.0; // 插入键值对，可以使用c++的make_pair函数 umap.insert(make_pair(\u0026#34;e\u0026#34;, 2.718)); string key = \u0026#34;PI\u0026#34;; // 查询方法一 if (umap.find(key) == umap.end()) cout \u0026lt;\u0026lt; key \u0026lt;\u0026lt; \u0026#34; not found\\n\\n\u0026#34;; // If key found then iterator to that key is returned else cout \u0026lt;\u0026lt; \u0026#34;Found \u0026#34; \u0026lt;\u0026lt; key \u0026lt;\u0026lt; \u0026#34;\\n\\n\u0026#34;; // 查询方法二 if (umap.count(key) == 0 ) cout \u0026lt;\u0026lt; key \u0026lt;\u0026lt; \u0026#34; not found\\n\\n\u0026#34;; // If key found then iterator to that key is returned else cout \u0026lt;\u0026lt; \u0026#34;Found \u0026#34; \u0026lt;\u0026lt; key \u0026lt;\u0026lt; \u0026#34;\\n\\n\u0026#34;; // 遍历方法一 unordered_map\u0026lt;string, double\u0026gt;::iterator itr; cout \u0026lt;\u0026lt; \u0026#34;\\nAll Elements : \\n\u0026#34;; for (itr = umap.begin(); itr != umap.end(); itr++) { // itr works as a pointer to pair\u0026lt;string, double\u0026gt; // type itr-\u0026gt;first stores the key part and // itr-\u0026gt;second stroes the value part cout \u0026lt;\u0026lt; itr-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; itr-\u0026gt;second \u0026lt;\u0026lt; endl; } // 遍历方法二 for (auto iter : umap) { cout \u0026lt;\u0026lt; iter.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; iter.second \u0026lt;\u0026lt; endl; } return 0; } 需要格外注意，除了上面的find方法之外，查询某个键是否在哈希表中，还可以通过如下代码查询某个键值key\n1 2 3 4 5 if (umap[key] \u0026gt; 0) { cout \u0026lt;\u0026lt; key \u0026lt;\u0026lt; \u0026#34; is found\\n\u0026#34;; } else { cout \u0026lt;\u0026lt; \u0026#34;Not found\\n\u0026#34;; } 如果哈希表中没有这个键值，那么它会自动添加进去，并赋给它初值，所以在查询某个键是否存在时，不要用这样的方法。\n参考资料 我写了首诗，把滑动窗口算法算法变成了默写题 - labuladong的算法小抄，非常通俗易懂的算法说明，基本上按照这个顺序来刷题的 unordered_map in C++ STL - GeeksforGeeks，C++ stl中的unordered_map Hashing | Set 1 (Introduction) - GeeksforGeeks，哈希表的介绍 ","date":"2020-08-02T15:40:45+08:00","permalink":"https://blog.bugxch.top/p/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7/","title":"滑动窗口技巧"},{"content":"最近练习leetcode编程，我希望在manjaro系统的vs code上可以单步调试C++代码，找了很多资料都不能正常运行，所以参考官方资料自己整好了，记录一下。\n预置条件 首先完成如下工作\n安装vs code;\n安装插件，如下图所示\n确认linux系统已经正确安装gcc，输入如下命令\n1 2 gcc -v # 查看gcc版本 sudo pacman -S build-essential gdb # 安装必要工具軟件 创建Hello world工程 在本地创建目录，我在本地创建了leetcode的目录，所以有如下的步骤\n1 2 3 4 5 mkdir project cd project mkdir cd helloworld code . # 在当前目录下打开vs code，当前打开的文件夹就是这个“工作空间” 阅读完本博客之后，你会在当前的目录下面创建下面的3个文件\ntasks.json (compiler build settings) launch.json (debugger settings) 添加源文件 如图所示，添加新的源文件helloworld.cpp\n在该文件中粘贴如下的源代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { vector\u0026lt;string\u0026gt; msg {\u0026#34;Hello\u0026#34;, \u0026#34;C++\u0026#34;, \u0026#34;World\u0026#34;, \u0026#34;from\u0026#34;, \u0026#34;VS Code\u0026#34;, \u0026#34;and the C++ extension!\u0026#34;}; for (const string\u0026amp; word : msg) { cout \u0026lt;\u0026lt; word \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } 然后保存该文件。\n构建helloworld.cpp 接下来，你将创建一个task.json文件告诉VS code如何构建(编译)当前的程序。这将触发g++编译器按照源代码创建一个可执行程序。在主菜单选择终端-\u0026gt;配置默认生成任务，然后在下拉菜单选择g++ build active file，如下图所示\n你将在.vscode文件夹下面看到tasks.json文件，我们进一步编辑这个文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;C/C++: g++ build active file\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;/usr/bin/g++\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}/${fileBasenameNoExtension}\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true } } ] } 关于json文件中变量的具体含义可以进一步参考Visual Studio Code Variables Reference\n文件中的指令指定了程序如何运行，当前文件中的args参数指定了传输给gcc的参数，这些参数必须按照编译器期望的顺序排列。\n这个任务告诉g++将源文件${file}编译，在当前文件夹下面创建可执行文件helloword，注意可执行文件的名称和源文件相同，但是去掉了扩展后缀名。label字段表示你能看到的任务列表，你可以写成任何你想写的东西。group中的\u0026quot;isDefault\u0026quot;: true表示你可以使用Ctrl+Shift+B运行该任务，这个仅仅是为了使用上的方便，你依然可以通过菜单中的选项运行该任务。\n运行编译程序 回到原来的helloworld.cpp程序，按下Ctrl+Shift+B运行该任务，请留意编辑器下方的终端的打印，在任务运行结束之后一般会提示成功或者失败，如果运行顺利，你可以看到如下的提示\n如果留意可以看到当前的文件夹中已经生成了可执行程序helloworld文件，打开新的终端，即可运行该程序\n1 ./helloworld # 运行可执行程序 修改tasks.json 你可以修改这个文件中的参数，比如将${workspaceFolder}/*.cpp替换${file}，或者也可以将${fileDirname}/${fileBasenameNoExtension}替换成一个硬编码的程序名称helloworld.out。\n调试源程序 接下来你将创建launch.json文件，当按下F5的时候VS Code调用GDB的调试器用于调试程序。找到菜单中的运行 \u0026gt; 添加配置，然后选择C++ (GDB/LLDB)，如下图所示\n我们选择g++ build and debug active file，你可以看到此处VS Code自动创建了文件launch.json文件，文件的内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;g++ - 生成和调试活动文件\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${fileDirname}/${fileBasenameNoExtension}\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;为 gdb 启用整齐打印\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34;: \u0026#34;C/C++: g++ build active file\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;/usr/bin/gdb\u0026#34; } ] } 很明显在这个文件中program指定了需要debug的程序，和之前的文件一样，此处就是没有后缀名的与源文件一样的程序，这个例子中就是helloworld。默认情况下，C++插件不会在代码中插入任何断点，所以stopAtEntry是false。如果将该项改为true，那么就可以让调试器停在主函数的断点处。\n开始调试 回到源文件，按下F5就可以开始调试了，在代码编辑器的上访可以看到调试的控制条，包括了单步调试，跳过调试，重启调试和停止调试的功能。稍微探索一下就可以发现，F9是添加断点，其他的调试方法鼠标悬停在上面都会显示快捷键，你看到的编辑器应该是这样的\n调试中可以看到每个变量的值，以及监视窗口。\n需要注意的是，当前的版本（2019年3月份之后）不会在单步调试模式下将cout的结果打印出来，只有程序运行完成之后才会统一打印出来。\n","date":"2020-07-26T08:12:22+08:00","permalink":"https://blog.bugxch.top/p/%E4%BD%BF%E7%94%A8linux-vs-code%E8%B0%83%E8%AF%95c-%E7%A8%8B%E5%BA%8F/","title":"使用linux vs code调试C++程序"},{"content":"为了能够进一步探讨创造力，深度思考，学习，以及AI当中的一些话题，我发现我不得不先写一篇post来引入关于思考的一些工具和运作方式，作为后续posts探讨的基石。这篇文章会基于我在medium上的post进行展开。\n为了掌握一项技能，或者深入一个领域，我们首先要从它们的定义开始入手，即知道，它们是什么，意味着什么。同样的，为了具备创造力，我们首先得弄清楚它最基本的含义是什么。\n所谓创造，其最基本的一个含义就是能够做出、发展出一些之前没有的东西，重点在于“之前没有”。这里很tricky的一个地方在于，只要是世人看不到的、接触不到的，即可认为是“没有”，而不必是哲学意义上的本来所固有之类的抽象属性。而为了创造出“世人看不到”的东西，你仅仅需要去看到那些其他人看不到的东西就可以了。\n这种“看到他人看不到的东西”的技能，叫做“深入思考”。你的思想越有穿透性，你的洞察力越深入，你就越能看到表象之下他人注意不到的事情。并且，这是一个细密并且会随着你认知能力的成长而成长的动态过程：\n为了能够进一步探讨创造力，深度思考，学习，以及AI当中的一些话题，我发现我不得不先写一篇post来引入关于思考的一些工具和运作方式，作为后续posts探讨的基石。这篇文章会基于我在medium上的post进行展开。\n为了掌握一项技能，或者深入一个领域，我们首先要从它们的定义开始入手，即知道，它们是什么，意味着什么。同样的，为了具备创造力，我们首先得弄清楚它最基本的含义是什么。\n所谓创造，其最基本的一个含义就是能够做出、发展出一些之前没有的东西，重点在于“之前没有”。这里很tricky的一个地方在于，只要是世人看不到的、接触不到的，即可认为是“没有”，而不必是哲学意义上的本来所固有之类的抽象属性。而为了创造出“世人看不到”的东西，你仅仅需要去看到那些其他人看不到的东西就可以了。\n这种“看到他人看不到的东西”的技能，叫做“深入思考”。你的思想越有穿透性，你的洞察力越深入，你就越能看到表象之下他人注意不到的事情。并且，这是一个细密并且会随着你认知能力的成长而成长的动态过程：\n你的穿透性越强，你深入的层次就会越深入； 你的视野越开阔，你所深入的方向就会越丰富； 你对你要解决的问题理解得越透彻，你就越能把握深入的程度，知道深入到哪个层次就必须停止，否则就是偏离你的问题。 每个人生而具备的能力是不同的，但我们不应该仅仅满足于继承于“天赋”的技能恒定值。正如人类区别于动物的地方在于，我们不会去接受大自然给我们的固有设定选项。我们会通过思考去发明工具，通过工具去开创出我们想要的世界。同样地，我们绝不应该也满足于自然给我们的“天赋”这一默认选项，我们会有意识地，通过练习、通过一些工具去塑造和提高我们想要的技能。\n掌握一项技能从来都不是件容易的事情。其第一步，必须要能够排除一些心理成见，让自己能够专注于训练本身。关于“深入思考”，很多人会拒绝去寻找、去接受提高他们思考能力的工具。他们会把这件事看得非常情绪化，非常personal。他们给出的反应是：提高思考的能力？我难道不会思考？你是说我无法掌握我自己的大脑？你是在侮辱我吗？(One direct ruthless answer from psychology to all these questions is yes, except the last one.)我对这些反应的一个看法是，人们非常容易在那些half-mature的技能或事情上得出偏见性的矛盾结论。\n如果你想去一个很远的地方，比如某个跨过太平洋的国家，你会很容易地接受这样一个事实：你不能够仅仅通过步行去完成这趟旅行。你会很乐意地运用一些工具，比如汽车或飞机去帮助你到达你的目的地。 如果你想去搜索一些信息，你会很容易地接受你不能够仅仅通过自己的双手和眼睛去到处寻找材料。你会很乐意地运用一些工具，比如Google去帮助你寻找你想要的。 那你为什么不能接受你需要运用工具才能好地提高你的思考技能的事实呢？人们通常会对那些他们穷尽所有能力都毫无办法的事情表现得客观一些，而对那些他们可以但却不够成熟的事情表现得很情绪化。（这也是为什么你比他人强一点点会引来嫉妒，强大很多会引来羡慕和祝福。）\n请抛掉这些无畏的偏见和情绪，让我们集中于提高思考深度的问题上。\n在我看来，问题列表(question list)，实践和写作是用于提高思考深度的最小巧并且最有效的工具组合。它们足够轻便，任何人都可以轻而易举地得到它们。但这样的易得性，丝毫没有降低它们在帮助你进入一个新的领域，解决一些复杂性难题时的有效性。恰恰相反，它们的小巧易得性，能够像Unix工具或者瑞士军刀一样，不仅能够为你提供各种行之有效的组合方案，而且还能将其复杂度和可操作性控制在你能接受的范围之内。\n问题列表 每一个领域都有独特的思维方式、思考角度和核心思想。在一个领域里的摸爬滚打，能让你学到的最有价值的东西不是这个领域的知识，而是这个领域独有的思维方式和它背后所展现的核心思想。另一方面，所谓进入一个领域，或者说在一个领域里开始入门，指的是你能够真正以这个领域所独有的角度去思考问题，能够用它背后所蕴含的思想去指导你的行事方式，进而让你具备这个领域所特有的做事风格。\n然而，要开始这样一段入门进而不断精深的旅程，你不能够像跑步一样，仅仅对自己说一声“往前”，然后就可以不断前进。大脑不会那样乖乖听话，因为那不是大脑的运作方式。如同钓鱼需要鱼饵，为了能够让大脑开启它的引擎，你也必须提供它的诱饵：“问题”。\n人的思维不会自动地往下深入，它只会根据你能提供给它的问题进行运转。你向什么方向抛出问题，它就向什么地方思考；你的问题越精细，它的思考就会越缜密；你抛给大脑的问题越频繁，它所训练的时间就会越长久。大师和新手之间的差距，在于处理一个问题时，他们头脑中的问题列表不同。大师头脑中的问题列表，不仅详实丰富，并且主次分明。他知道首先应该问出什么样的问题，去把握一件事的主题框架；然后，应该在哪些地方问出一些基本的构架性问题，以掌控住局势；最后，应该在哪些地方抛出更为细致的问题，以便能够进一步精细、优化自己所最关心的核心主题。你必须不断地扩充和删减你的问题列表，让它足够充分而又没有冗余，集中在“关节”性的部分，而不会被表象稀释它们的有效性。\n如何开始你的成长之旅，让你可以不断扩充你的问题列表？特别是开始阶段，如何从0变为1？我想，一份能够跨越领域的通识性的“元问题”列表或许能够给予你帮助。\n进入一个新的领域，你所需要开始的第一个问题系列便是：\n这个领域为什么会存在？它的意义是什么，能够为世界提供什么价值？ 这个领域关心哪些问题？为什么这些问题值得这个领域关心？ 你对上述问题的解答全面吗？如果是，你如何能够证明你的解答是完整的？如果不是，你怎样才能搜集到这个领域更多的信息？ 这些问题所展现的不仅是你如何进入新领域的途径，更是在向你说明，你的大脑如何在阅读上述材料时逐步落地，真正开始深入肤浅的表象，去进一步探索深刻的主题。很多人会嘲笑一些领域的“简单”和“枯燥”，对其从业者所表现出来的对该领域的“诗意”一般的向往表示费解和轻蔑，比如设计、电影、写作、数学和编程。\n面对设计作品，我们往往很难体会到设计者背后的良苦用心。为什么我们会不懂设计？因为我们缺乏最起码的入门。但只要我们通过上面的元问题列表检测一下自己，立刻就会推演出自己应该努力的方向，进入深度的沉思状态。\n为什么设计会存在？它真的仅仅是简单的装饰的堆砌吗？如果是，那为什么有些人会把奢侈品穿成淘宝货，而另外一些人能够把淘宝货穿出奢侈品的格调？如果不是，到底是什么能够让它能够直指你的内心，让你的所有行事方式都跟随设计者的意图移动？（嗯？感觉惊讶吗？嗯，你开始深入思考了） 这个领域关心哪些问题？关心各种细小元素：长、短、明、暗？为什么这些问题值得这个领域关心？仅仅是因为它能影响你的审美吗？它会不会影响你的其它部分呢？你的情绪？判断力？甚至是你的价值取向？ 你对上述问题的解答全面吗？所谓设计，仅仅考虑的是它的“美”吗？是否有可能我们完全弄错了它所关心的主题呢？会不会有可能它对“美”的理解完全不同于对装饰的关注呢？ 没有问题的引导，你甚至不会知道自己的“不知”，轻易地陷入习焉不察、不以为意的恶习。要知道其中的精髓和内在含义，就不得不细加推敲和反复琢磨。这些“推敲”与“琢磨”都是建立在你的“问题列表”之上的。很多新人面对师傅的指导，常常容易听到一句这样的话，“你得多看看，你再多想想”。在我看来，这是非常粗糙的指导。我应该看什么呢？想什么呢？对于稍有经验的人，没有进行深思熟虑是态度问题。可是，对于初学者来说，他还没有构建出相应的问题列表，还不知道应该问什么问题，应该反复推敲一些什么问题。这也就是俗称的没入门。此时给出一份该领域的问题列表，对于新手的成长将会是极其有帮助的。但即便是无人指导（每一个新领域的开拓者都会遇到这样的情况），跨界的元问题列表，也能为你提供一个很好的探索的起点。\n所谓问之弥深，钻之弥坚，你思维的引擎会随着所问的问题而不断地提升其转速，而的你思考也会随着问题的引领而不断地加深。没有问题做诱饵，你的思考将无法深入，你的思维也无法缜密。“反复推敲”“心思缜密”“行事谨慎”，没有一份问题列表作依托，就会成为你的一厢情愿。\n另一方面，问题列表本身即会构成一个领域的框架。所谓框架，即是一个领域所依托的骨架。如若能够将其骨架上的问题和所思所问一一解决和考量，这个领域的其它部分，便能够得以健康成长。而这些思维的框架无一不是由问题列表所构成，比如波特五力模型，CFA的企业财务健康分析，又或者是创业人士对自己将要构建的世界的分析。在如今创业大潮的时代背景下，列举一份我搜集整理的Google的问题列表，为大家作为参考，翻译如下：\nGoogle问题列表 思考一下你理想中的工作是什么样的，不是你当前的设想，而是你五年后的图景你想到什么地方去？\n你想做什么事？ 你想赚取多少薪水？ 写下你理想中的工作的介绍 (job description)：想想如果你在网上看到它，它应该是什么样的？ 现在，再想象你穿越到5年后并且你已经得到了这份工作：\n这时，你的简历上五年前到现在的履历应该是什么样的？ 从五年前到你现在得到这个职位，你应该会经历怎样的历程？ 请继续保持思考你理想中的工作，根据它去评估一下你自己的优势和劣势：你还需要提高哪些方面才能到达哪里？\n顺便提一句，如果你的结论是你现在已经得到了你理想中的工作，那么，这说明你的思考还不够大胆。重新做一遍上述的步骤，并且要保证你理想中的工作是基于你当前实力的延展，而不是毫无根据的幻想。\n如果你按照以上步骤行事，它应该会有效果。如果你不遵循它们，那么你很可能会为YogiBerra的一段话提供一段新的实例证明：“你要小心了，如果你都不知道你的理想乡在哪里，那么你很可能不会到达那里。”\n提出问题和解释问题的技能同给出问题答案的技能同样重要。\n现在，如果你对未来有你自己的一些看法，并且有了一些主意，那么你可以问问自己一些更加残酷的问题：\n一家非常小巧并且资本充裕的竞争公司，会如何去撼动你公司的核心业务？ 它会怎样利用数字平台的优势去挖掘你的弱点，或者撬走为你公司带来盈利最多的客户呢？ 你公司当前所做的哪些事情正在摧毁自己的业务呢？ 同质竞争和收益受损是你公司扼杀潜在创新所经常给出的理由吗？ 公司的领导层经常使用自己的产品吗？他们热爱它吗？ 他们愿意把自己的产品作为礼物送给自己的另一半吗？（显然这在很多情况下会有点不切实际，但它依旧是一个很好的思想实验。） 你的客户热爱你的产品吗？ 还是说，你的客户是被一些其它因素绑定在了你的产品上，但这些因素在未来很可能会消失？ 想象一下如果你的客户完全不会被这些因素所绑定，那会发生什么？ 上一问题的一个有趣的推论是，如果你强迫你的产品团队将产品做得来让客户可以轻易抛弃你的产品而转向你的竞争者，你的产品团队会有什么样的反应？他们依然能够将产品做得来非常出色，以至于客户想要继续使用你的产品，即便是他们不必如此？ 关于产品的问题列表：\n它们有多少部分是建立在独特的技术洞见之上？ 有多少产品人是在高管阵营里面？ 公司是否狠狠地奖励和提拔了那些在创造出色产品中做出最大贡献的人？ 你的决策过程是导向最好的决策？还是导向最容易接受的决策？ 你的员工有多大的自由度？ 如果你的公司里有一名非常有创造力的员工，这名员工能够有足够的自由度去施展和实现他的想法而不用担心他自己的职位高低吗？ 你在新想法的决策是依据产品的优良程度，还是盈利程度？ 在你的公司里，谁的表现会更好呢？是那些掌握了大量信息的人，还是传播了大量信息的人？ 那些掌握大量信息的人会阻止信息在人们之间互相传播吗？ 上面都是一些非常残酷的问题，并且他们都没有显而易见的答案。但可以肯定的是，如果这些问题不被提出，那么肯定不会有相应的解决方案。\n另外，鉴于我自己的技术背景，这里再提供一份我整理的技术人员的问题列表供大家参考，它们来自于《技术人创业攻略》这本书。\n许世伟 先了解整个背景，看别人一般怎么做 有哪些新兴的idea，这些idea是不是靠谱，如果我来做，会倾向于哪个方向 新技术的思考方式是什么 它要解决的问题是什么 它和自己要解决的问题有多大的相关性 你对这个技术的“了解”，是只限于多了解了一个名词？ 你清楚了这个技术背后的具体原理吗？ 产品的思考\n你了解这个产品的业务吗 了解它的运作方式吗 这个产品和商业的关系是什么呢 用户为什么需要我们 我们到底在颠覆什么 到底要做什么，应该如何做 工种认知和服务认知 为什么要做这个服务 把服务做好，要做哪些功能 某个功能为什么会受到用户群的欢迎\n刘睿敏 你想用钱去换技术：\n技术是别人吃饭的东西，为什么会给你？你如果不自己造一个饭碗，别人为什么会把他的给你呢？ 什么叫自主可控？自己做的，从无到有的东西叫自主可控。不是自己做的，就不可控 产业链上最核心的技术有哪些？你是否掌握了这些核心技术？ 你是否在持续跟踪这些核心技术？在应用真正开始盛行之前，你做好了理论上的准备吗？ 你是否只能谈一些如何应用、基于实践和操作层面的东西？ 你能深入细谈核心的技术要点和设计思路吗？ 你是否理解你修改的开源产品背后的设计思路？ 你是否有循序渐进地、逐层深入地了技术的核心？ 上层的工具开发，你是否有做相应的工作？中层的解析执行，你是否知道它们遵循的路径是什么？底层的优化，你是否知道该如何设计，你的优化又如何与其它模块配合？ 你的角色是否仅仅是一个使用者？ 你是否甚至连这个领域的理论都不清楚，还混淆了其中的各种概念 这篇文章转载自下面的公众号，大家可以关注公众号GeekArtT\n","date":"2020-07-19T21:18:11+08:00","permalink":"https://blog.bugxch.top/p/%E8%BD%AC%E8%BD%BD%E7%94%A8%E4%BA%8E%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/","title":"[转载]用于深入思考的小工具"},{"content":"背包问题是非常经典的动态规划问题，但是中文书籍和资料很少有把这个问题说得清晰明了的，问题表述不清，递推公式错误，不一而足，我在彻底想清楚这个问题后，觉得很有必要记录下整个思考过程。\n原始问题 当前有$n$件物品，第$i$件物品的重量为$w_i$，价值为$p_i$，当前有一个容量为$C$的背包。此处物品的重量，价值以及背包的容量都是非负整数。从这些物品中精心挑选若干件装入包中，这若干件被挑选的物品总重量不超过背包容量$C$，总价值尽量大，那么所有可能的挑选方法得到的\n最大值为多少？ 放进去哪些物件得到这个最大值？ 问题的表述比较抽象，如果上面的问题有统一的算法，那么即便问题的规模缩小，问题解决的逻辑也不会有变化，所以从规模比较小的情形入手，更容易分析出来。假设背包容量是4kg，我们有3件物品，每件物品的价格以及重量见下表\n物品 1 2 3 重量/kg 1 3 4 价格/$ 8 9 10 我相信大多数人看到这个问题，会使用如下的贪婪算法。\n贪婪算法 第1个想法是将物品按照价格从高到低进行排序，如果背包的空余容量可以容纳该物品，则将它放入背包。按照这个方法处理对于上面的例子，结果应该是仅仅放入第3件物品，价值是10，但是明显是错的，因为放入物品1和2的价值更大（17），所以这个方法行不通。\n与上面的方法类似，可以按照重量从轻到重装入背包，但是对于下面的情形一样行不通\n序号 1 2 3 重量/kg 1 2 3 价格/$ 8 9 18 放入背包的重量是物品1和2，总重是3，价值是17，正确答案是放入1和3，总价值是26，所以这种方法明显是错误的。\n另一种改进的方法，定义物品的价值密度为 $$ \\rho_i = p_i/w_i $$ 按照价值密度由高到低排序，依次核验后放入背包，但是按照该算法处理下面的情形依然是失败的\n序号 1 2 3 重量/kg 1 2 2 价格/$ 8 9 18 $\\rho_i$ 8 4.5 9 该方法的结果是放入1和3，但是明显2和3号的价值更大。\n所以，无论是按照重量，大小，还是密度排序，这样的方法都是错误的。其实考虑最周全的方法，求$n$件物品的是否放入背包的全部组合，记录所有总重量可以放入背包的组合的价值，然后选一个最大值即可，但是对于$n$件物品，需要考虑的组合有$2^n$组，算法的复杂度很高，当$n$比较大的时候就很不实际。\n上面的三种方法使用贪婪算法，下面是《算法的乐趣》中对贪婪算法的描述，\n贪婪算法是寻找最优解的常用方法，该方法将求解的过程分成若干步骤，在每个步骤都应用贪心原则，选取当前状态下最好的或者最优的选择（局部最有利的选择），并以此希望最后堆叠出的结果是最好的或者最优的解。\n之前的算法将物品的选择分解为依次挑选物品，这里的次序可以是价值从高到低，重量从低到高或者密度从大到小，并且希冀于每一步结束之后，整体上的价值是最高的，重量是最轻的或者密度是最大的。这个就是明显的贪婪算法思想，但是局部最优不等于全部最优，因此这样的算法是失败的。\n动态规划 重新定义问题 重新思考这个问题，换一个角度将其理解为有限空间利用价值最大化的问题，我们更清晰的描述一下这个问题，有助于我们进一步思考。从$n$个物品中挑选出其中的$m(m \\le n)$个，用于填充大小为$C$的空间，\n使得$m$个物件的的总重量不超过$C$，即$ \\sum_{k=1}^{m}{w_k} \\le C$ 在满足条件1的情况下，$m$个物件的总价值在所有可能的挑选组合中最大。 我们用$V[i, C]$表示这$m$个物件的总价值，即 $$ V[i,C] = \\max_{s.t.}{\\sum_{k=1}^{m}{p_k}}，m \\le n $$ 重申一下$V[i,C]$的含义，它表示**使用$i$个物件充分填充空间$C$得到的最大价值，**所以，这个问题就需要找到两样答案，\n$V[i,C]$的值； 得到$V[i,C]$的值对应的$m$个物件的集合$M_i$ 很多文章根本就没有把$V[i,C]$的含义说清楚！\n很多文章根本就没有把$V[i,C]$的含义说清楚！\n很多文章根本就没有把$V[i,C]$的含义说清楚！\n请注意，这个含义非常重要，在后面的推导和计算过程中会反复使用，请务必深刻理解！\n递推思路 注意前方高能，下面是这个算法的关键, 假定我们已经得到上面两个问题的答案，**如果此时再有第$i + 1$个物品加进来，该怎么处理？**此时，问题转换为求\n使用$i + 1$个物件充分填充空间C得到的最大价值$V[i + 1,C]$ 以及$V[i + 1,C]$对应的物件的组合$M_{i+1}$ 当你手里拿着这个重量为$w_{i+1}$的物品，准备填充容量为$C$的空包时候（注意此处的空包，不要想当然得以为包里面已经有前面的$i - 1$中挑选的物件了），有下面两种情形，\n该物件的重量大于背包的容量，即$w_{i+1} \\gt C$，那么这个物品无论如何也放不进背包，因此这个物品不会被选中，所以只能使用前面$i$个物件填充$C$，得出$V[i + 1,C] = V[i, C]，M_{i + 1} = M_{i}$。 该物件的重量小于等于背包容量，即$w_{i+1} \\le C$，这个时候你有两种选择， 先将这个物件放入背包，此处背包的可用空间还有$C-w_{i+1}$，那么可以使用之前的$i$件物品去充分填充这个剩余空间。注意，此时背包空间由两部分的物件充分填充，\n物件$i+1$充分填充空间$w_{i+1}$，该空间的最大价值为$p_{i+1}$\n之前的$i$个物件充分填充剩余的空间$C - w_{i+1}$，该空间的最大价值为$V[i-1, C-w_{i+1}]$ 所以，当前的情形下**使用$i+1$个物件填充空间$C$**的最大价值是上述二者的和，即$V[i+1, C] = V[i, C-w_{i+1}] + p_{i+1}，M_{i+1} = M_i\\bigcup i+1$。\n不放入背包，那结果和之前的第一种情形一样，空间$C$由前面的$i$件物品充分填充，那么$V[i + 1,C] = V[i, C]，M_{i + 1} = M_{i}$。 因此，结合上面的分析，对于这种可以放入背包的情形，取二者的最大值，有$V[i+1, C]=\\max {V[i, C-w_{i+1}] + p_{i+1}，V[i, C]}$。\n综合以上分析，我们得到了一个递推关系式，\n**终于水落石出！**将递推关系式中的$i$换成$i-1$，于是得到如下的结果\n初始条件及推导方法 根据上面的推导式，就可以求出最后的结果，最后还有两点需要明确：\n$V[i, C]$的最初的值是什么？\n回想一下这个值表示的含义，使用$i$个物件充分填充空间$C$得到的最大价值，仔细考虑这个含义可以得到\n$V[0,0] = 0$，使用0个物件填充大小为0的空间的最大价值肯定是0 $V[0,C] = 0$，使用0个物件填充大小为C的空间的最大价值肯定是0，背包空空如也，价值为0 $V[i,0] = 0$，使用$i$个物件填充大小为0的空间的最大价值肯定是0，背包空空如也，价值为0 如何根据最初的值，一步步推导出最终的结果$V[i, C]$？\n再观察上面的递推公式，$i$个物件总的最大价值依赖于前$i-1$个物件总的最大价值以及当前第$i$个物件本身的重量以及价值，换句话说，如果我知道了前$i-1$个物件总的最大价值以及当前第$i$个物件本身的重量以及价值，那么我也能推导出$i$个物件总的最大价值。\n更仔细的观察公式里面的max的公式，我们不仅需要知道$V[i-1, C]$，还需要知道$V[i-1, C-w_i]$，特别地，这里的$w_i$表示第$i$个物件的重量，它可以是任意的非负整数，因此我们需要知道$V[i-1,0]$到$V[i-1,C]$的所有值，于是下面的二维数组填充就呼之欲出。\n二维数组 我们使用二维数组记录$V[i,C]$，二维数组的行数为物件的总数$i$，二维数组的列数是背包的容量$C+1$（注意此处多加了一列，因为从上面的推导看出我们需要知道$V[i-1,0]$的值，所以多加一列作为第0列），我们使用之前的问题，使用4Kg容量的背包挑选下面的物件\n物品 1 2 3 重量/kg 1 3 4 价格/$ 8 9 10 我们一步步看看这个表格怎么填充，\n建立空的二维数组，行数是3，列数是5，表格中的所有值都是未知数（注意此表从第0列开始，我们数第0列，第1列直到第4列），\n根据之前的推论$V[i,0] = 0,i = 1,2,3$，所有行的第0列都是0，得到如下的表格\n计算第1行的值$V[1,k],k=1,2,3,4$，再回想一下这个含义的意思，使用1个物件填充空间为$k$的最大价值，第一个物件的重量是1，价值为8，那么\n可以填充大小为1的空间，填充后的剩余空间为0，总价值为8，即$V[1,1]= 8$； 可以填充大小为2的空间，填充后的剩余空间为1，但是此时你手上没有别的物件了，所以填充到此为止，总价值为8，即$V[1,2]= 8$； 可以填充大小为3的空间，填充后的剩余空间为2，但是此时你手上没有别的物件了，所以填充到此为止，总价值为8，即$V[1,3]= 8$； 可以填充大小为4的空间，填充后的剩余空间为3，但是此时你手上没有别的物件了，所以填充到此为止，总价值为8，即$V[1,4]= 8$； 于是，我们得到第一行的值如下表所示\n有了第2行的值，就可以根据之前的递推公式机械式得计算，第2件物品的重量为$w_2=3$，价值为$p_2=9$，\n第2件物品的$w_2\u0026gt;1$，所以根据递推公式计算$V[2,1]=V[1,1]=8$，这件物品不放入包中； 第2件物品的$w_2\u0026gt;2$，所以根据递推公式计算$V[2,2]=V[1,2]=8$，这件物品不放入包中； 第2件物品的$w_2=3$，所以根据递推公式计算$V[2,3]=\\max {V[1, 3-w_2] + p_{2}，V[1, 3]}=\\max {V[1,0] + 9，V[1, 3]}=9$，这件物品放入包中； 第2件物品的$w_2\u0026lt;4$，所以根据递推公式计算$V[2,4]=\\max{V[1, 4-w_2] + p_{2}，V[1, 4]}=\\max{V[1, 1] + 9，V[1, 4]}=17$，这件物品放入包中； 于是得到第二行的结果如下\n按照计算第2行值的方法，计算第3行的值，结果如下\n所以最终的结果是用3个物件填充空间为4的背包，得到的最大价值为$V[3,4] = 17$。\n放入哪些物件 但是且慢，文章的开头还有一个问题，我们放进去哪些物件，得到这个最大值的呢？请注意之前的递推思路那一小节中的物件集合$M_i$的变化，当且仅当$V[i, C] = V[i-1, C-w{i}] + p_{i}$时，第$i$件物品才会被放进来。再仔细观察一下递推公式，我们可以看到$V[i,C]$的值要么等于$V[i-1, C-w{i}] + p_{i}$，要么等于$V[i-1,C]$，所以可以确认\n如果$V[i, C] = V[i-1, C]$，那么第$i$件物品没有被放入背包中\n但是仅仅有这个条件判断是不是已经足够了，如果第$i$个物品是被放入背包中的，下一步回溯还是考察$V[i-1,C]$是否与$V[i-2,C]$的值相等吗？回到之前的那幅图\n总的问题与子问题有相同的结构，如果第$i+1$个物品已经验证放入背包中了，更小的问题是使用$i$个物件填充大小为$C-w_{i+1}$空间，那么我们应该考察$V[i,C-w_{i}]$是否与$V[i-1,C-w_{i}]$的值相等。所以回溯的算法如下：\n从二维数组的$V[i, C]$开始，检查$V[i, C]$的值是否与$V[i-1, C]$相同； 考察第1步的结果 如果相同，那么第$i$件物品没有被放入背包，令$i-1\\rightarrow i$，即继续检查$V[i-1, C]$的值是否与$V[i-2, C]$相同；\n如果不同，那么第$i$件物品被放入背包，令$i-1\\rightarrow i, C-w_i\\rightarrow C$，即继续检查$V[i-1, C-w_i]$的值是否与$V[i-2, C-w_i]$相同；\n不停使用步骤2的逻辑，直到考察到$i=0$为止。 那么，就可以逐行倒着回溯二维数组，\n我们先看第3行，$V[3,4]=V[2,4]$，所以第3件物品没有放入背包；\n第2行，$V[2,4]\\ne V[1,4]$，所以第2件物品放入背包，接下来需要检查$V[1,4-w_2]$是否与$V[0,4-w_2]$相同；\n第1行，$V[1,1]\\ne V[0,1]$，所以第1件物品放入背包（注意此处$V[0,4] = 0$，二维表格没有第0行，但是我们初始条件中推导过这个值），检查结束。 编程代码 下面是C++的程序代码，\n定义一个背包的类，默认有10物件，每个物件大重量为6，最高价格为35。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // knapsack.h #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;ctime\u0026gt; using std::vector; using std::cout; typedef struct tagObj { int weight; int price; } Obj; inline int max(int a, int b) { return a \u0026gt; b ? a : b; } class Knapsack { public: Knapsack(const int size = 10, const int maxWeight = 6, const int maxPrice = 35); void SolvePro(const int totalW); friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const Knapsack\u0026amp; nap); private: vector\u0026lt;Obj\u0026gt; knapsack_; vector\u0026lt;int\u0026gt; index_; int totalPrice_; }; 方法如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 // knapsack.cpp #include \u0026#34;knapsack.h\u0026#34; #include \u0026lt;ctime\u0026gt; #include \u0026lt;algorithm\u0026gt; Knapsack::Knapsack(const int size, const int maxWeight, const int minPrice) { srand(static_cast\u0026lt;unsigned int\u0026gt;(time(nullptr))); Obj obj; for (int i = 0; i \u0026lt; size; i++) { // 随机生成价值和重量 obj.weight = rand() % maxWeight + 1; obj.price = rand() % minPrice + 1; knapsack_.push_back(obj); } totalPrice_ = 0; } std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const Knapsack\u0026amp; nap) { os \u0026lt;\u0026lt; \u0026#34;Dispaly knapsack list\\n\u0026#34;; os \u0026lt;\u0026lt; nap.knapsack_.size() \u0026lt;\u0026lt; \u0026#34; object as below\\n\u0026#34;; for (unsigned i = 0; i \u0026lt; nap.knapsack_.size(); i++) { os \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34;: weight \u0026#34; \u0026lt;\u0026lt; nap.knapsack_.at(i).weight \u0026lt;\u0026lt; \\ \u0026#34;, price \u0026#34; \u0026lt;\u0026lt; nap.knapsack_.at(i).price \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return os; } void Knapsack::SolvePro(const int totalW) { const int row = static_cast\u0026lt;int\u0026gt;(knapsack_.size()); const int col = totalW; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; matrix(row + 1, vector\u0026lt;int\u0026gt;(col + 1, 0)); for (int i = 1; i \u0026lt;= row; i++) { for (int j = 1; j \u0026lt;= col; j++) { matrix[i][j] = matrix[i - 1][j]; if (j \u0026gt;= knapsack_.at(i - 1).weight) { matrix[i][j] = max(matrix[i - 1][j], \\ matrix[i - 1][j - knapsack_.at(i - 1).weight] + \\ knapsack_.at(i - 1).price); } } } totalPrice_ = matrix[row][col]; int startRow = row; int startCol = col; while (startRow \u0026gt; 0) { if (matrix[startRow][startCol] == matrix[startRow - 1][startCol]) { startRow--; continue; } index_.push_back(startRow); startCol -= knapsack_.at(startRow - 1).weight; startRow--; } reverse(index_.begin(), index_.end()); cout \u0026lt;\u0026lt; \u0026#34;\\nWeight capacity is \u0026#34; \u0026lt;\u0026lt; totalW \u0026lt;\u0026lt; \u0026#34;, and totalPrice is \u0026#34; \u0026lt;\u0026lt; matrix[row][col] \u0026lt;\u0026lt; \\ \u0026#34;, selected obj index is: \u0026#34;; for (unsigned i = 0; i \u0026lt; index_.size(); i++) { cout \u0026lt;\u0026lt; index_.at(i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } 使用main函数，调用如下\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; #include \u0026#34;knapsack.h\u0026#34; int main() { Knapsack nap1(10, 6, 10); // 我们有10个物品，最大重量为6，最大价值为10，价值和重量都是随机生成的 std::cout \u0026lt;\u0026lt; nap1; nap1.SolvePro(30); // 背包容量30 return 0; } 结果如下\n参考资料 0-1背包问题 - 简书，描述《算法图解》中对该问题的解法，比较有趣 动态规划解决01背包问题 - Christal_R - 博客园，中文博客写得不错的文章 背包 DP - OI Wiki，在没有Google下搜索出来的总结比较全面的文章 背包问题九讲 · 看云，非常系统的背包问题的解释 ","date":"2020-02-22T00:00:00Z","permalink":"https://blog.bugxch.top/p/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/","title":"01背包问题详解"},{"content":"假期做题，记录下。\n此处是复习题的答案，编程练习题的答案见bugxch/Solutions_C-PrimerPlus。\nAnswer #1 a) 形参在函数调用时候创建，在函数返回时销毁，自动存储变量，无链接性，所以是自动变量；\nb) 文件共享的变量具有外部链接性，所以使用静态存储外部链接性的变量，比如在A文件中定义，在B中使用extern关键字引用；\nc) 内部链接性，静态存储变量，可以使用static修饰符，或者使用未命名的命名空间；\nd) 无链接性，但是是静态存储变量，在函数内部使用static修饰符定义\nAnswer #2 有一下几点区别：\nusing声明仅仅导入特定的名称，但是using编译命令将导入一个名称空间的所有名称； 假如名称空间和声明区域定义了相同的名称。using声明中如果该名称与局部名称发生冲突，编译器会发出警告，但是using编译指令导入的而名称会被局部版本隐藏。 Answer #3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #inlcude \u0026lt;iostream\u0026gt; int main () { using double x; std::cout \u0026lt;\u0026lt; \u0026#34;Enter valud: \u0026#34;; while (!(cin \u0026gt;\u0026gt; x)) { std::cout \u0026lt;\u0026lt; \u0026#34;Bad input! Please enter a number: \u0026#34;; std::cin.clear(); while (std::cin.get() != \u0026#39;\\n\u0026#39;) continue; } std::cout \u0026lt;\u0026lt; \u0026#34;Value = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; return 0; } Answer #4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #inlcude \u0026lt;iostream\u0026gt; int main () { using std::cout; using std::cin; using double x; cout \u0026lt;\u0026lt; \u0026#34;Enter valud: \u0026#34;; while (!(cin \u0026gt;\u0026gt; x)) { cout \u0026lt;\u0026lt; \u0026#34;Bad input! Please enter a number: \u0026#34;; cin.clear(); while (cin.get() != \u0026#39;\\n\u0026#39;) continue; } cout \u0026lt;\u0026lt; \u0026#34;Value = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; return 0; } Answer #5 因为两个函数的形参和顺序一样，仅仅是返回值不同，因此无法使用函数重载。如果在不同的文件中使用，这两个函数的作用域不同，有两种方式实现，\n可以使用static关键字， 1 static double average(int a, intb) 将函数的声明和定义放在未命名的名称空间中 Answer #6 1 2 3 4 5 10 4 0 Other: 10, 1 another(): 10, -4 Answer #7 1 2 3 4 5 6 1 4, 1, 2 2 2 4, 1, 2 2 ","date":"2020-01-27T12:49:07Z","image":"https://raw.githubusercontent.com/bugxch/blogpics/master/202001/c%2B%2B.jpg","permalink":"https://blog.bugxch.top/p/cplusplus-primer-plus%E7%AC%AC%E4%B9%9D%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/","title":"《CPlusPlus Primer Plus》第九章习题及答案"},{"content":"该文档转载自图像缩放——双线性插值算法，我搜罗一堆中文文章里面讲得比较清楚的一篇了。\n在数学上，双线性插值是有两个变量的插值函数的线性插值扩展，其核心思想是在两个方向分别进行一次线性插值。如果选择一个坐标系统使得 f 的四个已知点坐标分别为 (0, 0),(0, 1),(1, 0) 和 (1, 1)，那么插值公式就可以化简为 $$ f(x, y) \\approx f(0,0)(1-x)(1-y)+f(1,0) x(1-y)+f(0,1)(1-x) y+f(1,1) x y $$ 用矩阵运算来表示的话就是 图像的空间变换，也称几何变换或几何运算，包括图像的平移、旋转、镜像变换、转置、缩放等。空间变换可如下表示：设(u,v)为源图像上的点，(x,y)为目标图像上的点，则空间变换就是将源图像上(u,v)处的颜色值与目标图像上(x,y)处的颜色对应起来。 计算机所处理的图像都是指点阵图，也就是用一个像素矩阵来描述一副图像。举个简单的图像：3×3的256级灰度图，也就是高为3个象素，宽也是3个象素的图像，每个象素的取值可以是 0－255，代表该像素的亮度，255代表最亮，也就是白色，0代表最暗，即黑色 。\n假如图像的象素矩阵如下所示：(这个矩阵中，图象处理中最常用的坐标系是：x从左到右，从0开始，y从上到下，也是从0开始)\n如果想把这副图放大为 4X4大小的图像，那么第一步肯定想到的是先把4X4的矩阵先画出来再说，好了矩阵画出来了，如下所示，当然，矩阵的每个像素都是未知数，等待着我们去填充\n然后要往这个空的矩阵里面填值了，要填的值从哪里来来呢？是从源图中来，好，先填写目标图最左上角的象素，坐标为(0,0)，那么该坐标对应源图中的坐标可以由如下公式得出： $$ srcX = dstX * (srcWidth / dstWidth) , \\ srcY = dstY * (srcHeight / dstHeight) $$ 套用公式，就可以找到对应的原图的坐标了$(0*(3/4),0*(3/4))=\u0026gt;(00.75,00.75)=\u0026gt;(0,0)$，找到了源图的对应坐标,就可以把源图中坐标为(0,0)处的234象素值填进去目标图的(0,0)这个位置了。所有的数值填充之后的结果如下所示\n这种放大图像的方法叫做最临近插值算法，这是一种最基本、最简单的图像缩放算法，效果也是最不好的，放大后的图像有很严重的马赛克，缩小后的图像有很严重的失真；效果不好的根源就是其简单的最临近插值方法引入了严重的图像失真。比如，当由目标图的坐标反推得到的源图的的坐标是一个浮点数的时候，采用了四舍五入的方法，直接采用了和这个浮点数最接近的象素的值，这种方法是很不科学的，当推得坐标值为 0.75的时候，不应该就简单的取为1，既然是0.75，比1要小0.25 ，比0要大0.75 ,那么目标象素值其实应该根据这个源图中虚拟的点四周的四个真实的点来按照一定的规律计算出来的，这样才能达到更好的缩放效果。\n双线型内插值算法就是一种比较好的图像缩放算法，它充分的利用了源图中虚拟点四周的四个真实存在的像素值来共同决定目标图中的一个像素值，因此缩放效果比简单的最邻近插值要好很多，计算量比零阶插值大，但缩放后图像质量高，不会出现像素值不连续的情况。\n双线性内插值算法描述如下: 对于一个目的像素，设置坐标通过反向变换得到的浮点坐标为(i+u,j+v) (其中i、j均为浮点坐标的整数部分，u、v为浮点坐标的小数部分，是取值[0,1)区间的浮点数)，则这个像素得值 f(i+u,j+v) 可由原图像中坐标为 (i,j),(i+1,j),(i,j+1),(i+1,j+1)所对应的周围四个像素的值决定，即：　$$ f(i+u, j+v)=(1-u)(1-v) f(i, j)+(1-u) v f(i, j+1)+u(1-v) f(i+1, j)+u v f(i+1, j+1) $$\n其中f(i,j)表示源图像(i,j)处的的像素值，以此类推。\n假如目标图的象素坐标为(1,1)，那么反推得到的对应于源图的坐标是(0.75,0.75), 这其实只是一个概念上的虚拟象素,实际在源图中并不存在这样一个象素,那么目标图的象素(1,1)的取值不能够由这个虚拟象素来决定，而只能由源图的这四个象素共同决定：(0，0)(0，1)(1，0)(1，1)，而由于(0.75,0.75)离(1,1)要更近一些，那么(1,1)所起的决定作用更大一些，这从公式1中的系数uv=0.75×0.75就可以体现出来，而(0.75,0.75)离(0,0)最远，所以(0，0)所起的决定作用就要小一些，公式中系数为(1-u)(1-v)=0.25×0.25也体现出了这一特点。算法步骤详述：\n假设原始图像大小为size=m×n，其中m与n分别是原始图像的行数与列数。若图像的缩放因子是t(t\u0026gt;0)，则目标图像的大小size=t×m×t×n。对于目标图像的某个像素点P(x，y)通过P*1/t可得到对应的原始图像坐标P’( x1，y1),其中x1=x/t，y1=y/t，由于x1，y1都不是整数所以并不存在这样的点，这样可以找出与它相邻的四个点的灰度f1、f2、f3、f4，使用双线性插值算法就可以得到这个像素点P’(x1，y1)的灰度，也就是像素点P(x，y)的灰度。\n一个完整的双线性插值算法可描述如下：\n通过原始图像和比例因子得到新图像的大小，并创建新图像。 由新图像的某个像素(x，y)映射到原始图像(x’,y’)处。 对x’,y’取整得到(xx，yy)并得到(xx，yy)、(xx+1，yy)、(xx，yy+1)和(xx+1，yy+1)的值。 利用双线性插值得到像素点(x,y)的值并写回新图像。 重复步骤2直到新图像的所有像素写完。 ","date":"2020-01-26T22:24:10Z","permalink":"https://blog.bugxch.top/p/%E8%BD%AC%E8%BD%BD%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC%E7%AE%80%E4%BB%8B/","title":"[转载]双线性插值简介"},{"content":"与tensorflow模型与caffe模型不同，当前的pytorch没有官方的直观查看网络结构的工具，google了下pytorch的网络解析的方法，发现可以将pytorch的model转换成为events文件使用tensorboard查看，记录之。\n安装插件 TensorboardX，TensorboardX支持scalar, image, figure, histogram, audio, text, graph, onnx_graph, embedding, pr_curve and videosummaries等不同的可视化展示方式，具体介绍移步至项目Github 观看详情。使用下面的命令安装\n1 pip install tensorboardX 安装tensorboard，参考命令\n1 pip install tensorboard 具体过程 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #-*-coding:utf-8-*- import torch import torchvision from torch.autograd import Variable from tensorboardX import SummaryWriter # 模拟输入数据 input_data = Variable(torch.rand(16, 3, 224, 224)) # 从torchvision中导入已有模型 net = torchvision.models.resnet18() # 声明writer对象，保存的文件夹 writer = SummaryWriter(log_dir=\u0026#39;./log\u0026#39;, comment=\u0026#39;resnet18\u0026#39;) with writer: writer.add_graph(net, (input_data,)) 该代码中14行声明一个writer对象，分别表示events存放的目录，comment表示事件的title，然后使用如下的方式打开tensorboard\n1 tensorboard --logpath=D:\\log --port=6006 然后按照命令行提示打开即可。\n参考链接 PyTorch 使用 TensorboardX 进行网络可视化-PyTorch 中文网 Pytorch使用tensorboardX可视化。超详细！！！ - 简书 torch.utils.tensorboard — PyTorch master documentation ","date":"2019-12-06T21:53:20Z","permalink":"https://blog.bugxch.top/p/tensorboad%E6%9F%A5%E7%9C%8Bpytorch%E6%A8%A1%E5%9E%8B/","title":"Tensorboad查看pytorch模型"},{"content":"探索了很多遍，下面是我使用calibre的转换书籍功能重新排版书籍的最佳参数，特此记录，这个适用于kindle oasis 2，仅供参考。\n设置输出格式（此处选择AZW3），基础文字大小，以及行高 设置段落的缩进与之间的空行间距 选择适配的设备型号 最终使用kindle的最小行距显示，排版效果如下\n","date":"2019-05-04T08:31:00Z","permalink":"https://blog.bugxch.top/p/kindle%E6%9C%80%E4%BD%B3%E6%8E%92%E7%89%88%E8%AE%B0%E5%BD%95/","title":"Kindle最佳排版记录"},{"content":"如何给manjaro添加开机启动脚本。\n前段时间折腾小黑T450安装了Manjaro系统，又安装了sublime text 3，顺便参考Installation Package Control指导安装了package control插件，但是很不幸国内的package control页面已经被屏蔽了。因此，需要给package control设置代理，根据《SublimeText 安装 PackageControl 及 HTTP 代理配置 - Tony的技术笔记 - SegmentFault 思否》我看到一个方法是配置完设置之后，在shell中运行的命令\n1 polipo socksParentProxy=localhost:1080 设置一下sublime text 3中的package control的代理就可以使用它安装插件了。但是每次开机之后都要敲入上面的命令，非常麻烦。\n安装过程 参考官方资料，按照如下的步骤设置了自动启动脚本\n新增一个autostart的桌面启动项，这一项开机后会随桌面启动\n1 2 cd ~/.config/autostart touch AutoExec.desktop 在创建的AutoExec.desktop中写入如下的内容\n1 2 3 4 5 6 [Desktop Entry] Type=Application Exec=\u0026#34;/etc/AutoExec.sh\u0026#34; Terminal=yes Name=AutoExec X-GNOME-Autostart-enabled=true 创建开机自启动脚本/etc/AutoExec.sh，\n1 2 sudo touch /etc/AutoExec.sh chmod +x /etc/AutoExec.sh 写入如下的内容\n1 polipo socksParentProxy=localhost:1080 \u0026amp; 即在开机之后的后台自动启动。\n参考资料 systemd - ArchWiki，官方资料 [Solved] Execute script on startup / Newbie Corner / Arch Linux Forums，论坛资料 SublimeText 安装 PackageControl 及 HTTP 代理配置 - Tony的技术笔记 - SegmentFault 思否 ","date":"2019-02-24T20:48:23Z","permalink":"https://blog.bugxch.top/p/manjaro%E6%B7%BB%E5%8A%A0%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/","title":"Manjaro添加开机启动脚本"},{"content":"去年年底安装将我的Thinkpad T450的双系统中的opensuse换成了Manjaro，折腾安装了下CUDA，是为记录。\n基本安装 NVIDIA显卡安装 Manjaro系统安装显卡比较简单，它有一个命令\n1 sudo mhwd -a [pci or usb connection] [free or nonfree drivers] 0300 其中\n-a: 自动检测和安装合适的显卡驱动 [pci or usb]: 为通过PCI或者USB连接的设置安装驱动 [free or nonfree]: 安装免费或者非免费的驱动 0300: 确认即将安装的显卡的驱动 我们要安装英伟达的驱动，只要使用下面的一行命令即可搞定\n1 sudo mhwd -a pci nonfree 0300 等待安装结束，使用如下命令查看是否已经安装完成\n1 nvidia-smi 我的显示结果如下\n从上图可知，我的显卡型号是GeForce 940M，显卡的驱动版本是415.27。\nCUDA安装 安装命令 Manjaro的CUDA安装也是异常简单，一行命令搞定\n1 sudo pacman -S cuda cudnn 这行命令可能需要花费一些时间，请耐心等待。\n验证安装 完成之后，我们进入cuda的安装路径，我的路径是/opt/cuda，你可以使用下面的命令将CUDA的示例程序拷贝到你的用户主目录下，之后编译程序\n1 2 3 cp -r /opt/cuda/samples ~ cd ~/samples make 此时就使用nvcc编译器开始编译CUDA的sample程序，这个花费时间更长，应该在半小时左右，等待编译结束，使用下面的命令验证是否成功\n1 2 cd ~/samples/bin/x86_64/linux/release ./deviceQuery 在窗口中查看最后一行的结果是否为pass，如果是则表示CUDA安装成功。\n双显卡配置 我的电脑有两个显卡，一个是intel的集成显卡，一个是NVIDIA的独显。\n安装显卡切换程序 Manjaro的双显卡配置有点问题，Bumblebee还是有点问题，使用下面的命令重新安装\n1 2 3 4 5 6 7 8 9 10 11 # 依赖 sudo pacman -S virtualgl lib32-virtualgl lib32-primus primus # 安装双显卡切换程序bumblebee sudo mhwd -f -i pci video-hybrid-intel-nvidia-bumblebee # 允许服务 sudo systemctl enable bumblebeed # 添加用户 sudo gpasswd -a $USER bumblebee 为了防止重启之后不能进入登录界面，需要做如下的配置\n打开 /etc/default/grub 找到并且改为：GRUB_CMLINE_LINUX_DEFAULT=\u0026ldquo;quiet acpi_osi=! acpi_osi=Linux acpi_osi=’Windows 2015’ pcie_port_pm=off resume=\u0026hellip;\u0026rdquo; 运行sudo update-grub，重启 测试显卡性能 使用下面的shell命令安装显卡测试程序\n1 2 3 4 5 6 7 8 9 10 # 安装测试软件 sudo pacman -S mesa-demos # 集成显卡性能 glxgears -info # 独显性能 optirun glxgears -info # 或者 primusrun glxgears -info 需要注意的是，之后运行的所有程序，如果需要使用独立显卡，需要在命令的前面加上optirun或者primusrun的前缀。\n1 2 3 4 5 6 7 8 9 10 11 # 打开nvida面板 optirun -b none nvidia-settings -c :8 # 不依赖Bumblebee来使用CUDA sudo tee /proc/acpi/bbswitch \u0026lt;\u0026lt;\u0026lt; \u0026#39;ON\u0026#39; # 使用完CUDA 停止NVIDIA显卡 sudo rmmod nvidia_uvm nvidia \u0026amp;\u0026amp; sudo tee /proc/acpi/bbswitch \u0026lt;\u0026lt;\u0026lt; OFF inxi -G # 查看显卡情况 optirun nvidia-smi # 查看CPU情况 参考资料 Installing Tensorflow 1.6.0 + GPU on Manjaro Linux – Dr. Joe Logan – Medium Manjaro折腾笔记：我的数据科学环境搭建之路 - 杨睿 - 博客园 leblancfg.com – Notes on installing CUDA, CuDNN and Tensorflow on Manjaro Configure Graphics Cards - Manjaro Linux ","date":"2019-02-09T19:02:24Z","permalink":"https://blog.bugxch.top/p/manjaro%E5%AE%89%E8%A3%85cuda%E6%95%99%E7%A8%8B/","title":"Manjaro安装CUDA教程"},{"content":"Tensorflow中的padding有两种方式，其中的SAME方式比较特殊，可能产生非对称pad的情况，之前在验证一个tensorflow的网络时踩到这个坑。\nTensorflow的计算公式 二维卷积接口 1 2 3 tf.nn.conv2d( input, filters, strides, padding, data_format=\u0026#39;NHWC\u0026#39;, dilations=None, name=None ) padding计算公式 需要注意padding的配置，如果是字符串就有SAME和VALID两种配置，如果是数字list就明确表明padding在各个维度的数量。\n首先，padding如果表示确切的数字，其维度是input维度的2倍，因为每个维度两个边需要补pad，比如宽度的左边和右边，高度的上边和下边，但是tensorflow中不会给N维度以及C维度补pad，仅仅在W和H维度补pad，因此对于NHWC，padding =[[0, 0], [pad_top, pad_bottom], [pad_left, pad_right], [0, 0]] ，对于NCHW的pad的顺序换过来。\n然后，如果输入的是字符串选项，补的pad都可以映射到padding这个参数上，\nVALID模式表示不在任何维度补pad，等价于padding =[[0, 0], [0, 0], [0, 0], [0, 0]]；\nSAME模式表示在stride的尺度下，Wo与Wi保持在stride$S$下保持一致（以宽度维度为例），需要满足如下关系 $$ W_{o}=\\left\\lceil\\frac{W_{i}}{S}\\right\\rceil $$ 我们知道如果dilation = 1，那么在某个维度上，卷积的输出宽度$W_i$、输出宽度$W_o$和步长$S$，在没有pad的情况下，满足如下的关系式 $$ W o=\\left\\lfloor\\frac{W i-W_{k}}{S}\\right\\rfloor+1 $$ 我们以补最小程度的$P_a$为基准，于是有关系式 $$ W o=\\frac{W i+P_{a}-W_{k}}{S}+1 $$ 反推过来得到 $$ P_{a}=\\left(W_{o}-1\\right) S+W_{k}-W_{i} $$ 这是需要补的总的pad，tensorflow的补充pad是尽量两边对称的，\n如果$P_a$是偶数，那么两边都补$P_l = P_a/2$； 如果$P_a$是奇数，那么左边补$P_l = \\lfloor{P_a/2}\\rfloor$，右边是$P_r = P_a-P_l$。 参考如下的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 inputH, inputW = 7, 8 strideH, strideW = 3, 3 filterH = 4 filterW = 4 inputC = 16 outputC = 3 inputData = np.ones([1,inputH,inputW,inputC]) # format [N, H, W, C] filterData = np.float16(np.ones([filterH, filterW, inputC, outputC]) - 0.33) strides = (1, strideH, strideW, 1) convOutputSame = tf.nn.conv2d(inputData, filterData, strides, padding=\u0026#39;SAME\u0026#39;) convOutput = tf.nn.conv2d(inputData, filterData, strides, padding=[[0,0],[1,2],[1,1],[0,0]]) # padded input data print(\u0026#34;output1, \u0026#34;, convOutputSame) print(\u0026#34;output2, \u0026#34;, convOutput) print(\u0026#34;Sum of a - b is \u0026#34;, np.sum(np.square(convOutputSame - convOutput))) 计算结果是\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 output1, tf.Tensor( [[[[ 96.46875 96.46875 96.46875] [128.625 128.625 128.625 ] [ 96.46875 96.46875 96.46875]] [[128.625 128.625 128.625 ] [171.5 171.5 171.5 ] [128.625 128.625 128.625 ]] [[ 64.3125 64.3125 64.3125 ] [ 85.75 85.75 85.75 ]￼ [ 64.3125 64.3125 64.3125 ]]]]) output2, tf.Tensor( [[[[ 96.46875 96.46875 96.46875] [128.625 128.625 128.625 ] [ 96.46875 96.46875 96.46875]] [[128.625 128.625 128.625 ] [171.5 171.5 171.5 ] [128.625 128.625 128.625 ]] [[ 64.3125 64.3125 64.3125 ] [ 85.75 85.75 85.75 ] [ 64.3125 64.3125 64.3125 ]]]], shape=(1, 3, 3, 3), dtype=float64) Sum of a - b is 0.0 ONNX计算公式 onnx的接口，参考IR定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 std::function\u0026lt;void(OpSchema\u0026amp;)\u0026gt; ConvOpSchemaGenerator(const char* filter_desc) { return [=](OpSchema\u0026amp; schema) { std::string doc = R\u0026#34;DOC( The convolution operator consumes an input tensor and {filter_desc}, and computes the output.)DOC\u0026#34;; ReplaceAll(doc, \u0026#34;{filter_desc}\u0026#34;, filter_desc); schema.SetDoc(doc); schema.Input( 0, \u0026#34;X\u0026#34;, \u0026#34;Input data tensor from previous layer; \u0026#34; \u0026#34;has size (N x C x H x W), where N is the batch size, \u0026#34; \u0026#34;C is the number of channels, and H and W are the \u0026#34; \u0026#34;height and width. Note that this is for the 2D image. \u0026#34; \u0026#34;Otherwise the size is (N x C x D1 x D2 ... x Dn). \u0026#34; \u0026#34;Optionally, if dimension denotation is \u0026#34; \u0026#34;in effect, the operation expects input data tensor \u0026#34; \u0026#34;to arrive with the dimension denotation of [DATA_BATCH, \u0026#34; \u0026#34;DATA_CHANNEL, DATA_FEATURE, DATA_FEATURE ...].\u0026#34;, \u0026#34;T\u0026#34;); schema.Input( 1, \u0026#34;W\u0026#34;, \u0026#34;The weight tensor that will be used in the \u0026#34; \u0026#34;convolutions; has size (M x C/group x kH x kW), where C \u0026#34; \u0026#34;is the number of channels, and kH and kW are the \u0026#34; \u0026#34;height and width of the kernel, and M is the number \u0026#34; \u0026#34;of feature maps. For more than 2 dimensions, the \u0026#34; \u0026#34;kernel shape will be (M x C/group x k1 x k2 x ... x kn), \u0026#34; \u0026#34;where (k1 x k2 x ... kn) is the dimension of the kernel. \u0026#34; \u0026#34;Optionally, if dimension denotation is in effect, \u0026#34; \u0026#34;the operation expects the weight tensor to arrive \u0026#34; \u0026#34;with the dimension denotation of [FILTER_OUT_CHANNEL, \u0026#34; \u0026#34;FILTER_IN_CHANNEL, FILTER_SPATIAL, FILTER_SPATIAL ...]. \u0026#34; \u0026#34;X.shape[1] == (W.shape[1] * group) == C \u0026#34; \u0026#34;(assuming zero based indices for the shape array). \u0026#34; \u0026#34;Or in other words FILTER_IN_CHANNEL should be equal to DATA_CHANNEL. \u0026#34;, \u0026#34;T\u0026#34;); schema.Input( 2, \u0026#34;B\u0026#34;, \u0026#34;Optional 1D bias to be added to the convolution, has size of M.\u0026#34;, \u0026#34;T\u0026#34;, OpSchema::Optional); schema.Output( 0, \u0026#34;Y\u0026#34;, \u0026#34;Output data tensor that contains the result of the \u0026#34; \u0026#34;convolution. The output dimensions are functions \u0026#34; \u0026#34;of the kernel size, stride size, and pad lengths.\u0026#34;, \u0026#34;T\u0026#34;); schema.TypeConstraint( \u0026#34;T\u0026#34;, {\u0026#34;tensor(float16)\u0026#34;, \u0026#34;tensor(float)\u0026#34;, \u0026#34;tensor(double)\u0026#34;}, \u0026#34;Constrain input and output types to float tensors.\u0026#34;); schema.Attr( \u0026#34;kernel_shape\u0026#34;, \u0026#34;The shape of the convolution kernel. If not present, should be inferred from input W.\u0026#34;, AttributeProto::INTS, OPTIONAL); schema.Attr( \u0026#34;dilations\u0026#34;, \u0026#34;dilation value along each spatial axis of the filter. If not present, the dilation defaults is 1 along each spatial axis.\u0026#34;, AttributeProto::INTS, OPTIONAL); schema.Attr( \u0026#34;strides\u0026#34;, \u0026#34;Stride along each spatial axis. If not present, the stride defaults is 1 along each spatial axis.\u0026#34;, AttributeProto::INTS, OPTIONAL); schema.Attr( \u0026#34;auto_pad\u0026#34;, auto_pad_doc, AttributeProto::STRING, std::string(\u0026#34;NOTSET\u0026#34;)); schema.Attr( \u0026#34;pads\u0026#34;, pads_doc, AttributeProto::INTS, OPTIONAL); schema.Attr( \u0026#34;group\u0026#34;, \u0026#34;number of groups input channels and output channels are divided into.\u0026#34;, AttributeProto::INT, static_cast\u0026lt;int64_t\u0026gt;(1)); schema.TypeAndShapeInferenceFunction([](InferenceContext\u0026amp; ctx) { propagateElemTypeFromInputToOutput(ctx, 0, 0); convPoolShapeInference(ctx, true, false, 0, 1); }); }; } 需要注意上面的auto_pad选项，与tensorflow类似有3个选项\nNOTSET，同tensorflow的VALID\nSAME_UPPER 或者SAME_LOWER，这里的内容可以参考onnx文件defs.cc中的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 std::vector\u0026lt;int64_t\u0026gt; pads; if (getRepeatedAttribute(ctx, \u0026#34;pads\u0026#34;, pads)) { if (pads.size() != n_input_dims * 2) { fail_shape_inference(\u0026#34;Attribute pads has incorrect size\u0026#34;); } } else { pads.assign(n_input_dims * 2, 0); // pads的size是输入维度的2倍 const auto* auto_pad_attr = ctx.getAttribute(\u0026#34;auto_pad\u0026#34;); if ((nullptr != auto_pad_attr) \u0026amp;\u0026amp; (auto_pad_attr-\u0026gt;s() != \u0026#34;VALID\u0026#34;)) { // 如果pad mode是SAME_UPPER或者SAME_LOWER则进入该分支 int input_dims_size = static_cast\u0026lt;int\u0026gt;(n_input_dims); for (int i = 0; i \u0026lt; input_dims_size; ++i) { // 计算每个axis的pads int64_t residual = 0; int64_t stride = strides[i]; if (stride \u0026gt; 1) { // 如果stride == 1，那么total_pad就是Wk - Stride = Wk - 1 if (!input_shape.dim(2 + i).has_dim_value()) { continue; } residual = input_shape.dim(2 + i).dim_value(); while (residual \u0026gt;= stride) { residual -= stride; } } int64_t total_pad = residual == 0 ? effective_kernel_shape[i] - stride : effective_kernel_shape[i] - residual; // effective_kernel_shape = Wk if (total_pad \u0026lt; 0) total_pad = 0; int64_t half_pad_small = total_pad \u0026gt;\u0026gt; 1; int64_t half_pad_big = total_pad - half_pad_small; if (auto_pad_attr-\u0026gt;s() == \u0026#34;SAME_UPPER\u0026#34;) { // pad mode is here pads[i] = half_pad_small; pads[i + input_dims_size] = half_pad_big; } else if (auto_pad_attr-\u0026gt;s() == \u0026#34;SAME_LOWER\u0026#34;) { pads[i] = half_pad_big; pads[i + input_dims_size] = half_pad_small; } } } } 上面的代码里面最难理解14~23行，其实这里计算total_pad就是tensorflow中的$P_a$，以上面的公式，做更进一步的推导， $$ \\begin{equation} \\begin{aligned} P_{a}\u0026amp;=\\left(W_{o}-1\\right) S+W_{k}-W_{i}\\ \u0026amp;=(\\left\\lceil\\frac{W_{i}}{S}\\right\\rceil - 1)S+W_{k}-W_{i}\\ \\end{aligned} \\end{equation} $$\n下面的分析有两种情况，对应代码第23行，\n如果$W_i$是$S$的整数倍，那么$W_i = nS$，带入上面的公式有$P_a = W_k - S$； 如果$W_i$不是$S$的整数倍，那么$W_i = nS+m, m \\gt 0$，带入上面的公式有$P_a = W_k - m$，这个$m$就是$W_i$被Stride相除之后的余数，即代码中的residual。 SAME_UPPER和SAME_LOWER对应$P_a$是奇数的情况，如果是偶数，结果一样，如果是奇数，那么SAME_UPPER放小半部分$\\lfloor{P_a/2}\\rfloor$，SAME_LOWER放大半部分$P_a - \\lfloor{P_a/2}\\rfloor$。\n举例 在python - What is the difference between \u0026lsquo;SAME\u0026rsquo; and \u0026lsquo;VALID\u0026rsquo; padding in tf.nn.max_pool of tensorflow? - Stack Overflow上有一个比较具体的例子，可以看到，使用SAME模式可以使得stride刚好完整取完所有的input而不会有剩余或者短缺。\nVALID 模式\n1 2 3 inputs: 1 2 3 4 5 6 7 8 9 10 11 (12 13) |________________| dropped |_________________| SAME模式\n1 2 3 4 5 pad| |pad inputs: 0 |1 2 3 4 5 6 7 8 9 10 11 12 13|0 0 |________________| |_________________| |________________| 在这个例子中$W_i = 13, W_k = 6, S = 5$。\n参考资料 TensorFlow中CNN的两种padding方式“SAME”和“VALID” - wuzqChom的博客 - CSDN博客 python - What is the difference between \u0026lsquo;SAME\u0026rsquo; and \u0026lsquo;VALID\u0026rsquo; padding in tf.nn.max_pool of tensorflow? - Stack Overflow What does the \u0026lsquo;same\u0026rsquo; padding parameter in convolution mean in TensorFlow? - Quora ","date":"2018-11-14T07:09:58Z","permalink":"https://blog.bugxch.top/p/tf%E4%B8%AD%E7%9A%84padding%E6%96%B9%E5%BC%8Fsame%E5%92%8Cvalid%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/","title":"tf中的padding方式SAME和VALID有什么区别?"},{"content":"在日常工作中，需要非常频繁地与数据打交道，将数据保存下来做数据比对，因此需要总结下python下的文本和数据的读写操作。\npython文件读写 基础知识 在python中使用下面的语句打开一个文本\n1 f = open(\u0026#39;workfile\u0026#39;, \u0026#39;w\u0026#39;) 创建了一个文件对象f。其中的\n读写方式。w表示文本workfile的创建方式为写入，当然还有其他的读写方式，可以参考如下的表格 \u0026ldquo;r\u0026rdquo; read: Open file for input operations. The file must exist. \u0026ldquo;w\u0026rdquo; write: Create an empty file for output operations. If a file with the same name already exists, its contents are discarded and the file is treated as a new empty file. \u0026ldquo;a\u0026rdquo; append: Open file for output at the end of a file. Output operations always write data at the end of the file, expanding it. Repositioning operations (fseek, fsetpos, rewind) are ignored. The file is created if it does not exist. \u0026ldquo;r+\u0026rdquo; read/update: Open a file for update (both for input and output). The file must exist. \u0026ldquo;w+\u0026rdquo; write/update: Create an empty file and open it for update (both for input and output). If a file with the same name already exists its contents are discarded and the file is treated as a new empty file. \u0026ldquo;a+\u0026rdquo; append/update: Open a file for update (both for input and output) with all output operations writing data at the end of the file. Repositioning operations (fseek, fsetpos, rewind) affects the next input operations, but output operations move the position back to the end of file. The file is created if it does not exist. 编码方式。一般而言，默认读写文件使用的是字符串，字符串的编码方式视平台而定，也可以通过参数b来指定读写的数据为二进制文件，该模式仅仅用于没有字符的数据。 上面的基本语句有一个更优雅的语句方式\n1 2 with open(\u0026#39;workfile\u0026#39;) as f: read_data = f.read() 这样写的好处是文件可以自动关闭，即便有异常抛出也可以。\npython文件读写 这一段介绍python本身的文件读写功能。\n文本文件 以之前的基础知识为例，读取文本文件很简单，使用文件对象的方法有\nread，直接读取文本的所有内容，也可以使用f.read(size)读取size字节的数据 1 2 3 with open(\u0026#39;workfile\u0026#39;) as f: read_data = f.read() print(read_data) readline，逐行读取文件中每一行 1 2 3 with open(\u0026#39;workfile\u0026#39;) as f: first_line = f.readline() sec_line = f.readline() 上面的语句依次读取文件的每一行。\n遍历文本的每一行 1 2 3 with open(\u0026#39;files\\stringdata.txt\u0026#39;,\u0026#39;r\u0026#39;) as f: for line in f: print(line) 这个会依次读取文件的每一行\n将文本中的每一行读入一个列表中，列表的每个元素是文本的一行 1 2 3 with open(\u0026#39;files\\stringdata.txt\u0026#39;,\u0026#39;r\u0026#39;) as f: s = f.readlines() print(s) 写入字符文本，仅仅需要一个函数write 1 2 3 with open(\u0026#39;files\\stringdata.txt\u0026#39;,\u0026#39;w\u0026#39;) as f: f.write(\u0026#34;hello world\\n\u0026#34;) f.write(str(10.255616)) 文本内容是\n1 2 hello world 10.255616 二进制文件 二进制文件的读写和文本文件读写的方法类似，最大的区别是打开的选项必须要加一个b。\n写入二进制文件 1 2 with open(filepath, \u0026#39;wb\u0026#39;) as f: f.write(output) 这个脚本将output的数字保存到filepath对应的文件里面。\n读取二进制文件 1 2 with open(filepath, \u0026#39;rb\u0026#39;) as f: content = f.read() 下面是读写二进制文件的一个例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import numpy as np def save_bin(output,filepath): with open(filepath, \u0026#39;wb\u0026#39;) as f: f.write(output) return def load_bin(filepath, dtype=np.float32): with open(filepath, \u0026#39;rb\u0026#39;) as f: content = f.read() data = np.frombuffer(content,dtype=dtype) return data data_out = np.random.randn(1,10) data_out = np.float32(data_out) print(data_out) save_bin(data_out, \u0026#39;./datawrite.bin\u0026#39;) data_in = load_bin(\u0026#39;./datawrite.bin\u0026#39;, np.float32) print(data_in) 其中使用numpy模块生成正态分布的10个数字，并且以float32的格式保存在文件里面，之后再读取出来。需要注意的是，读取和写入文件的数据格式必须保持一致，比如float16写入就float16数据格式读出，否则读出来的数据是错误的。我在ipython环境下随机运行的结果如下\n1 2 3 4 5 In [44]: runfile(\u0026#39;C:/Users/h00437182/Desktop/python/readfile.py\u0026#39;, wdir=\u0026#39;C:/Users/h00437182/Desktop/python\u0026#39;) [[ 0.5902766 0.19589928 0.12194731 -0.17657255 -0.4276924 -0.3527161 -1.3733053 -0.7128385 -1.1449672 1.4563532 ]] [ 0.5902766 0.19589928 0.12194731 -0.17657255 -0.4276924 -0.3527161 -1.3733053 -0.7128385 -1.1449672 1.4563532 ] numpy文件读写 numpy是python的一个数据处理的模块，它的文件读写功能使用起来更加强大和便捷。在日常工作中，常常需要比对数据，因此有必要将数据保存成txt文档进行比对，此处的文件读写都是围绕数据展开。将数据保存在文本文件中是日常工作的一个大痛点和需求，下面的命令就可以实现这样的目标。\nnumpy的数据读写是成对使用的。\nsavetxt和loadtxt\n这两个命令只适用于一维或者二维数组，常见的使用格式如下\n1 2 np.loadtxt(filename, dtype=int, delimiter=\u0026#39; \u0026#39;) np.savetxt(filename, data, fmt=\u0026#34;%d\u0026#34;,delimiter=\u0026#39; \u0026#39;) 比如，下面的脚本，我们复用之前的脚本生成10个随机数，之后以小数点后4位的精度保留，之后再读出来\n1 2 3 4 5 6 7 8 9 import numpy as np data_out = np.random.randn(1,10) print(data_out) np.savetxt(\u0026#39;data.txt\u0026#39;,data_out, fmt=\u0026#34;%.4f\u0026#34;, delimiter=\u0026#39; \u0026#39;) dataout = np.loadtxt(\u0026#39;data.txt\u0026#39;, delimiter=\u0026#39; \u0026#39;) print(dataout) 文件data.txt中的数据是\n1 1.9229 -1.0319 0.0624 0.6372 -0.4520 0.7549 -1.6933 -0.2295 1.4575 -0.7399 tofile和fromfile\n这两个命令的说明如下\n1 2 ndarray.tofile(fid, sep=\u0026#34;\u0026#34;, format=\u0026#34;%s\u0026#34;) numpy.fromfile(file, dtype=float, count=-1, sep=\u0026#39;\u0026#39;) 需要注意的是，使用fromfile读出的文件的数据是一维的，需要知道数据的维度才能恢复数据本来的样子，参考如下的用例\n1 2 3 4 5 6 7 8 9 import numpy as np data_out = np.random.randn(1,10) data_out = np.float64(data_out) print(data_out) data_out.tofile(\u0026#39;data.bin\u0026#39;) dataout = np.fromfile(\u0026#39;data.bin\u0026#39;, dtype=np.float64) print(dataout) save和load\n这一对命令可以保存原始的数据，就是原封不动保存之前的narray的信息，使用load之后得到的数据就是原来的数据，参考如下的例子\n1 2 3 4 5 6 7 8 import numpy as np data_out = np.random.randn(2,10) print(data_out) np.save(\u0026#39;data.npy\u0026#39;, data_out) dataout = np.load(\u0026#39;data.npy\u0026#39;) print(dataout) 这个脚本的结果如下所示\n1 2 3 4 5 6 7 8 9 runfile(\u0026#39;C:/Users/h00437182/Desktop/python/readfile.py\u0026#39;, wdir=\u0026#39;C:/Users/h00437182/Desktop/python\u0026#39;) [[ 0.768138 1.09159732 1.45133552 -1.796178 1.19846175 -0.40864606 0.73694781 -0.87850709 -2.29957767 -1.2550539 ] [-0.38308247 0.08059661 -1.84944623 -0.43883914 1.88381452 1.0455034 -0.01678215 0.95006648 0.06723308 -0.6050553 ]] [[ 0.768138 1.09159732 1.45133552 -1.796178 1.19846175 -0.40864606 0.73694781 -0.87850709 -2.29957767 -1.2550539 ] [-0.38308247 0.08059661 -1.84944623 -0.43883914 1.88381452 1.0455034 -0.01678215 0.95006648 0.06723308 -0.6050553 ]] 完美保存数据的精度和维度信息。\n参考资料 7. Input and Output — Python 3.7.1 documentation，python官方介绍输入输出的文档 Reading and Writing Files in Python (article) - DataCamp，datamap的二进制文本读取 python - How to save and load numpy.array() data properly? - Stack Overflow ","date":"2018-11-08T07:33:12Z","permalink":"https://blog.bugxch.top/p/python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","title":"python文件操作"},{"content":"I love shell.\n在很多shell脚本中，经常可以看到下面的语句\n1 2 rootDir=$(cd $(dirname $0); pwd) ... 这个语句的作用是获取shell脚本所在目录的绝对路径，这个语句怎么理解？为什么不直接用pwd来获取当前路径呢？\n语句解释 参考explainshell.com - cd $(dirname $0); pwd的解释，拆解如下。\ndirname的功能是去掉文件路径名中的从右往左数的第一个/及其之后的所有文字，查看dirname的help信息可以看到如下的例子\n1 2 3 dirname /usr/bin/ -\u0026gt; \u0026#34;/usr\u0026#34; dirname dir1/str dir2/str -\u0026gt; \u0026#34;dir1\u0026#34; followed by \u0026#34;dir2\u0026#34; dirname stdio.h -\u0026gt; \u0026#34;.\u0026#34; $0，这是bash shell脚本中的位置参数，用来表明输入到命令行中的命令本身。其余的还有$1，$2等等，分别表示输入到命令行中的命令后面带有的第一个参数和第二个参数，依次类推。比如下面的命令\n1 bash test9.sh 10 9 其中的$0就是test9.sh，10和9分别是$1和$2。\npwd，这个命令已经很熟悉了，就是打印当前的绝对路径。\n有了上面的分析，那整个命令怎么理解呢？举例说明，假如我们有如下的脚本test.sh在目录~/DTS/code下\n1 2 3 #/bin/bash rootDir=$(cd $(dirname $0); pwd) echo \u0026#34;rootDir $rootDir\u0026#34; 该脚本的功能就是寻找脚本所在目录下的所有的.cc文件。我们在命令行中运行该命令./test.sh，输出的结果是\n1 2 bugxch@opensuse:~/DTS/code$ ./test.sh rootDir /home/bugxch/DTS/code 请留意运行该脚本的时候的几个关键要素\n调用脚本的路径。我们在目录~/DTS/code/下调用该脚本，也就是当前目录了。\n调用脚本的命令。我们的命令是./test.sh.\n结合上面的两条，此时$(dirname $0)的结果就是.，那么cd $(dirname $0)就是cd .，也就是切换命令到~/DTS/code，之后运行pwd，此时获得的就是脚本所在的绝对路径了。\n为什么不用pwd？ 请注意以下的基本事实\n调用shell脚本，就是在调用脚本的当前目录下，逐行执行脚本中的每一个命令。\n如果我们修改上面的脚本如下\n1 2 3 4 #/bin/bash rootDir=$(cd $(dirname $0); pwd) echo \u0026#34;rootDir $rootDir\u0026#34; echo \u0026#34;pwd $pwd\u0026#34; 并且在~/DTS下输入命令code/test.sh来运行这个脚本，输出结果如下\n1 2 3 bugxch@opensuse:~/DTS$ code/test.sh rootDir /home/bugxch/DTS/code pwd /home/bugxch/DTS 第2个pwd不是脚本所在的目录，而是我们输入命令的目录。正如那个基本事实所示，在该目录下运行该脚本相当于逐行敲入脚本中每一句之后执行，所以在~/DTS调用脚本中的pwd，就相当于在该目录下敲入pwd，因此结果就是当前路径。\n之所以不能直接使用pwd获取脚本所在目录，是因为如果在脚本目录之外调用该脚本，返回的是调用命令所在的目录而不是脚本所在目录。\n","date":"2018-11-03T20:47:24Z","permalink":"https://blog.bugxch.top/p/%5Ccd-%5Cdirname-0pwd%E7%9A%84%E8%A7%A3%E9%87%8A/","title":"\\$(cd \\$(dirname $0);pwd)的解释"},{"content":"最近的工作中，在求算子softamx时需要使用牛顿迭代法，记录下。\n基本思想 牛顿迭代法的具体内容可以参考 牛顿迭代法的维基百科页面。\n几何直觉 观察本文上面的图片，凭借我们的直觉可以发现，如果在函数$f(x)$的根附近的点$x_n$上画一条切线，这条切线与$x$轴的交点$x_{n+1}$比$x_n$更加接近方程的根。如果在$x_{n+1}$这个点继续使用上一次的方法，再画一条切线，可以想见新的切线与$x$轴的交点肯定比$x_{n+1}$更接近根，如此迭代就会越来越逼近方程的根。下面这幅图表示的更清晰\n所以，据此可以推导出如下的方程， $$ \\frac{0 - f(x_n)}{x_{n+1} - x_n} = f\u0026rsquo;(x_n) $$ 进一步化简可以得到， $$ x_{n+1}=x_{n}-{\\frac {f(x_{n})}{f\u0026rsquo;(x_{n})}} $$ 这就是牛顿迭代法的基本公式。\n但是牛顿迭代法不一定总是有效，已有证明牛顿迭代法的二次收敛必须满足以下条件：\n$f\u0026rsquo;(x)\\neq 0$; 对于所有$x\\in I$，其中$I$为区间$[α − r, α + r]$，且$x_{0}$在区间其中$I$内，即$ r\\geqslant \\left|a-x_{0}\\right|$的，对于所有$x\\in I$，$f\u0026rsquo;\u0026rsquo;(x)$是连续的; $x_{0}$足够接近根 α。 所以使用牛顿迭代法，首先需要选择离方程的根足够近的起点，而且这个起点的切线斜率不能为0。\n公式推导 牛顿迭代法的另一种推导方式是使用泰勒展开式 $$ f(x)=f(x_0)+f^\\prime(x_0)(x-x_0)+\\frac{1}{2}f^{\\prime\\prime}(x_0)(x-x_0)^2+\\dots + \\frac{1}{n!}f^{(n)}(x_0)(x-x_0)^n + o(x-x_0)^n $$ 使用一阶展开近似可以得到 $$ f(x)=f(x_0)+f^\\prime(x_0)(x-x_0) $$ 化简就可以得到之前的方程(2)。\n牛顿迭代法求极值 使用牛顿迭代法可以求函数的极值，通过迭代的方法求方程$f(x)$的极值。根据微积分原理，令$f\u0026rsquo;(x) = 0$的$x$就是函数的极值所在，同样利用泰勒公式展开到二阶，有 $$ f(x)=f(x_0)+f^\\prime(x_0)(x-x_0)+\\frac{1}{2}f^{\\prime\\prime}(x_0)(x-x_0)^2 $$ 两边同时对$x$求导数，并令其为0，我们就能得到 $$ f^\\prime(x_0)+f^{\\prime\\prime}(x_0)(x-x_0) = 0 $$ 同样可以得到 $$ x=x_0-{\\frac {f\u0026rsquo;\u0026rsquo;(x_{0})}{f\u0026rsquo;(x_{0})}} $$ 这就是牛顿迭代法求极值的理论依据。\n指令迭代 假设计算机中有求倒数的指令$y = rec(x) = 1/x$，但是精度不高，如何通过牛顿迭代法提高精度？\n可以这么想，假设我们的输入是$a$，那么我们对输入求倒数就等价于求方程$a = 1/x$的根，也就是求方程$f(x) = 1/x -a$的根，那么根据牛顿迭代法，如果我们找到一个初值$x_0$，就可以按照如下的方程来迭代 $$ x_{n+1} = x_n - \\frac{f(x_n)}{f\u0026rsquo;(x_n)}=2x_n - ax_{n}^2 $$ 而刚好这个初值就是指令使用一次之后的结果（相比随意找一个数字，这个值离根更近），即$x_0 = 1/a = rec(a)$。\n更一般的，假如\n我们利用指令$f$需要对数$a$做指令计算$f(a)$，但是该指令的精度不高，可以转化成求$f^{-1}(x) = a$得根，也就是求$g(x) = f^{-1}(x) - a$的根\n比如，假如有求一个数的自然对数的指令vln，那么可以通过计算$f(x) = e^x -a$的根计算$vln(a)$的值。\n方程举例 下面我们使用牛顿迭代法用C++的代码求解一个数的立方根，假定这个数是$a$，该问题等价于求方程$x^3 = a$的根，也就是求方程$f(x) = x^3 - a$的根。根据牛顿迭代法，可以按照如下的步骤求根\n确定迭代的终止条件，我们假设假定$|x_n^3 - a |\u0026lt; 0.00001$即停止该迭代；\n确定初始点，即选择合适的$x_0$。很明显如果$a = 0$，方程的根就是0，我们选取1作为初始点；\n确认迭代方程，根据方程(2)，我们的迭代方程是\n$$ x_{n+1} = \\frac{2x_n}{3}+\\frac{a}{3x_n^2} $$\n于是，我们的程序如下所示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;math.h\u0026gt; using namespace std; int main() { double a,x0,x1,rsl; int times = 0; cin \u0026gt;\u0026gt; a; //输入需要求解的数字 x0 = 1.0; rsl = fabs(x0*x0*x0 - a); while(rsl \u0026gt; 0.00001) { x1 = (2/3.0)*x0 + a/(3.0*x0*x0); x0 = x1; rsl = fabs(x1*x1*x1 - a); times++; cout \u0026lt;\u0026lt; times \u0026lt;\u0026lt; \u0026#34; : \u0026#34; \u0026lt;\u0026lt; \u0026#34;actual data -- \u0026#34; \u0026lt;\u0026lt; x1*x1*x1 \u0026lt;\u0026lt; \u0026#34;, result -- \u0026#34; \\ \u0026lt;\u0026lt; rsl \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \u0026#34;Final x is \u0026#34;\u0026lt;\u0026lt; x1 \u0026lt;\u0026lt; \u0026#34; and result is \u0026#34;\u0026lt;\u0026lt; x1*x1*x1 \u0026lt;\u0026lt; endl; return 0; } 使用这个程序求解-34.5的立方根结果如下\n1 2 3 4 5 6 7 8 9 1 : actual data -- -1271.41, result -- 1236.91 2 : actual data -- -392.257, result -- 357.757 3 : actual data -- -132.242, result -- 97.7418 4 : actual data -- -56.6032, result -- 22.1032 5 : actual data -- -37.2522, result -- 2.75222 6 : actual data -- -34.5672, result -- 0.0672223 7 : actual data -- -34.5, result -- 4.35659e-05 8 : actual data -- -34.5, result -- 1.83391e-11 Final x is -3.25542 and result is -34.5 可以看出通过8轮迭代就找到了-34.5的近似根-3.25542。\n","date":"2018-08-05T08:15:17Z","permalink":"https://blog.bugxch.top/p/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/","title":"牛顿迭代法"},{"content":" 烂熟于心，两三本书。\n操作系统 《计算机组成与设计：硬件/软件接口》，从硬件和软件接口的角度讲述计算机运行的基本原理，结合矩阵运算的例子，从编译器，代码，芯片内部并行处理等角度大大提高了程序运行的效率。书籍侧重从软硬件的角度如何提高程序运行的效率，降低功耗，和当前的AI core中的加速算子的工作联系紧密，值得细读。 操作系统 (豆瓣)，掌握计算机操作系统的好书 操作系统，bilibili上的一个非常不错的清华操作系统公开课 Linux C编程一站式学习，结合C语言学习 深度学习 动手学深度学习，新的深度学习框架 《神经网络与深度学习》，结合实际的代码简明扼要的代码介绍了深度学习以及卷积神经网络的核心概念，需要仔细研读，结合代码理解其中的所有关键概念。 机器学习速成课程，谷歌与2018年3月1日推出的在线机器学习速成教程。 《解析卷积神经网络—深度学习实践手册》，学习卷积神经网络的必读书目 编程基础 《C++Primer Plus》，C++学习经典书籍，我在github上建立了个仓库，专门上传本书中的各章的答案，精读 Git教程，网上找的git教程，读起来还不错 老码识途，结合C语言以及VS软件的汇编显示功能，自底层往上逐层剖析程序的运行之道，建立“猜测——实证——构建”的系统观，深入读读 跟我一起写Makefile，编写大型C/C++工程的必备技能 《利用Python进行数据分析》，掌握python中编程的基础课程，其中包括numpy/pandas等非常重要的python数据分析库 Google 开源项目风格指南，google发布的C++/python/json编程风格指南 如何成为一名黑客，学习计算机的奇技淫巧 林锐·高质量C 编程指南，不错的编程指导 《make projects with GNU》，系统学习makefile工程的好书 社科 《大国大城》，2017年初在上海书城看到的描述城市化发展的好书 奇特的一生 ，博物学家的传记 原则，桥水基金老大的生活工作之道 认识身体 (豆瓣) ","date":"2018-07-26T06:38:02Z","permalink":"https://blog.bugxch.top/p/2018%E9%98%85%E8%AF%BB%E4%B9%A6%E5%8D%95/","title":"2018阅读书单"},{"content":"读书笔记。\n这两周读了日本作者矢泽久雄写的《程序是怎么跑起来的》，解开了我这个作为通信专业的软件从业者的很多困惑，为了避免日后遗忘，将一些看了这本书之后的问题的解答记录下来。\nQ：电脑的 CPU 中包含哪些部分？各自的作用有哪些？ A：CPU 包含寄存器，控制器，时钟和运算器四种主要的结构。如下图所示\n控制器负责将内存上的指令、数据等读入到寄存器，并根据运算的结果控制整个计算机； 寄存器用来暂存数据、指令等处理对象，一般 CPU 包含 20～100 个不同的寄存器； 时钟负责 CPU 开始计时的时钟信号； 运算器负责运算从内存读入寄存器的数据 从程序员的角度来说，CPU 可以看作寄存器的集合。CPU 中包含不同种类的寄存器，各自有不同的功能，如下表所示：\n种类 功能 数目 累加寄存器 存储运算中和运算后的数据 1 标志寄存器 存储运算后的 CPU 状态 1 程序计数器 存取下一条指令的内存地址 1 基址寄存器 存储数据内存的起始地址 多个 变址寄存器 存储基址寄存器的相对地址 多个 通用寄存器 存储任意数据 多个 指令寄存器 存储指令。CPU 内部使用，程序员无法通过程序对寄存器进行读写操作 多个 栈寄存器 存储栈区域的起始地址 多个 Q：一个典型的 C 语言源代码在电脑中运行的基本流程是怎样的？ A：C 语言写成的源代码是高级语言程序，但是 CPU 运行的代码是本地机器语言，因此 C 的源代码并不能立即运行。实际上，一个 C 的源代码需要经过编译、和链接生成. exe 的可执行文件之后，电脑会将. exe 文件的副本复制到内存中再运行，基本的流程如下图所示：\nQ：内存内部结构如何？内存的数据存取都有哪些数据结构？ A：内存是计算机的主存储器，通过芯片与计算机相连，主要负责存储指令和数据，CPU 通过基址寄存器和变址寄存器读取和写入内存中的数据。内存由连续的长度为 8bit（1 个字节）的基本元素构成，程序启动之后 CPU 的控制寄存器根据时钟信号从内存中读取指令和数据。\n存取内存的数据结构包括数组、栈、堆、队列、链表和二叉树。我们可以通过指针直接访问和改变对应内存地址中的变量的数值。\n数组是多个同样类型的数据在内存中连续的排列的形式，可以通过数组的索引访问数组元素； 栈可以不通过指定地址和索引对数组元素进行读写。栈由栈底、栈顶描述，一般用来临时保存运算过程中的数据、连接在计算机设备上或者输入输出的数据； 队列与栈相似，栈的元素是 FILO，但是队列是 FIFO，队列一般用环形缓冲区实现； 链表与数组不同，它在内存中不是连续存储的，每个元素都有一个直接后继，像串珠一样将每个元素串联起来，最大优势是增减元素方便快捷； 二叉树中除了最终的子节点之外，每个元素都有两个后继结点，有序二叉树使得搜索变得更有效 Q：数据和程序是如何保存在计算机中的？ A：程序和数据是保存在计算机的硬盘中的，但是程序运行需要将机器语言的程序加载到内存，因为 CPU 的程序计数器指定内存地址才能读出程序内容。内存和磁盘因为自身特点的差异，它们之间具有紧密的联系。\n磁盘缓存。由于磁盘的读取速度较慢，为了加快程序的运行，将磁盘中的部分数据加载到内存中缓存起来，之后在访问同一个数据的时候就直接从内存中读取数据，这样的机制叫磁盘缓存；\n虚拟内存。虚拟内存刚好与之相反，在运行比较大的程序或者内存资源比较紧张可以将部分磁盘当作假想的内存来用。实现虚拟内存机制需要在磁盘为内存预留空间，并在程序运行时与内存中的内容进行置换（swap），window 中提过分页式虚拟内存机制，如下图所示\n一般虚拟内存的大小与内存相当或者是内存的两倍。\nQ：什么是动态链接和静态链接？二者有何不同？ A：DLL（Dynamic link libary）是在程序运行时候动态加载的文件，维基百科中的解释是\n動態連結函式庫（英语：Dynamic-link library，缩写为 DLL）是微软公司在微软视窗操作系统中实现共享函数库概念的一种实作方式。这些函式庫函数的扩展名是.DLL、.OCX（包含 ActiveX 控制的函式庫）或者.DRV（舊式的系统驱动程序)。\n所謂動態链接，就是把一些經常會共用的程式碼（靜態链接的 OBJ 程式庫）製作成 DLL 檔，當執行檔呼叫到 DLL 檔內的函數時，Windows 作業系統才會把 DLL 檔載入記憶體內，DLL 檔本身的結構就是可執行檔，當程式需求函數才進行链接。透過動態链接方式，記憶體浪費的情形將可大幅降低。靜態連結函式庫則是直接連結到執行檔。\nDLL 的文件格式与视窗 EXE 文件一样——也就是说，等同于 32 位视窗的可移植执行文件（PE）和 16 位视窗的 New Executable（NE）。作为 EXE 格式，DLL 可以包括原始碼、数据和资源的多种组合。\n简单来说，已经编译成汇编语言的程序文件，在进一步链接时如果直接将库文件链接进 exe 可执行文件，则该链接文件就是静态库，如果仅仅在程序运行时才进行链接称为动态链接，链接的目标文件就是动态链接库（windows 中为 dll 文件）。需要说明的是，在链接之后，exe 文件中包含了静态链接库的所有内容，所以会比较大，而动态链接库相对轻巧，并且动态链接库可以在被多个同时运行的程序所共有，并且保证内存中只有一个 dll 文件中调用函数的副本，这样就节省了程序运行的空间。实际上 window 操作系统的大部分 API 目标文件是动态链接库，动态链接库一般由导入库导入，导入库中并不存在目标函数的实体，仅仅保存目标函数所在的动态链接库的名称及路径。下面的表格是对两者的总结。\n链接类型 何时链接 是否可共享 文件类型 资源占用 静态 编译后链接时 否 .a/.lib 多 动态 程序运行时 可被多个程序共享 .dll/.so 少 关于动态链接和静态链接的详细介绍请参考博文 C++ 静态库与动态库。\nQ：一个 C 语言源程序是如何变成可执行文件（exe）的？又是如何在操作系统中运行的？ A：这是个比较大的问题，作者在书中举了个 C 语言的例子。大体来说，C 的源程序需要通过编译器编译成汇编语言（asm 文件），进一步链接需要的库文件（dll 文件）生成可执行文件（exe 文件），最后点击 exe 将可执行文件导入内存运行程序。以Sample.c文件为例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; char *title = \u0026#34;messgae box\u0026#34;; double average(double a, double b) { return (a + b)/2.0; } int WINAPI WinMain(HINSTANCE h, HINSTANCE d, LPSTR s, int m) { double ave; char buff[80]; ave = average(123,456); sprintf(buff, \u0026#34;average value is %f\u0026#34;, ave); MessageBox(NULL, buff, title, MB_OK); return 0; } 编译该文件，在源文件目录上运行命令bcc32 -W -c Sample.c，生成 sample.obj 目标文件； 链接需要的库文件，运行命令ilink32 -Tpe -c -x -aa c0w32.obj Sample.obj, Sample.exe,, import32.lib cw32.lib 需要说明的是，c0w32.obj 文件是与所有程序起始位置相结合的处理内容，称为程序的启动。在源程序中，我们调用了系统函数 sprintf 和 messagebox，因此，需要将这两个函数对应的库函数（其中的内容与 exe 文件相同，都是本地代码）链接进来，告诉链接器去哪里找这两个函数对应的本地代码。\nsprintf 的本地代码在 cwlib32.lib 中，编译之后会将它的目标函数合成到 exe 文件中，称为静态链接；而 messagebox 的本地代码在库文件 user32.dll 里，使用 import32.dll 是为了告诉连接器 “messagebox 在库文件 user32.dll 中，以及 user32.dll 在哪里”，所以 import32.dll 称为导入库。程序运行时，执行从 DLL 文件调出的 MessageBox() 函数这一信息就会和 exe 文件结合，称为动态链接。\n源程序到可执行文件的流程如下所示：\nQ：可执行文件包含哪些内容？它加载到内存中是什么样子？ A：可执行文件中包含了源程序的变量和函数的虚拟地址，在加载到内存之后需要必要的信息将虚拟地址转换成实际地址，转换需要的信息就在 exe 文件开始的部分，称为再配置信息。exe 文件被加载到内存之后，就将这些虚拟内存转换成实际内存，程序运行中会生成栈和堆，因此在内存中的样子如下图所示\nQ：c，o，a，lib，obj，dll 这些文件分别是什么？他们之间是什么关系？ A：c 是 C 语言的源文件，如博文 Linux 的. a、.so 和. o 文件 中所述\nlib,dll,exe 都算是最终的目标文件，是最终产物。而 c/c++ 属于源代码。源代码和最终目标文件中过渡的就是中间代码 obj，实际上之所以需要中间代码，是你不可能一次得到目标文件。比如说一个 exe 需要很多的 cpp 文件生成。而编译器一次只能编译一个 cpp 文件。这样编译器编译好一个 cpp 以后会将其编译成 obj，当所有必须要的 cpp 都编译成 obj 以后，再统一 link 成所需要的 exe，应该说缺少任意一个 obj 都会导致 exe 的链接失败。而 .o, 是 Linux 目标文件, 相当于 windows 中的. obj 文件，.so 文件为共享库, 是 shared object, 用于动态连接的, 相当于 windows 下的 dll,.a 为静态库, 是好多个. o 合在一起, 用于静态链接\nQ：什么是_BSS 段和_DATA 段？全局变量和局部变量在程序运行时有何不同？ A：这是汇编语言的概念，编译器将高级语言源程序转换成汇编文件 (.asm 文件)，有如下的源文件sample2.c\n1 2 3 4 5 6 7 8 9 10 int AddNum(int a, int b) { return a + b; } void MyFun() { int c; c = AddNum(123,456); } 经过编译之后的汇编文件（软件环境 win10，gcc 编译器）内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 .file \u0026#34;sample.c\u0026#34; .text .globl _AddNum .def _AddNum; .scl 2; .type 32; .endef _AddNum: pushl %ebp movl %esp, %ebp movl 8(%ebp), %edx movl 12(%ebp), %eax addl %edx, %eax popl %ebp ret .globl _MyFun .def _MyFun; .scl 2; .type 32; .endef _MyFun: pushl %ebp movl %esp, %ebp subl $24, %esp movl $456, 4(%esp) movl $123, (%esp) call _AddNum movl %eax, -4(%ebp) leave ret .ident \u0026#34;GCC: (tdm-1) 4.9.2\u0026#34; 汇编程序最接近机器语言，而且其与 C 语言一一对应，所以通过汇编文件就可以了解程序运行的大体情况。从上面的汇编文件，可以看到如下的结果\n寄存器 esp 指向栈顶元素地址，每个元素占据 4 个字节的数据； 在每个函数开始的时候，都要将寄存器 ebp 的数据压入栈中进行保护； 上述程序中隐藏的一个关键步骤是在第 21 行，call AddNum 时，计算机已经将 MyFun 函数的下一个指令的地址压入栈中，在调用完 AddNum 时（第 12 行），返回函数 Myfun 时候会自动将栈中的返回指令的地址出栈交给 CPU 的程序计数器，这样就可以实现在调用函数之后仍然返回原来的调用的地方； 函数的入参被保存在栈中，返回值被保存在寄存器里。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int a; int b; float fl; int c = 9; int d = 10; int e = 11; int f = 12; void MyFun(void) { int a1,b1,c1; float fl1; a1 = 1; b1 = -1; fl1 = -99.34; c1 = -87; a1 = a; b1 = b; fl1 = fl; c1 = c; } 以上的 C 源代码转换成汇编语言是\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 .file \u0026#34;sample2.c\u0026#34; .comm _a, 4, 2 .comm _b, 4, 2 .comm _fl, 4, 2 .globl _c .data .align 4 _c: .long 9 .globl _d .align 4 _d: .long 10 .globl _e .align 4 _e: .long 11 .globl _f .align 4 _f: .long 12 .text .globl _MyFun .def _MyFun; .scl 2; .type 32; .endef _MyFun: pushl %ebp movl %esp, %ebp subl $16, %esp movl $1, -4(%ebp) movl $-1, -8(%ebp) movl LC0, %eax movl %eax, -12(%ebp) movl $-87, -16(%ebp) movl _a, %eax movl %eax, -4(%ebp) movl _b, %eax movl %eax, -8(%ebp) movl _fl, %eax movl %eax, -12(%ebp) movl _c, %eax movl %eax, -16(%ebp) leave ret .section .rdata,\u0026#34;dr\u0026#34; .align 4 LC0: .long -1027166700 .ident \u0026#34;GCC: (tdm-1) 4.9.2\u0026#34; 从中可以看出全局变量保存在. comm 和. globl 段，局部变量保存在寄存器中，因此在程序运行的整个过程中，全局变量可以随时访问，但是局部变量却会在用过之后消失。\n关于 windows 的汇编的内容可进一步参考文章汇编与逆向分析\n以上是此书最干货的部分，书中该介绍了计算机二进制数，和计算机硬件的部分内容，在此略过不提。\n","date":"2018-07-21T21:59:51Z","permalink":"https://blog.bugxch.top/p/%E6%9E%81%E7%AE%80%E7%89%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/","title":"极简版《计算机原理》"},{"content":"学习是个终身课题，偶尔得之，胡言乱语。\n类比是非常好的融汇贯通知识的方法。比如可以将一个人比喻成一棵树，外在的气质，形象和谈吐就是地面上树干树枝和树叶，而真正的思考力，感受力和自省力都是庞大的树根部分。树根扎到泥土的深度越深，树冠就生长得越茂盛，树枝就伸展地越远大，整棵大树也越有生命力\n提升自己的能力, 打破内心的畏惧墙，充分估计难度曲线，耐心磨练意志，快速锻炼能力。自律自省 ，自我更新，不断地以 最高效率最大程度地实现自我突破永远是此生最重要的事情\n在处理具体的事物时，结构和框架比内容和细节更重要\n做事情效率是第一位的，为了提升效率就要不停地搭架子，做很多辅助性的工作，利用所有可用的手段和各种所有可能的工具来实现自己的目标。\n比如读书，在具体阅读时候 快速抽取 全书的结构，重点关注最有价值的部分，阅读在脑中快速联想建立具象的情景，尽量建立起与自身经验和已有知识体系的 强联系， 加深内容在脑回中的烙印，最大程度理解作者想要传递的信息。此外，还需要瞻前顾后，分章节 回溯 自己看过的东西，总结归纳，咀嚼吸收。\n不能舍本逐末，最重要是完成任务， 不要耗费太多时间和精力在工具上\n高效处理多任务一个有效方法是交织，采用适当的方法将不同的多个任务糅合到同一个任务中去。比如，既要进行英语学习又要学习专业知识，可以阅读英文教材或者用英语做读书笔记都是好方法\n生活的很大一部分困惑和烦恼来自于对目标的失焦，时间的失控，以及由此带来的浑浑噩噩和不断的不可抑制的自责。所以无论何时都要给自己确定清晰的目标，充分利用每一个精确到半小时的时间粒度\n先有行动，慢慢有动力，然后再行动，越做越好，形成良性循环。于是慢慢有了清晰的目标，为了达到清晰的目标就要利用身边的所有资源（精力，时间和金钱等），利用所有的工具（书本，人脉，网络，软件，社交等），专注精力持续不断调整自身的方法和姿态， 锲而不舍百折不挠， 最终完满达成目标\n极限思维法和加减思维法。衡量是否真的需要一样东西，可以使用加减思维法可以问问自己：\n如果我拥有这件东西会怎样？ 如果我失去这件东西又会怎样？ 我的收益和我的支出是否平衡？ 确定当前的事情是否是真正值得做，可以想想\n如果目前的所有的困难都被克服以最短的时间和效率完成了这个事情我会怎样？\n比如资金 / 人力 / 时间全都有了我会继续热爱当前所做的事情吗？\n在生活中引入 no pain no gain 模式，在享受或者购买任何事物之前，想想自己需要克服的困难，根据二者的匹配程度，确认在解决完什么困难以前绝不购买或者享受什么事物。比如，浏览知乎很爽，可以在肆意浏览之前先解答一个专业的问题，等价的快感要等价的付出来换。此条对于健康用品无效\n精读的内容必须以博客，思维导图和笔记等方式整理储存，便于将来随时检索和快速回忆，这是检验知识是否完全消化的标准\n极小化思想。进入一个领域 / 行业，最快的方法是快速学习这个领域最基础的知识，然后在实践中反复不停地磨练自己，补充其他的部分。 完成比完美更重要。写博客写文章先把框架搭起来，再慢慢补充内容。 主题阅读法。同一个复杂的主题有很多不同的书，每本书会介绍其中的一部分，而且他们着墨的深浅也不同，没有那本书可以穷尽所有。不同的书就像知识的一条线，很多书在一起才能织起这张大网。 图形化思想。一图胜千言，尤其是物理和工程的礼知识，翻开书就是一大堆头疼的公式，如果仅仅明白数学原理并不算真正懂得理论。最好在学习的时候，将这些理论和实际联系起来，如果不能映射到现实的事物中，也要将知识图表化形象化，便于记忆和理解 纠正偏见，重视数据。我的头脑中有很多错误的假设和观念，有必要根据数据纠正这些偏见 珍视自身体验，拒绝道德压力。 相信自己，摒息凝神，找准节奏，继续前进。 类似于 MATLAB/python/sublime text 等工具类软件学习就该使用原生的帮助功能，自行搜索需要的内容，不买相关工具使用指导书籍。要在庞大的帮助功能中找到自己需要的信息，既锻炼自己的英文阅读能力，又考验自己处理复杂事物的能力。 按照该文的方法，学习应该注意如下几点： 加速理解，快一点，再快一点。完整的学习过程分为三个阶段：知识面覆盖，练习和自省。第一阶段效率最低，需尽快加速完成，不要在书本上做笔记，最多在每一章节最后写一个总结性的笔记或者做稀疏的笔记。 自我调试，及时反馈。这一阶段最重要及时反馈，最好答案就在手边，及时纠正错误。 自省。使用费曼技巧应对比较困难的课题。 费曼技巧很简单：\n拿张白纸； 在白纸顶部写上你想理解的某想法或某过程; 用你自己的话解释它，就像你在教给别人这个想法。 最要紧的是，对一个想法分而化之，虽然可能重复解释某些已经弄懂的知识点。但你最终会到达一个临界点，无法再解释清楚。那里正是你需要填补的知识缺口。为了填补这个缺口，你可以查课本、问老师、或到互联网搜寻答案。通常来说，一旦你精准地定义了你的不解或误解，找到确切的答案则相对而言更轻松。\n","date":"2018-07-21T21:59:00Z","permalink":"https://blog.bugxch.top/p/%E6%96%B9%E6%B3%95%E8%AE%BA/","title":"方法论"},{"content":"这是工作中遇到的小问题。\n数据结构中有一种数据类型——堆栈，该结构中的数据项有如下特点：\n除了最前面和最后面的数据，每个数据项都有一个前驱结点和一个后继结点；\n堆栈两端分别称为栈顶和栈底，数据项只能在栈顶加入或者弹出。\n很明显，堆栈的数据遵循先入后出原则。假设我们有 3 个不同的数据项，编号 1，2，3，只要保证入栈顺序是大编号在后小编号在前，且每次进栈的数量不限，则所有可能的出栈顺序有：1-\u0026gt;2-\u0026gt;3，1-\u0026gt;3-\u0026gt;2，2-\u0026gt;1-\u0026gt;3，2-\u0026gt;3-\u0026gt;1，3-\u0026gt;2-\u0026gt;1 一共 5 种，注意 3-\u0026gt;1-\u0026gt;2 不是可能的出栈顺序，因为如果 3 最先出栈，那么 1 和 2 必在栈中（如果还未入栈，则说明 3 先入栈，与假设矛盾），只能 2 在上 1 在下，所以出栈顺序必然是 2-\u0026gt;1。那么，\n问题一：编号$1\\sim n$的连续数据项以编号的先后顺序入栈然后出栈，所有可能的出栈顺序有多少种？\n上面的问题比较难于回答，引申之后得到另一个比较弱的问题\n问题二：给定一个长度为$n$ 的整数序列，且各个元素均不相同，它是否是一个出栈序列？\n为了回答以上的两个问题，我们首先来看下一个正常的出栈序列有什么特点。假设长度为 $n$的出栈序列是$a_1,a_2,…,a_n$，取其中第$k$ 个数 $a_k$，则有如下结论：\n$a_k$之前的所有数据项都已经出栈，即$a_1,a_2,…,a_{k-1}$都已经出栈； $a_k$ 之后的所有数据项中，小于 $a_k$的都在栈内，大于$a_k$的尚未入栈； $a_k$之后紧跟的出栈数据项 $a_{k+1}$ 要么大于$a_k$，要么是所有未出栈的比$a_k$小的数据项中最大的一个 结论 1 很明显，因为本身就是出栈序列，因此之前的数据肯定已经出栈；结论 2 中，之后的数据只有两种存在的可能：在栈内，或者未进栈。比$a_k$小的如果未进栈，那么 akak 根本不可能出栈（因为就没进栈），比$a_k$大的如果在栈内，那$a_k$也无法出栈，因为$a_k$在它的下面，因此得证；结论 3，$a_{k+1}$就是$a_k$ 出栈后栈顶的数据，因此必然是在栈内的数据的最上面的一个，或者是栈外的某一个数据（进栈再出栈）。\n于是由结论 3 找到判断序列的方法：逐个检查序列的每一项$a_k$，将该项之后的数据分为大于该数据的大数集合$S_g$和小于该数的小数集合$S_l$，查看是否后续的数据项是小数集合的最大值或者是大数集合的任意值，如果不是则不是出栈序列，即若 $a_{k+1}\\in S_g$ 或 $a_{k+1}=max_l{S_l}$，即是出栈序列。\n问题一的解答，就是穷举长度为 nn 的序列，逐个进行判断，得到最后的结果，附上 python 程序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import math import itertools % 输入序列的长度 n = raw_input(\u0026#34;Input n: \u0026#34;) % 判断是否是出栈序列 def IsNotStackSeq(n_ls, n): for k in range(0,n-2): % 逐个检查序列中的每一个元素 ak = n_ls[k] set_in = n_ls[k+1:] a_max = ak % 将ak之后的元素分为大于和小于两组集合 min_list = [item for item in set_in if item \u0026gt; ak] max_list = [item for item in set_in if item \u0026lt; ak] if len(max_list) \u0026gt; 0: a_max = max(max_list) % 后续的元素是否是小于集合的最大值或者属于大于集合 if n_ls[k+1] != a_max and (n_ls[k+1] not in min_list): return 1 return -1 def StackSeqList(n): n_permation = list(itertools.permutations(range(1,int(n)+1), int(n))) n_list = [item for item in n_permation if IsNotStackSeq(list(item),int(n)) \u0026lt; 0] return (len(n_list),n_list) ","date":"2018-07-21T21:46:35Z","permalink":"https://blog.bugxch.top/p/%E5%A0%86%E6%A0%88%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/","title":"堆栈出栈序列问题"},{"content":"简单来说，正则表达式是根据一定的语法规则组合而成的用来匹配具有某种模式的文本的字符串。\n维基百科定义如下：\n正则表达式，又称正规表示式、正规表示法、正规运算式、规则运算式、常规表示法（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。\n正则表达式在台湾又译作正规表达式，英文名称表示 “某种规则的表达式” 的意思，目前主流的文本编辑器(source insight/sublimtext/ultra edit/emacs/notepad++/vim) 和主流计算机语言（perl/python/PHP/java/.NET/tcl/c/c++）都支持正则表达式。它**简单，优美，功能强大，妙用无穷。**大数据时代的到来，因其快捷强大的文本处理能力必然在数据挖掘处理中发挥越来越重要的作用。\n正则表达式由一般字符和特殊字符组成，一般字符指常见的字符本身，比如123Aaf0=;~#@%这些简单字符。通过简单地排列组合这些字符可以实现对复杂字符串的精确匹配。先放一张 python 的正则字符列表，下面逐一介绍。\n元字符\n除了一般字符之外，python 规定了.^$*+?{}[]()\\|这 14 个元字符，它们分别具有特殊的含义，有的代表量词，有的代表分组，有的代表逻辑等等（具体可参见上表）。正则表达式使用\\作为转义字符，例如 \\ s 代表空格，使用 \\ t 代表 tab 等，我们将转义字符与其组合归类到一般字符。\n注意字符集[]，它匹配内容是括号中的任何一个字符，比如[a0d]表示匹配 a 或者 0 或者 d，而不是匹配a0，0d或者a0d。关于字符集需要注意如下两点：\n字符集中的特殊字符都失去了它们本身代表的涵义，而成为符号自身，比如[a\\.0]匹配dlkll\\fd，因为其中有\\； 字符集前面最前面为^表示不匹配字符集中的任意字符，比如[^\\da-f]表示不匹配数字及字母 a~f 中的任意字符。 与 python 原生的字符串方法不同的是，正则表达式可以使用量词，位置匹配，字符组合，分组捕获等更强大的功能实现更复杂的字符处理功能。\n量词 特殊字符中的+*?三个字符是量词字符，描述在它们之前紧挨着它们的字符连续重复的数量。比如量词a{100}就代表 a 连续重复 100 次，而a+表示 a 出现至少一次，其他的具体的内容可参见表格。\n位置字符 正则表达式不仅可以匹配字符也可以匹配位置，这些字符包括^$\\b\\A\\Z\\B，比如匹配以 Atom 开头的行，就是^Atom，其他字符的具体含义可以参见表格。\n逻辑 |表示或，所有的字符中优先级最低，比如girl|boy表示匹配 girl 或者 boy，而不是girloy或者girboy。\n初识正则表达式 有了以上的基础知识，就可以完成大部分简单的正则表达式了，比如官方文档中的例子，尝试用正则表达式a[bcd]*b去匹配abcbd。具体的匹配步骤如下表所示\nStep Matched Explanation 1 a 正则表达式中的 a 2 abcbd 引擎匹配 [bcd]*，匹配尽可能多的字符直到目标字符串结尾 3 失败 引擎尝试匹配 b，但是目前已经到了字符串结尾，所以无字符匹配，失败 / 4 abcb 回溯一个字符（即d），因此 [bcd]* 少匹配一个字符 5 失败 再次尝试匹配 b ，但是当前未匹配字符只有 'd'，再次失败 6 abc 再次回溯一个字符（即b）， 因而 [bcd]*仅仅匹配bc 6 abcb 再次尝试匹配 b 。 这次未匹配字符当前位置就是 'b'，因此成功 从以上的匹配过程可以看到，正则表达式匹配过程就是引擎从左到右逐个搜索目标字符串，匹配正则表达式中所有字符代表的模式，如果搜索完整个字符串仍然没有找到就失败。推荐使用网站 regex101.com 选择 python 语言，练习正则表达式。网站截图如下所示，它用蓝色底块标识了表达式匹配的内容，直观好用。\n贪婪模式 上面的例子里的第二步，*会尽可能地匹配符合表达式的所有字符，引擎就像一个贪婪的胖子，一口气吞下所有可以吞下去的东西，这就是正则表达式的贪婪模式。构造正则表达式时需要特别小心地处理具有相同属性的量词字符?{m,n}+，不然往往会产生意想不到的结果。\n比如使用正则表达式\u0026lt;.*\u0026gt;尝试匹配\u0026lt;a\u0026gt;b\u0026lt;c\u0026gt;的中的\u0026lt;a\u0026gt;，却匹配了整个表达式。为了仅仅匹配\u0026lt;a\u0026gt;，需要在*后加上?，即使用\u0026lt;.*?\u0026gt;就能成功。二者的具体的区别如下表所示\n表达式 步骤 \u0026lt;.*\u0026gt; 先匹配\u0026lt;，再匹配.*，此时吞下所有的符号，最后从最后一个字符开始，吐一个字符匹配一次\u0026gt;，直到成功为止 \u0026lt;.*?\u0026gt; 先匹配\u0026lt;，再匹配.*?，此时一个字符一个字符吞，每吞一个字符就立马匹配\u0026gt;，直到成功为止 在量词之后加上?表示非贪婪模式或者最小模式，吐到第三个字符为止，因此它找到了最小的\u0026lt;.*\u0026gt;的模式。\n零宽字符 正则表达式中字符\\b^$\\A\\Z\\B|不占有任何字符，但是定义字符的边界，它们都是零宽 (zero-width) 字符。比如\\b\\w+\\b表示匹配一个单词，而其中的\\b表示单词的边界。\n分组捕获 字符处理不仅仅需要判断是否匹配，我们常常希望提取相关模式的字符串，获得对应的信息，比如从网页源代码中提取邮件地址。此时就可以利用正则表达式的分组功能捕获字符，上面表中的的 group 就可以抓取不同的分组字符。比如，需要从下面字符中提取邮件的发件人信息\n1 2 3 4 From: author@example.com User-Agent: Thunderbird 1.5.0.9 (X11/20061227) MIME-Version: 1.0 To: editor@example.com 使用^From:\\s*([\\w@.]+)抓取信息，其中有 2 个括号，就是分别分组捕获发件人和日期。从左到右以(的出现顺序为序，分别是第 1 个分组第 2 个分组依次类推，使用编号就可以重复对应括号分组的模式。\n举个例子，匹配类似abba的单词，使用正则表达式\\b([a-zA-Z])([a-zA-Z])\\2\\1\\b，其中的 \\ 1 和 \\ 2 就分别表示与第 1 个和第 2 个分组相同的内容，依次类推。\n如果分组很多，数字编号数数会很累，也可以使用(?P\u0026lt;name\u0026gt;...)命名，之后再使用(?P=name)引用，比如下面的代码\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; p = re.compile(r\u0026#39;(?P\u0026lt;word\u0026gt;\\b\\w+\\b)\u0026#39;) \u0026gt;\u0026gt;\u0026gt; m = p.search( \u0026#39;(((( Lots of punctuation )))\u0026#39; ) \u0026gt;\u0026gt;\u0026gt; m.group(\u0026#39;word\u0026#39;) \u0026#39;Lots\u0026#39; \u0026gt;\u0026gt;\u0026gt; m.group(1) \u0026#39;Lots\u0026#39; 其中的\u0026lt;word\u0026gt;表示匹配的分组名字是word，使用 group() 方法使用名字即可调用这个分组内容。\n零宽断言 除此之外，还有如下 5 个特殊的分组匹配符号和正常的匹配符号相似，但是它们匹配...的表达式，却不捕获内容。\n(?:...)。非捕获分组，表示匹配… 表示的表达式，但是它不捕获内容，因此不能以\\1和\u0026lt;name\u0026gt;的方式被引用。比如\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; m = re.match(\u0026#34;([abc])+\u0026#34;, \u0026#34;abc\u0026#34;) \u0026gt;\u0026gt;\u0026gt; m.groups() (\u0026#39;c\u0026#39;,) \u0026gt;\u0026gt;\u0026gt; m = re.match(\u0026#34;(?:[abc])+\u0026#34;, \u0026#34;abc\u0026#34;) \u0026gt;\u0026gt;\u0026gt; m.groups() () 第二个表达式什么都没有匹配。\n(?=...)。肯定正序环视 (Positive lookahead)，跟在匹配字符之后，表示接下来匹配… 的字符，比如Isaac (?=Asimov)匹配后面跟着 Asimov 的 Isaac。\n(?!...)。否定正序环视 (Negative lookahead) 与上面的意思刚好相反，表示不匹配…。\n举个例子匹配形如foo.txt的文件名，但是要求文件的扩展名不是bar，就可以使用.*[.](?!bar).*$匹配。\n(?\u0026lt;=...)。肯定逆序环视 (Positive lookbehind) 跟在匹配字符之后，表示之前匹配… 的字符，比如(?\u0026lt;=abc)def匹配abcdef，表示之前为abc的def。\n(?\u0026lt;!...)。否定逆序环视 (Negative lookbehind) 表示之前不匹配…，与上一条意思刚好相反。\n符号优先级 另一个需要留心的问题是正则表达式的优先级，它表示解读正则表达式时对一般字符及字符组（用()括起来的一般字符的组合）的粘度，最低的是|（表中未列出），具体可参考如下的优先级列表。\n运算符 描述 \\ 转义符 (), (?:), (?=), [] 圆括号和方括号 *, +, ?, {n}, {n,}, {n,m} 限定符 ^, $, \\ 任何元字符、任何字符 定位点和序列（即：位置和顺序） 正则表达式举例 结合以上的例子，解读如下正则表达式。\n[-+]?(\\d*\\.\\d+|\\d+) 拿到一个正则表达式，首先看它有哪些运算符，然后依照从最高到最低优先级每个运算符去粘挨着它的字符，按照尽量多地将相同优先级的字符粘在在一起形成更大的字符，比如d*\\.\\d+就是一个大字符，最后就将所有的运算符和字符遍历完为止。\n这个正则表达式匹配+.989，-9.989，+989，-989，.989这些小数或者整数。\n[1-9]\\d{4,} 匹配 1 个数字和至少 4 个数字，实际上是 QQ 号码 Windows(?=95|98|NT) 匹配后面跟着 95，98 或者 NT 的 Windows [1-9]\\d{5} 匹配中国邮政编码 附表\n此外附上网站 deerchao 总结的常见正则表达式列表\n说明 正则表达式 网址（URL） [a-zA-z]+://[^\\s]* IP 地址 (IP Address) ((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?) 电子邮件 (Email) \\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* QQ 号码 [1-9]\\d{4,} HTML 标记 (包含内容或自闭合) \u0026lt;(.*)(.*)\u0026gt;.*\u0026lt;\\/\\1\u0026gt;|\u0026lt;(.*) \\/\u0026gt; 密码 (由数字 / 大写字母 / 小写字母 / 标点符号组成，四种都必有，8 位以上) (?=^.{8,}\\$)(?=.*\\d)(?=.*\\W+)(?=.*[A-Z])(?=.*[a-z])(?!.*\\n).*$ 日期 (年 - 月 - 日) (\\d{4}\\d{2})-((1[0-2])(0?[1-9]))-(([12][0-9])(3[01])(0?[1-9])) 日期 (月 / 日 / 年) ((1[0-2])(0?[1-9]))/(([12][0-9])(3[01])(0?[1-9]))/(\\d{4}\\d{2}) 时间 (小时: 分钟, 24 小时制) ((10?)[0-9]2[0-3]):([0-5][0-9]) 汉字 (字符) [\\u4e00-\\u9fa5] 中文及全角标点符号 (字符) [\\u3000-\\u301e\\ufe10-\\ufe19\\ufe30-\\ufe44\\ufe50-\\ufe6b\\uff01-\\uffee] 中国大陆固定电话号码 (\\d{4}-\\d{3}-)?(\\d{8}\\d{7}) 中国大陆手机号码 1\\d{10} 中国大陆邮政编码 [1-9]\\d{5} 中国大陆身份证号 (15 位或 18 位) \\d{15}(\\d\\d[0-9xX])? 非负整数 (正整数或零) \\d+ 正整数 [0-9]*[1-9][0-9]* 负整数 -[0-9]*[1-9][0-9]* 整数 -?\\d+ 小数 (-?\\d+)(\\.\\d+)? 不包含 abc 的单词 \\b((?!abc)\\w)+\\b ","date":"2018-07-21T21:12:46Z","permalink":"https://blog.bugxch.top/p/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3%E4%B8%8A/","title":"正则表达式详解（上）"},{"content":"书接上文，在下篇中主要介绍如何在 python 中使用正则表达式实现文本的匹配和替换工作。\n匹配字符串 python 的 re 模块支持正则表达式，基本步骤是使用 compile 编译正则表达式为 pattern 实例，之后使用实例匹配目标文本（一般使用方法 match 和 search）。先来看一个简单的例子，\n1 2 3 4 5 6 7 8 9 10 11 12 13 # encoding: UTF-8 import re string = \u0026#34;Tutorial. 0123456789 _ + -., !@ # $%^\u0026amp;*();\\/|\u0026lt;\u0026gt;\\\u0026#34;\\\u0026#39;12345 - 98.7 3.141 .6180 9,000 + 42 55.123.4567 + 1 - (800) - 555 - 2468 foo@demo.net ar.ba@test.co.uk www.demo.com\u0026#34; pattern = re.compile(r\u0026#34;\\d+\u0026#34;, re.M) sear = re.search(pattern, string) print(\u0026#39;sear\u0026#39;, sear) mat = re.match(pattern, string) print(\u0026#39;mat\u0026#39;, mat) fin = re.findall(pattern, string) print(\u0026#39;fin\u0026#39;, fin) 代码第 4 行，使用正则表达式r\u0026quot;\\d+\u0026quot;compile 编译一个 pattern 的实例。\n为什么要在正则表达式之前加个r呢？\n此处的r表示 raw，即原始输入。因为\\在 python 的字符串中也是转义字符，此处的功能与正则表达式中的功能有冲突。compile中的表达式从输入到真正的表达式的意思执行需要经过两次解读，python 本身解读之后将字符串表达的意思传递给正则表达式，正则引擎再解读之后执行，问题就出在两次解读上。\n以最终匹配\\section为例，如果不加r使用 python 第 5 行的参数就该是\\\\\\\\section，即pattern = re.compile(\u0026quot;\\\\\\\\section\u0026quot;, re.M)。第一次解读，python 将其理解为\\\\section传递给正则引擎，正则理解为要匹配\\section，如下表所示\nCharacters Stage \\section 希望匹配的字符串 \\\\section 正则引擎添加反斜线 re.compile() \u0026quot;\\\\\\\\section\u0026quot; python 字符串为表示\\字符再添加反斜线 所以为了匹配 1 个\\最后需要写 4 个\\，实在麻烦，**为了便利，因此使用r在字符串之前，表示去掉 Python 的解读，仅保留正则引擎的解读。**比如下表中的参数写法就能省掉很多不必要的\\，十分方便。\nRegular String Raw string \u0026quot;ab*\u0026quot; r\u0026quot;ab*\u0026quot; \u0026quot;\\\\section\u0026quot; r\u0026quot;\\section\u0026quot; \u0026quot;\\\\w+\\\\s+\\\\1\u0026quot; r\u0026quot;\\w+\\s+\\1\u0026quot; re.M是个什么东东？\n上面的代码中，compile 还包含了re.M作为一个 flag，它是MULTILINE的缩写，表示匹配多行模式，除了多行模式之外（具体含义见下表），python 还有其他的 flag 影响表达式匹配的规则。\nFlag Meaning ASCII, A 使得 \\w, \\b, \\s 和 \\d 仅仅匹配 ASCII 文本 DOTALL, S 使得 . 匹配换行符在内的所有字符 IGNORECASE, I 忽略大小写 LOCALE, L 使用 locale 匹配 MULTILINE, M 多行匹配，影响 ^ 和 $ VERBOSE, X (for ‘extended’) 忽略表达式中的空格，允许插入注释 需要说明的是X模式，使用方法如下\n1 2 3 4 5 6 7 8 9 charref = re.compile(r\u0026#34;\u0026#34;\u0026#34; \u0026amp;[#] # Start of a numeric entity reference ( 0[0-7]+ # Octal form | [0-9]+ # Decimal form | x[0-9a-fA-F]+ # Hexadecimal form ) ; # Trailing semicolon \u0026#34;\u0026#34;\u0026#34;, re.VERBOSE) 表达式内部加入了注释，而且可以多行显示，可以使用它表示复杂的表达式，非常方便。\n匹配正则表达式的方法\npattern 的对象建立之后，就是可以使用 re 的方法匹配字符串了。最重要的方法有下表中的四个。\n方法或者属性 目的 match() 表达式是否匹配字符串的开头 search() 浏览整个字符串，匹配其中任意位置 findall() 匹配所有的字符子串，返回列表 finditer() 匹配所有的字符子串，返回 iterator. 运行上面的代码如下所示\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; sear \u0026lt;_sre.SRE_Match object; span=(11, 21), match=\u0026#39;0123456789\u0026#39;\u0026gt; mat None fin [\u0026#39;0123456789\u0026#39;, \u0026#39;12345\u0026#39;, \u0026#39;98\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;141\u0026#39;, \u0026#39;6180\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;000\u0026#39;, \u0026#39;42\u0026#39;, \u0026#39;55\u0026#39;, \u0026#39;123\u0026#39;, \u0026#39;4567\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;800\u0026#39;, \u0026#39;555\u0026#39;, \u0026#39;2468\u0026#39;] sear 匹配成功，返回匹配的对象。mat 匹配失败，fin 匹配成功并且返回了字符列表。\n匹配成功之后对象有如下方法\n方法 目的 group() 返回匹配的字符串 start() 返回匹配字符串的开始位置 end() 返回匹配字符串的结束位置 span() 返回匹配字符串开始位置和结束位置的元组 (start, end) group()在上篇中讲过，它在字符捕获时候非常有用，字符的分组从 0 开始，其中第 0 个代表所有匹配的内容，1 代表匹配的第一组，以此类推。比如下面的代码\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; p = re.compile(\u0026#39;(a(b)c)d\u0026#39;) \u0026gt;\u0026gt;\u0026gt; m = p.match(\u0026#39;abcd\u0026#39;) \u0026gt;\u0026gt;\u0026gt; m.group(0) \u0026#39;abcd\u0026#39; \u0026gt;\u0026gt;\u0026gt; m.group(1) \u0026#39;abc\u0026#39; \u0026gt;\u0026gt;\u0026gt; m.group(2) \u0026#39;b\u0026#39; 可以将group(0)理解成没有分组符号匹配的所有字符，而之后的编号代表分组依次匹配的子串。\n修改字符串 模块级别的字符串修改方法如下表所示。\n方法和属性 目的 split() 使用 pattern 将目标字符串分割，并返回列表 sub() 查找所有匹配的子串，并替换之，返回替换之后的字符串 subn() 查找所有匹配的子串，并替换之，返回替换之后的字符串和次数 .split(string[, maxsplit=0]) 将字符串分割，其中有参数最大分块，默认将分割成最多的块。 1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; p = re.compile(r\u0026#39;\\W+\u0026#39;) \u0026gt;\u0026gt;\u0026gt; p.split(\u0026#39;This is a test, short and sweet, of split().\u0026#39;) [\u0026#39;This\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;test\u0026#39;, \u0026#39;short\u0026#39;, \u0026#39;and\u0026#39;, \u0026#39;sweet\u0026#39;, \u0026#39;of\u0026#39;, \u0026#39;split\u0026#39;, \u0026#39;\u0026#39;] \u0026gt;\u0026gt;\u0026gt; p.split(\u0026#39;This is a test, short and sweet, of split().\u0026#39;, 3) [\u0026#39;This\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;test, short and sweet, of split().\u0026#39;] 替换字符串 .sub(replacement, string[, count=0]) 将 string 中所有符合 pattern 模式替换成 replacement，count 表示替换的次数。看如下的例子 1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; p = re.compile( \u0026#39;(blue|white|red)\u0026#39;) \u0026gt;\u0026gt;\u0026gt; p.sub( \u0026#39;colour\u0026#39;, \u0026#39;blue socks and red shoes\u0026#39;) \u0026#39;colour socks and colour shoes\u0026#39; \u0026gt;\u0026gt;\u0026gt; p.sub( \u0026#39;colour\u0026#39;, \u0026#39;blue socks and red shoes\u0026#39;, count=1) \u0026#39;colour socks and red shoes\u0026#39; 方法subn()与sub()类似，但是它返回一个元组，其中包含替换之后的字符串，以及替换的次数，下面是另一个例子\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; p = re.compile( \u0026#39;(blue|white|red)\u0026#39;) \u0026gt;\u0026gt;\u0026gt; p.subn( \u0026#39;colour\u0026#39;, \u0026#39;blue socks and red shoes\u0026#39;) (\u0026#39;colour socks and colour shoes\u0026#39;, 2) \u0026gt;\u0026gt;\u0026gt; p.subn( \u0026#39;colour\u0026#39;, \u0026#39;no colours at all\u0026#39;) (\u0026#39;no colours at all\u0026#39;, 0) 特别地，替换可以使用分组，这在交换字符串的位置时非常有用。举例如下\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; strin = \u0026#39;This is part1 and part2\u0026#39; \u0026gt;\u0026gt;\u0026gt; p = re.compile(\u0026#39;(.*)(part1)(.*)(part2)\u0026#39;) \u0026gt;\u0026gt;\u0026gt; p.sub(r\u0026#39;\\1\\4\\3\\2\u0026#39;, strin) \u0026#39;This is part2 and part1\u0026#39; 我们还可以使用之前的名字分组，除了使用\\number指代第几个分组之外，还可以使用\\g\u0026lt;number\u0026gt;指代已经命名的分组。一个典型的例子如下所示\n1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; p = re.compile(\u0026#39;section{ (?P\u0026lt;name\u0026gt; [^}]* ) }\u0026#39;, re.VERBOSE) \u0026gt;\u0026gt;\u0026gt; p.sub(r\u0026#39;subsection{\\1}\u0026#39;,\u0026#39;section{First}\u0026#39;) \u0026#39;subsection{First}\u0026#39; \u0026gt;\u0026gt;\u0026gt; p.sub(r\u0026#39;subsection{\\g\u0026lt;1\u0026gt;}\u0026#39;,\u0026#39;section{First}\u0026#39;) \u0026#39;subsection{First}\u0026#39; \u0026gt;\u0026gt;\u0026gt; p.sub(r\u0026#39;subsection{\\g\u0026lt;name\u0026gt;}\u0026#39;,\u0026#39;section{First}\u0026#39;) \u0026#39;subsection{First}\u0026#39; 使用正则表达式 考虑使用正则表达式之前，先想想是否可以使用字符串方法就能解决问题。如果仅仅匹配和替换固定字符串，python 自带的字符串方法速度更快，效率更高，不是每个字符串的替换都需要使用正则表达式。\n未尽事宜 相信以上介绍的内容能够解决大部分的字符处理问题，但是对于专业大数据处理可能还需要了解正则表达式更多的内容，比如不同语言的正则表达式语法，以及复杂正则表达式的匹配效率。这些比较深入的知识可以参考 Jeffrey E.F. Friedl 的《精通正则表达式》，里面有非常专业的解释，相信它可以帮你解决正则表达式的绝大部分疑问。\n","date":"2018-07-21T21:10:56Z","permalink":"https://blog.bugxch.top/p/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3%E4%B8%8B/","title":"正则表达式详解（下）"},{"content":"推荐给轻度抑郁者的好书。\n有段时间心情抑郁，严重怀疑自己，偶尔看到《伯恩斯新情绪疗法》这本书，对照认知扭曲的十大罪状，发现自己招招中到膝盖上，列出来警醒自己。真是错误的心理源于错误的思维！\n非此即彼思维：你用非黑即白的思维模式看待世界，只要你的表现有一点不完美，你就宣告彻底失败。 以偏概全：在你看来，只要发生一件负面事件，就表示失败会接踵而至。 心理过滤：你单单挑出一些负面细节反复回味，最后你眼中的整个现实世界都变得黑暗无光。 否定正面思考：你拒绝正面的体验，坚持以这样或那样的暗示自己 “它们不算”。虽然这种消极信念有悖于现实体验，但你却以这种方式固执地坚持。 妄下结论（包括读心术、先知错误）：你喜欢用消极的理解方式下结论，即使没有确切的事实有力地证明也如此。 读心术。如果发现他人的行为不尽如人意，你就认为是针对你的，对此你也懒得去查证； 先知错误。你觉得事情只会越来越糟，对这一预言深信不疑。在你看来，它就是铁板钉钉的事实。 放大和缩小（或称 “双目镜把戏”）：对于你的错误或他人的成就等方面，你往往会夸大它们的重要性。但对于你的优点或他人的缺点等方面，你又会不理智地将它们缩小，把它们看得微不足道。 情绪化推理：你认为，只要有负面情绪，就足以证明事实确实非常糟糕，因为你这样想：“我感觉得出来，所以肯定就是真的。” “应该”句式：你习惯于用 “我应该做这个” 和“我不应该做那个”来鞭策自己，好像你需要被皮鞭抽一顿之后才能好好干活一样。“必须”和 “应当” 这类句式也会让他人产生同样的抵触效果。这种句式带来的情绪就是内疚。当你把 “应该” 句式强加于他人时，你会产生愤怒、沮丧甚至仇恨的情绪。 乱贴标签：这是一种极端的以偏概全的形式。此时，你不再描述自己的错误，而是给自己贴上消极的标签：“我是个废物。” 如果有人惹恼了你，你又会给他贴上消极的标签：“他真是个讨厌鬼。” 乱贴标签指的是用高度情绪化、充满感情色彩的语言来描述事物。 罪责归己：即使某些外界消极事件你根本不需要负责，但你却认为自己是罪魁祸首。 大家可以对照看看自己，是否有以上列出的消极思维呢？\n","date":"2018-07-21T21:09:13Z","permalink":"https://blog.bugxch.top/p/%E4%BC%AF%E6%81%A9%E6%96%AF%E6%96%B0%E6%83%85%E7%BB%AA%E7%96%97%E6%B3%95/","title":"伯恩斯新情绪疗法"},{"content":"新年来到，2017 年我就三十岁了，盘点下过去一年我的变化。\n种一棵树最好的时间是十年前，其次是现在。 ——互联网\n世界观 变化越来越快，波及越来越广 世界不是线性时不变系统，它充满未知与突兀。英国脱欧，特朗普当选总统，表姐在老家读高中时从没想到会在武汉定居，丫丫在成都啃馒头时从没想过工资能超过四千。2016 年初房价上涨从上海一直波及到武汉和郑州，即便生活在二线城市躲清静，也躲不开汹涌的潮水。科技进步促使消费品成本快速降低，两三年时间老家几乎一半的家庭装了宽带，现在有人开始买小汽车和空调，基础设施急速向城镇靠拢，这样的节奏让我始料未及。 上海的房价一个月就可能翻番，明天可能就有猎头打电话帮你跳槽到心仪的公司，可能变好也可能变坏。**明白世界多变这个道理，遇到坏事就不会焦虑，遇到好事就抓住机会。**今天的行业可能两三年就被淘汰，保持学习，持续更新。\n接受现实，但是寻求改变 我接受自己的家庭。 很多同学比我家境优渥，从小不会为钱财发愁，所以可以腾出更多时间专注在喜欢的时间上，父母有远见上学时候就买房，现在毕业没有房贷压力，做事顾忌很少。**我的父母就是农民，经济收入有限，没有多少余钱供我买房，我接受这事实。**父母在自己的能力范围之内已经做到最好，我心怀感激。\n我接受自己的现状。 阴差阳错做着自己不喜欢的工作，部门边缘化，重复劳动，加薪有限，升职遥遥无期。坚持计划没多久就会懈怠，做事不专心，没勇气去改变，找工作怕被拒绝，避开包括人际关系在内的所有复杂的事物，持续半年时间的浑浑噩噩，一想到买房就焦虑到不行。听起来狼狈不堪，不过这就是 2016 年的我啊，忽然豪情万丈，之后又跌落谷底，一度怀疑自己患上了轻度抑郁症。我是一个完美主义者，但是我不是个完美的人：我有缺点，而且有些还很严重，不过我接受这样的自己。\n接受一件事，就不会再为了这个既定的事实消耗无谓的能量。之前我一直为自己的白发担忧，偶尔会拔白头发，现在已经不去理会了，老了鹤发童颜也不是很漂亮？我不会埋怨父亲为什么不是富商，我不会嫉妒生活比我好的同学，我不会怨恨自己计划怎么没有严格执行完，我不会抱怨老板抠门工作没意思，我也不会苛求自己一定要成功。埋怨，嫉妒，苛求，自毁，这些坏情绪不仅消耗能量，而且对改变这些事实没有任何帮助。\n**接受一件事，就会在既有的基础上寻求改变。**家境不富裕？那就一鼓作气，凭一己之力努力想办法赚钱；工作不满意？想办法部门内部调换或者跳槽；计划没法坚持？心理暗示，奖赏自己，寻找合适的工具，总是想办法让自己坚持；害怕处理人际关系？搞砸一次看看能坏到什么程度，看书看课程，与朋友交流，看看有什么变化。停止抱怨，只要愿意并付诸行动，凡事总会改观。\n奖赏自己 可能是受父亲的影响，从小抠着花钱，上学花着父母的钱，能省就省。开始赚钱之后，慢慢学会钱该怎么花。上学时候因为省钱没有考驾照，现在比原来的价格高了两三倍，而且现在也时间成本更高；因为省钱不太出去交际，也失去了很多朋友；因为省钱不出去旅行，就会错过年轻时壮游的极致体验。**盲目地省钱与盲目地花钱一样愚蠢，**比钱财更重要的是体验，健康，友情和成长。生产力工具，健康，学习，交友和旅行的钱不能省，因为钱和这些东西不能等价交换：即便从经济学的角度来看，拥有它们带来的正向的增益远远大于为此付出的金钱。\n丫丫买到心仪的羽绒服，心满意足地说，“原来购物可以让人快乐啊”。\n以前纠结到底要不要花的钱，现在不多想也就花了，今年购置了新的笔记本电脑，添了一台显示器，年末又买了 ipad，还添了些件好衣服，买书付费网络课程也花了不少。以前买东西看是不是便宜，现在买东西看值不值，即便是高价值这个价，确实需要也会果断买。\n做事 大事提前规划 此条尤其适用于跳槽、买房、结婚、生子和退休储蓄。我 2013 年刚来上海，到手月薪 5500，没太想过买房。2015 年自己积蓄 20W，师傅友善地提醒我去看房，我还是没想好买房，结果 2016 年初房价大涨，现在望楼兴叹。如果我早两年提前规划提前看房呢？肯定会比现在好。对于买房、生育和退休这样长期规划的理财计划需要提早准备，不止理财需要耗费大量精力的事情都需要提前规划和行动，真到眼前再做很有可能就错过窗口期了。\n框架比细节优先，完成比完美优先 我是个完美主义者，特别容易花费大量精力和时间打磨细节，而影响整体工程的进度，在工作中如是，生活中亦如是。现在则先把代码接口定义好，整体框架完成，再一个个填充，文章也是一条条内容列清楚，再细致去完成。这个可能和围棋的道理比较相同，布局比较好后面就轻松很多，刚开始就纠结于一池一地的得失必然会失掉大局。\n行动先于兴趣 这一点来自《伯恩斯新情绪疗法》，这点意识的转变尤其重要，很多人包括我都觉得做一件事必须有十足的兴趣，之后才付诸行动。事实上，更多时候是是先尝试做了，之后想一直把它做好，最后兴趣越来越浓。写文章就是典型的例子，中学时候每周都要上交一次作文，每次题目布置下来都特别发愁，但是一旦开始坐下来写，耐着性子写十分钟以上，好像上天眷顾一样越写越顺，越写越刹不住，感觉特别好。此条尤其适用于创造性更高的活动，比如绘画，剧本和书法等等。\n充分利用可控时间 有段时间我安装过类似于 24PI 的时间统计软件，自己每天花费在手机上的时间平均有 3.5 小时，几乎每天所有的闲暇时间大部分浪费在手机上了，更何况我还会在工作时候看手机。很有必要重新规划闲暇时间，多用于学习，**晚上关闭手机电脑看纸质书就是不错的保持专注力的主意，**不过没坚持多久，今年需要保持。\n健身 身体最诚实，在健身上投入一分就回报一分，懈怠太久就出问题，尤其在压力和节奏特别大的时候。我从儿童节开始使用 “凌健身” 健身，每次 25min 左右的巨量无氧运动，累计健身时长 1360 分钟，消耗 18853 大卡，身体状态和精神状态大为改观。身体刚健，精神也不会脆弱。\n知识管理 书读不尽 吾生也有涯，而知也无涯。以有涯随无涯，殆已！ ——庄子《养生主第三》\n这是我年末的顿悟，**知识是无尽的，我只取对我有用的，与学生时代享受性读书不同，现在读书更强调目的性。**豆瓣有个买书如山倒，读书如抽丝小组，大家都习惯买书，但是看书却很慢，我也有这问题。看到好书就想买回来放在书架上，但是面对这么多的 “知识诱惑” 却无处下爪，要么就是猴子摘包谷，这个没读完又翻另一本（丫丫就因此说过我）。应对这个问题的最佳办法，就是读自己非常想了解的书，一直念念不忘的书，唯有饥渴，才能执着。\n信息爆炸，但是知识依旧没太大增长 这是李笑来老师的观点，互联网时代我们通过微信，微博，twitter 或者网站获取信息越来越便捷，新鲜事每天都有，过段时间就爆出来一个大新闻，我们的眼球耳朵和大脑被铺天盖地的新闻占据得满满当当。但是新闻背后的知识逻辑却很少变化，与其盲目跟风讨论时事，不如退而结网理顺背后的思想脉络。\n对我而言，虽然通信行业飞速发展，但背后的基础知识仍然是通信原理、数字信号处理、射频电路这些专业课程，再变化再丰富，万变不离其宗。\n建立完整知识链路 2016 年我建立了完整的从输入到输出的知识链路。输入端我更专注于主题阅读，交织读书，同一个专题多个书交叉看。\n学会双拼，打字速度更快 学会 markdown 写作，专注写作，自动排版，美观大方 付费为知笔记会员，重新利用 evernote 笔记。每天收藏微信文章，定期写日志，定期输出多看读书笔记 申请了微信公众号，随便记记生活的感触 搭建这个 GitHub 博客，专门撰写技术文章 开始在 GitHub 上做项目，虽然目前仅仅是仿照和修改别人的代码，不过至少是个好头 凡事皆可记录，给知识以通路。\n获得对知识的直观理解 在理解知识逻辑的基础上，更进一步简化逻辑链，更自然地理解知识概念，获得知识的深层次的直观的理解。比如之前学习的《线性代数及其应用》，向量、矩阵、特征值分别对应三维空间的点、变换和变换的方向不变形，对线性代数的知识理解就更深刻和直观。\n重视 “术” 层面的知识 知识分为 “道” 与“术”两部分，分别对应理论与实践，我一直花费比较大的精力在道上。**理论知识有个问题，大脑吸收很慢，只有和具象的事物结合，你才能更快地理解新知识，结合具体事例能更高效地吸收知识。**新年需要重新分配时间，更多地学习术，在实践中遇到问题反过来倒逼理论知识的学习，或许更高效更有效。比如 OFDM 的知识我都清楚，花费大量时间打磨理论细节，但是实际 matlab 仿真都很少，现在在 github 上建立项目，一点点熟悉，每一部分会更直观更清晰。\n2017, KEEP MOVING 2017 年，三十而立。我会更沉着地磨炼技能，更耐心地守望机会，更坚定地执行计划，更果断地一击即毙。KEEP SHARP, KEEP MOVING!\n","date":"2018-07-21T21:01:51Z","permalink":"https://blog.bugxch.top/p/2016%E6%88%91%E7%9A%84%E6%94%B9%E5%8F%98/","title":"2016，我的改变"},{"content":"要记住，你的目标是尽可能多地把时间利用在能给你带来最大价值的事情上。\n去年夏天我忽然对工作失去兴趣，我每天重复同样的事情：打卡，收发邮件，查看 bug 列表，处理相同的问题，答复客户的问话，或者按照模板写写无聊的技术报告。墙上的日历一页页撕掉，今天和昨天没什么不同，一眼望到头的时间空洞让我对未来没了期待，我就像困在四面密不透风的围墙里，焦虑惶惑，我总得做点什么让一部分的自己发生改变，《专注力》这本书给出了一部分的答案：**砍掉、忽略或者委派 80% 低附加值的事情，聚焦最重要具有高附加值的那 20% 的事情上, 并尽量使之有趣和简单。**书中的一部分内容启发我去作出适当的改变，所以我想连同自己的一些小心得分享在这篇书评里。\n二八法则 确认你最重要的 20% 工作事项，更多地重复这 20% 的工作，这当然就意味着，少做那些不太有利的 80%。\n这个法则给我最大的启发，不是调整工作内容，而是完全重新规划我的全部生活。我做的第一件事就是列出每天做过的所有的事件，包括但不限于刷手机，处理邮件，解决客户 bug，写新代码，看电视剧，练习听力，读书并写笔记，健身，写博客，打羽毛球等等。接下来重新评估每个事件的价值，砍掉或者压缩低价值的事情，将省出来的时间和精力更多地分配到高价值的事情上。比如我开始限制每天使用手机的时间，果断卸载掉不必要的 APP，腾出大块的固定的时间学习和实践新技能（我自称 “静音时间”），制订读书计划并尝试写读书笔记等等。工作中也一样，每天尽量快速完成所有维护性工作，把更高效的大段时间用在 coding 上。我还开始学习双拼输入法，大概过了一个月的时间，现在输入全程无阻碍。\n精力的重新分配也许会打乱之前的节奏，但是也冲刷了日复一日笼罩在头顶的的烦闷与枯燥，如果觉得生活无趣，为什么不自己找乐子呢？\n任务分解 一项过于庞大的任务会让人望而却步、心生不悦。要完成这种任务，秘诀是把任务分解成易于完成的子任务。要持续不断地对任务进行分解，直到这些子任务都很容易完成，直到你不再惧怕面对这些任务。\n如果说上一个法则教我跟不好的过去 say goodbye，那这个法则教我怎么完成复杂枯燥的新任务。大脑讨厌所有庞大虚无空洞的事物，它喜欢简单明确形象的事物，比起研究数学定理，我想大多数人更喜欢听故事。聊起英语学习这样的大题目我就头大，既不知道该怎么入手，也不知道有什么有效的方法可循，更不知道什么时候能达到怎样的水平，英语包括听说读写四个方面，每一个方面都涉及太多的内容，每个人又都有自己的一套说法。如何结合自己的英语水平，参考别人的意见，形成一套适合自身学习的有效的方法论，稍微想想这工程就挺让人崩溃的。\n这时候就需要分解任务，或许可以从时间上先将其分为一个月，一个季度，半年和一年四个时间尺度，再预估到了某个时间节点自己能够达到的英语水平，按照这个目标开展学习计划。需要注意的是，我要合理预估学习曲线，达到一定的练习密度，专注于首先能够奏效的事情上，比如对我而言，听力一直不好，我是个上班族每天可以投入的英语听力的的时间不超过一个小时，以这样的练习密度很可能我需要花费半年才能有比较显著的提升，心里有这样的合理预期，就不会因为一个月没有起色而懊恼甚至放弃继续学习。\n失败的唯一途径就是你的自我放弃。\n新计划的执行从来不是一帆风顺的，其中肯定会有拖延症的身影，作者在书里提到一些有趣的小 tips：练习不完美地做一些小事，然后观察会发生些什么（或者不会发生些什么），让自己严格而挑剔的内心缓和下来，完成永远比完美更重要。对于大的项目，你可以画一个类似温度计的进度表，将需要完成的任务以间隔形式在表中进行标注，并且标出目标日期。在完成每项任务后用彩笔涂出已完成的部分。把这个 “温度计” 放在你（最好也包括其他人）每天能看到的地方。\n保持专注 这是一个被说烂的话题，专注的重要性不言而喻，最好的方法莫过于更快地进入心流模式，如下图所示\n心流模式下当事人完全聚焦并沉浸到自己正在从事的活动中，长时间投入其中而不感到疲惫和厌倦，甚至感知不到时间的流逝。\n我觉得这简直就是上天对当事人的最大奖赏:)。如上图所示，心流模式下不仅能够磨砺更高的技巧，而且还能在乐趣中完成更具挑战性的任务，是不是非常美妙？所以问题就是，我们怎么才能快速进入心流模式并长时间保持这种神搓搓的状态？作者在书里提到，可以尝试想象任务完成之后的美好体验，想象越具体越形象越好，还可以学习 “巴普洛夫的狗”，在专注某件事的时候给自己奖励性的刺激，比如在学习编程的时候手边放一厅可口的啤酒，以后我想起编程嘴里就有了啤酒的好滋味，怎么会讨厌它呢？其实，我们这么做都是利用心理学和生物学的知识引诱我们的大脑，从事它潜意识里抗拒的工作。还有再坚持一会儿的耐心，简单的东西自然得来不费力，那些复杂的困难的部分肯定需要投入比简单任务更多甚至数倍的精力，古语云，如切如磋，如琢如磨，即是此意。\n就我个人的体验而言，连接 wifi 的手机和电脑是进入心流模式的最大的拦路虎，信息获取速度快，新鲜的资讯或者段子很容易获得小快感（想象烟花在脑子里绽放的样子），大脑适应了高密度强刺激快反馈信号输入，在需要低密度弱刺激慢反馈新技能的学习中就很难维持良好的运行状态。（当我每次浸淫在网络世界不能自已时，我就觉得大脑就像泡在碱水中的棉球，苍白而酸腐，不知道有没有学者比较过毒瘾发作的大脑内部的构造和化学成分是不是也是一样的呢？）\n怎么办？方法有二，断网关机扔手机重新将大脑改造成适应原来刺激的状态；或者可以将新技能的学习转化成高密度强刺激的模式，实际上现在很多的网站和手机 APP 已经在做这件事了，比如 codecademy，拓词，有道口语大师等。我大部分时间使用了第一种方法，我收起了自己的笔记本，手机调成静音放一边，每天晚上一个小时学习纸质书，并且写笔记，省心省事高效。第二种方法用的更多的是英语学习，借助优秀的 APP 进阶学习。我个人认为，处理艰深的复杂的需要更多脑力的任务，第一种方法不可避免，虽然会经历痛苦的戒断过程，但是任务达成之后的缓慢积累起来的快感一时无两（法国数学家 Cédric Villani 就说过，一个伟大数学定理的完美证明 “主宰的高潮大不同于性高潮，它足足维持了好几天。”）。\n信息焦虑 困扰那些天生好奇的、乐于寻求并接纳新观点的创造性思维人士的最大问题之一，是信息过量问题。我们很容易淹没在来自电视、收音机、杂志、报纸特别是网络灌输的信息中。如果你想要把精力集中在最有价值的事情上，学会如何处理不断增多的信息这一点至关重要。\n信息焦虑的最大原因就是网络时代巨量信息的大爆炸引发的信息成瘾。我手机里曾经装了很多的资讯类 APP，网易新闻，澎湃新闻，豌豆荚一览，华尔街见闻，每天上班间隙看看微博上有什么消息，刷刷这些 APP 有啥劲爆的新闻，晚上回家更是肆无忌惮，钻在被窝里把微信，微博，豆瓣，知乎，新闻通通刷一遍才肯放开手机悻悻然睡去。高密度强刺激快反馈的信息刺激改变了大脑的结构和化学成分，它处理这样的信息越来越顺手越来越停不下来，或者网上有一张非常有趣的图片，如果有 wifi 和充电器，我可以坐在厕所一直不起来；-)\n作者在书里建议消除信息焦虑，可以包括在机场或者其他人群嘈杂的地方使用使用消音耳机，试着有目的地吸收信息，当你对于信息的使用缺乏目的性时，你便无法掌控信息。如果一开始便带有目的性，你会自动对信息进行筛选过滤，这能帮助你分辨有关及无关的信息。总而言之，除了断舍离，还可以减少信息的摄入数量，提高信息的质量。其实在收起电脑之后，我的信息焦虑缓解不少，另外，我卸载掉全部的资讯类 APP，使用 RSS 阅读器 feedly（Google Reader 的绝佳替代品），每天午饭结束我在办公室刷刷当天的文章，这样重要的信息不会遗漏，也保证了我的静音时间。\n注：本文转自我的读书笔记进展不顺利？或许这样做更有效（专注力）书评，欢迎关注，欢迎点赞~\n","date":"2018-07-21T20:58:38Z","image":"https://img3.doubanio.com/lpic/s28133355.jpg","permalink":"https://blog.bugxch.top/p/%E4%B8%93%E6%B3%A8%E5%8A%9B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","title":"《专注力》读书笔记"},{"content":"不懂得逻辑学，小心被诈捐。\n罗尔求助事件刚刚过去不久，如果懂点逻辑学，那些掏了大钱的微信用户们可能就不会被诈捐了。\n连岳推荐，这本小书期待造就实践者，而不是理论家。整本书读完，论证缜密，但是实例不足，特别简朴的思想在结合现实问题时才能显示其真正的威力。我对其中的一些内容心有戚戚焉，另外想结合实际写写刷新我认知的新内容。\n心有戚戚焉 所有的逻辑推理，所有的论证，目的只有一个：找出某个事物的真相。\n开篇点题，逻辑本身就是发现真相并将其从谬误中分离出来的学问，方法就是全神贯注得确认事实的真实性，使用逻辑学的基本原理对这些事实进行推理，得出可靠的结论，并使用清晰有效的语言将其表达出来。需要特别留意黑体部分的字眼，因为\n事实可能是假的； 推理可能是错误的； 即便发现了真相，使用模糊的字眼也可能表达不清楚。 这里的问题展开说就比较杂乱了，大体分开说。\n一般情况下，我们总是想当然地认为相似的情景只不过是对曾经经历过的事物的简单重复。但从严格意义上来说，世界上没有两片绝对相同的叶子。每个情景都有它的特殊性，而我们必须对此特殊性保持敏感。\n这样的谬误不胜枚举：一线城市的房价涨价十年，是不是下一个十年也会持续涨价？你看谁谁谁和你一样的学历，现在做什么过得多好多好。具体会怎样，因素太多不好判断，但是仅仅通过表象的彼时判断此时，此物判断彼物，大谬矣。\n主观事实是指，由个人亲身经历的或间接通过别人的经历确认的事实。\n特别确认事实的真实性和可靠性，尤其是我父母那辈人，经常听谁谁谁说某某某咋咋咋，听起来有鼻子有眼，真要问起细节来语焉不详。我的同事说，中国股市就是投机市场，赚不了钱的，但是他自己从来没有炒股的经验。\n现实生活中，我们能亲身经历的重要公共事件非常有限。这就意味着，在大多数情况下，我们必须依靠间接证据。同间接求证一个事物真实性的方法一样，在利用间接证据求证一个事件的真实与否时，我们必须投入足够的注意力，因为认真审查证据来源的真实性及可靠性是最重要的。\n我的父母关于某个传闻，我的同事关于股市的认知来自媒体来自他人，他们没有亲身经历，事实可能未必如此。我们尤其要警惕媒体和他人消息来源的真实性，多考察几个信息源，多学学英文，多用用 Google。\n了解自己要表达什么。所以，回头重新审视观念的外在来源，理清思路，合适的表达将随之而来。\n说不清楚，思路混乱，很可能是根本没认识清楚考察的事物。比如最近我在写的关于奇异值分解的博客，数学的形式推理已经搞清楚了，但是背后的直观理解还是很模糊。想要写一篇高质量的博客文章，我还是要搜集很多资料，反过来做深入的数学推理之后的直观的理解。\n作者专门提到 “有效沟通”，分别强调四点**：说完整的句子，不要将主观看法当做客观事实，避免使用双重否定，根据对象选择合适的语言**。这都能成为写作和演讲的基本标准了好么！！！小时候我爸爸叫我拿东西，“你把那个柜子上的那个东西拿过来”，我的心里就凌乱了，我他妈知道是哪个柜子？神马东西？大学傻傻地翻图书馆《理论》，看得头都大了，云山雾罩不知道说了个啥，后来找一本老外写的书，真他妈利索，一看就懂。我国大部分专业学者的写作水平不敢恭维啊。补充一条，一图胜千言，能用图表，就少用文字。**\n不要将你主观上的某个灰色观念无限放大到包括整个世界，并且认为这就是世界的本来面貌。真相情况不明时往往会让人心情烦躁，避之唯恐不及，我们要设法尽力避免陷入这种困境。但是，当你陷入了不确定的泥潭时，也不能丧失信心。要明白：或许现在你不能弄明白事物的真相，但是，不确定的情况之所以可能出现，正是因为我们曾经有过确定性的经验。\n所谓的 “灰色地带”，就是有点线索真相还不明晰的时候，这就像一个人在山里迷路，四野无人，苦清孤寂，路途漫漫，这个时候一定不能丧失信心，KEEP MOVING！！！\n仅仅因为某些特征适合于整体的某个部分，就声称这些特征也必然适合于整体，这是明显的谬误。但是这种谬误人们常常避免不了，所以在面临类似的情况时应加倍小心。以偏概全是人类的某种天性，尽管这并不是什么好事。\n**以偏概全，在我看来，这是典型的缺乏概率思维的表现，它是两个最严重的思维错误之一。**言必称 “中国都…… 美国都……”；因为自己工作职位不好，就认为全公司都很烂；因为一两个人不好，就否定他们家乡的所有人（地域歧视）；因为读了两本烂书，就否定一门学科；因为一个人的部分缺点，而否定一个人的全部。这些是消极的方面，反过来也可能因为局部的特征而过高地估计整体的特征。只有采样足够多，才能保证整体的估计没有太大的偏差。我们所能做的就是多观察多接触，迟些下结论，或者根据目前观察所得，小心地将结论限定在合适的范围之内。\n论证是理性的探讨，不要将它和争吵混为一谈。论证的目的是发现真相，争吵的目的是击败你的对手。有许多人，虽然他们愿意和你争吵，但却不愿意或者没能力和你进行论证。不要浪费时间、精力和这种人进行争论。\n这句话是说，珍爱生命，远离傻逼。\n正如我们要检验自己的主张是否与事实相符一样，在论证中所用的专家意见同样要经过检验。这个世界上有太多自以为是的专家。检验的标准不是他们在说什么，而是他们是如何通过论证来得到它的。\n很多所谓的专家都是虚的，title 不重要，看他论证有没有道理最重要， 经济学著作写得好的，我首推茅于轼老先生。推荐他的两本书和一段访谈，看看他说的好不好？\n生活中的经济学 (豆瓣) 中国人的焦虑从哪里来 (豆瓣) 茅于轼：给你爱的人以自由 心意服饰商学院—在线播放—优酷网，视频高清在线观看，这段视频中由夫妻关系类比经济概念，给你爱的人以自由，哈哈哈~\n小心思考 小书里特别强调了情感与逻辑的关系，他的论述比较分散，但是很精彩。\n思想，即便是最纯净的思想，也不可能完全脱离情感的浸染。因为每个思想都是人这种天生的情感动物构思出来的。\n永远不要直接调动人们的情感，要努力使人们自己发现真相。这一条或许可以写进新闻记者的职业操守里去了。\n正如我们在对人不对事谬误中所看到的，通过提供与论证毫无关系的爆炸性情感信息来攻击对手。混淆视听提供了这种策略的另一种样本。它是故意提出一些无关的情感信息来分散对方的注意力。这种谬误有两个特点：（1）它直接诉诸情感，而不是推理；（2）它所提供的信息与所要进行的论证毫不相关。\n辱母刺死案中的相关细节报道是否真实存在？某某股权纠纷中的太太是否花钱买车和公司违背承诺有毛关系？娱乐圈媒体圈的从业人员，最善于搞臭对方的手段就是混淆视听。\n强烈的情感和清晰的思维是成反比的，一旦情感超过一定界限，引导论证正确进行的机会就随之归零。\n人类天生是情感动物，每个人对任何事情的第一反应就是情感，其后才有思想的跟进。去年的罗尔诈捐事件刚刚过去，现在的媒体运作太懂得如何挑动大众的情感为自己谋利了，普通大众也要在情感色彩浓厚的报道前，需要克制自己的情感反应，仔细考察事实的真实性，再做判断不迟。\n文末再推荐一本比这个更全面深刻但是也更枯燥的好书，思考的力量 (豆瓣)，大四买的，我带在身边已经有七年了，推荐看看~\n注：本文源自我的豆瓣读书笔记谨慎求证，小心思考（简单的逻辑学）书评，欢迎关注，欢迎点赞~\n","date":"2018-07-21T20:57:20Z","permalink":"https://blog.bugxch.top/p/%E8%B0%A8%E6%85%8E%E6%B1%82%E8%AF%81%E5%B0%8F%E5%BF%83%E6%80%9D%E8%80%83/","title":"谨慎求证，小心思考"},{"content":"他活了四十多年，观察人间就两种人。一种人的世界是：立场、感受、意见；另一种人的世界是：目标、方法、行动。他说四十岁开始创业就为把自己的思维方式从第一种切换到第二种。\n该文章转自微信公众号 三公子的人生记录仪（文末有该公众号二维码），原始问答来自知乎用户风尘棋客 ，点击链接即可关注。\n写在前面：这篇文章是我小长假在网上乱逛的时候看到了，非常了不起，我觉得有必要让大家都读一读，说实话，依照目前我的能力，真的写不出如此精彩且深刻的文章。\n文章最初发表在知乎，作者是风尘棋客，发表时间为 2015 年 9 月 19 日，原文地址我也放在公众号文末的阅读原文中。在知乎的帖子中，作者说明文章可以转载，故我选择将此文在公众号分享。\n此外，内容很多，阅读时间在 25 分钟左右，如果赶时间的朋友可以选择收藏，也可以选择直接打印后阅读。但无论怎样，都请大家抽一点时间读完，错过了也只能是你的损失。反正我仔细读完了。\n原文 今天让我们先把 “金钱真的有那么重要吗”，“为了赚钱牺牲生活品质是否值得”，“那个男生对我很好但就是买不起房我应该和他分手吗” 这些问题先放到一边，单纯而虔诚地跪倒在鲜红的毛爷爷脚下来探讨：\n如何才能有钱，那些有钱人身上是否真的具备一些独特的思维和品质，最终取得了令普通人望尘莫及的财富积累，我们和他们的差距究竟在哪里？\n如果你期待的答案是：\n专注勤奋毅力积累一万个小时，出门左转俞敏洪老师演讲录。 马化腾其实是富二代，巴菲特的父亲是国会议员，出门右转朋友圈 “揭秘白手起家的富豪神秘背景”。 商业上的成功很大程度上是随机性造就的，查看 “我们这一代人的困惑”，你可能之前没看懂。 如果上面这些答案都不能让你满意，我们继续。\n02\n你的高中老师不会告诉你，即使你再努力学习也照样买不起房。\n我现在身边过的最不开心的朋友，是上学的时候成绩最优秀的，现在又生活在国内的那一批。他们在学校的时候大多成绩优异，考试名列前茅，是老师眼中的骄子，同学们心中的偶像。虽然今天他们依然领着高于同龄人的薪水，却发现工作三年攒下来的钱依然不够在北京买一个厕所。所以觉得世界对他们很不公平。\n在漫长的求学经历和成长过程中，我们这一代人对于事业成功（其实就是赚很多钱）的认识高度的统一：努力学习，先考上一个好高中，再考上一个好大学，选择一个好专业，找到一份高工资的工作，拼命工作成为高级管理人员，从此衣食无忧生活幸福。可直到毕业了进入社会才发现，自己被灌输了近 20 年的美好人生蓝图，和现实相距甚远。为什么会这样呢？\n严肃的说，这是因为以中国目前畸形的经济结构和大多企业的利润构成，资产的泡沫程度要远远高于企业能为高素质技术人才支付的报酬。粗暴的讲，传统教育传递给学生的赚钱思路只是一场骗局，即把那几张卷子上的题做对越多的将来就越有钱，可是，这和现实世界中财富的分配方式几乎毫无关系啊，至少，和中国目前的国情完全不符。\n举一个简单的例子来阐述什么叫做企业的利润构成决定员工的收入，就比如说经营一家蛋糕店吧，美国公司的经营思路是找到最优秀的蛋糕师，提供味道最好的蛋糕，向全世界销售，凭借优秀的产品获得高溢价和高市场份额，来获取毛利进而付给优秀的蛋糕师高额的薪水；\n而中国的蛋糕店的老板们发现，自己的蛋糕怎么做也不可能比美国的蛋糕好吃，何况中国大众消费者对于蛋糕的消费能力也不强，真正赚钱的方式是提供品质一般但勉强合格的产品，通过一些独占的销售渠道，把蛋糕以大订单的形式卖给这些对蛋糕品质要求没有那么高的大客户，所以蛋糕师的水平并不太重要，能给公司签下订单的员工才是公司最有价值的人才。可与此同时，中国传统教育给我们灌输的思路是蛋糕做得越好的人，将来也就越有钱。\n这里的美国和中国不是绝对的，可以换成北上广和二三线城市，也可以换成互联网企业和炼钢厂，但你的工资是由你所在的企业的利润丰厚程度和你对利润的贡献程度所决定的道理，放之四海皆准。难以想象的是，如此天经地义的常识，我却发现身边有无数人完全不能理解，尤其是很多名校的毕业生，恨不能拿着一纸文凭向政府要钱，逢人便说假如生活欺骗了你。\n人生的痛苦主要源自错误的期待，认清事物的运转规律不会让你立即获得财富，但至少可以让你迅速放弃愚蠢的幻想。\n03\n你渴望成为的那种有钱人不是靠技能获取一份高工资的人。\n严格来说，即使在中国，凭借高超的技术领取高薪，最终取得财务自由也不是不可能的，只是难度极大，而且异常辛苦。没有过人的先天的条件和顶级的后天培养，大多数人所能习得的技能，都不是不可替代到让老板心甘情愿为你付一份远远超过市场平均水平的薪水的。只要你对中国绝大多数企业的收入获得方式稍加理解，就能明白技术骨干的收入是很难超过掌握客户的销售总监和组建团队和客户对接的项目主管的。\n美国的一个著名的喜剧明星 Chris Rock 在一场脱口秀中讲过一个段子：黑人在美国最多也就 rich，但不可能 wealthy。奥尼尔年薪两千万美金，那只能叫 rich；在奥尼尔工资支票上签字的那些白人老头们，才能算 wealthy。\n事实上，我们身边最常见的有钱人都是后者，他们不是技能过人的人，而是整合资源的人，简称老板，也是这篇文章想探讨的重点。\n值得一提的是，在现代的商业环境下，并非传统企业那种 100% 的公司拥有者才叫老板。项目投资人，企业的合伙人，装修队的工头，夜总会的妈咪，安排一队小弟在三里屯收二手 iPhone 自己坐在旁边抽烟的人… 但凡直接发起并促成商业活动的人，在我看来都是老板。\n你真正渴望成为的那种有钱人，不是超凡技能的人，而是寻找资源并整合资源的人。这就是学校和父母从来不曾告诉你的秘密，当然了他们之所以不告诉你，很可能是因为自己也没这么想过。\n04\n自我保护心理注定了穷人的宿命。\n人类天生习惯的自我合理化心态决定了大多数人注定是穷人。\n不信，可以看看你身边多少人热衷于分享 “盖茨的的书不会告诉你他母亲是 IBM 董事，是她给儿子促成了第一单大生意，巴菲特的书只会告诉你他 8 岁就知道去参观纽交所，但不会告诉你他国会议员的父亲带他去的，是高盛的董事接待的”，“还原聚美优品陈欧履历造假真相”，百度知道甚至有好几个问题都在研究 “马化腾究竟是是不是富二代”。\n我们的内心深处有一种与生俱来的强烈的自我保护机制，它会不停地暗示你，只有自己的想法和选择才是最好的最合理的。但凡当大脑扫描到有什么人和事会令自己的显得是如此的无知而无能的信息，这种保护机制就会迅速启动，收集一切线索去证明他们都是因为一些客观因素而侥幸成功，自己要是有同样的客观条件，只会比他们更好。\n而且，万一这些成功人士是自己身边非常熟悉的人，内心的保护机制会更加强大（君不见今年没炒股的人，看到身边炒股的人赔了，比自己发财了还高兴）。\n就像上学的时候，我们热衷于讨论学习好的人都是书呆子没出息，漂亮姑娘只喜欢开跑车的渣男一样；长大之后则变成了，同事升职了是因为会拍领导马屁，同学创业成功了因为家里给了巨额的启动资金。穷人的头脑是如此的敏捷，如果上述原因都找不到，还有最后一招杀手锏。\n他们就是运气好。\n是的，正是这种与生俱来的自我保护心理，维护了社会稳定，减少了自杀率，也让极少的一部分克服了这种心里的人，成为了有钱人。\n总结下来就是，穷人相信人和人之间的差距是客观条件所决定的，而富人相信这种差距的决定性因素是主观能动性。\n穷人的思维习惯是：他们做到了，是因为他们富二代 / 有关系 / 运气好，我没有这些，所以我做不到。如果我有这些条件，我也可以做到。\n富人的思维习惯是：他们做到了，我为什么没做到，我怎么才能做到？\n可怜的穷人们，不打破这种自我保护的心里，是很难摆脱一事无成的宿命的。可惜，他们中的大多数一生都沉浸在自我安慰中，从怀才不遇到壮志未酬，最终感慨平平淡淡才是真。\n05\n有钱人的思维是整合资源而不是拥有现成的资源。\n如果这篇文章你只能看一段，那就是这一段，没准它就能改变个别人的人生轨迹。\n其实很多穷人也不是甘心于一辈子领薪水的啊，他们只是在等机会，他们永远在等机会。\n我在美国留学的时候，惊人地发现原来每个留学生和他们的父母心里其实也都有一条走上人生巅峰的道路嘛。本科认真学习，积极参加课外活动，拓展社交网络，最终成绩优异简历丰富，找到一个大公司工作几年积累工作经验，继续名校 MBA 深造，出任跨国公司高级管理人员，最终调回国内担任中国区经理，甚至时机成熟了，凭借多年工作积累的经验和人脉，跳出来单飞最终创业成功。\n听起来如此酣畅淋漓的人生攻略，其实是最经典的穷人思维，穷人总以为有钱人的每一步都是按部就班顺水推舟得来的，所以要等着一切时机都成熟了，一切资源都获取了，才能开始行动。\n不出意外的话，这一天永远都不会到来。\n他们无法理解的是，世界上还有另外一小撮人，和他们拥有类似的客观条件，但却把他们觉得遥不可及的事情做起来了。这一小撮人，没有本金，找朋友借钱找投资人投资甚至找银行贷款；没有技术，自己去现学或者找到懂技术的人帮自己来做；没有关系，找人介绍请人吃饭送礼屡败屡战；没有客户，一个一个冷拨电话登门拜访甚至办公室门口堵着。\n上面这种人，就是传说中的老板。\n当你真正开始做一个整合资源的老板的时候就会发现，你之前自以为拥有的资源和人脉远没有你想的那么好用，任何一个商业活动从无到有，都必然要经历那些团队不整没有客户的阶段，滴滴打车两年前还在在北京机场 T3 一个一个拽着出租车司机下载 App；以雷军在互联网圈二十多年的人脉，创立小米的时候光一个个登门挖人就挖了近一年，相比之下，你觉得自己能有的那些资源又能有多管用呢？\n切记，老板的实质是寻找资源然后整合资源的人，并不是拥有现成资源的人。\n更进一步说，一切商业机会都包含了大量的未知因素，而鉴于人类对于一个未知事物的群体接受度的判断力是极其有限的，一个优秀的老板擅长的是边做根据形势快速调整自己的商业活动，而不是事先把一切事情都预料好了。你能想象亚马逊的创始人当年在网上卖书的时候，已经计划好了公司的业务要包括电子阅读器，电商，流媒体，云计算，无人机吗？\n为什么穷人等待的机会永远不会到来？等你把一切都看的清清楚楚的时候，市场早已经被那些趁着一切并不明朗就冲进去的人瓜分干净了。真正的好机会，永远都存在与未知中。\n同样的道理并非只存在于商业世界，每个人生活中最好的机会，几乎都出现在那些你没有完全准备好的时候。\n还记得刚去美国的时候，我听说高中的数学课代表去新东方做了托福老师，班里的同学谈起这件事，语气中大多充满了怀疑和嘲讽，因为大家都清楚他高中的时候学习好是因为数理化成绩优异，英语水平根本不行。他们想的一点没错，后来我才得知，这哥们当时连托福都没考过，但就是一咬牙硬着头皮上去应聘还成功了，结果最初过得心惊胆战，做梦都怕被学生从讲台上赶下来，于是每天疯狂的做题备课恶补英语，好不容易坚持了下来。\n而两年之后，嘲讽他的人还是当年的样子，他已经成了新东方的托福名师，公开课出现在新东方官网上，学生遍布北美。后来我默默地在家里看了他的讲课视频，比起我当年崇拜的那些新东方名师毫不逊色。\n我忽然想起了罗永浩当年写给俞敏洪的求职信，试想如果罗老师当年认为要把英语练到王强老师一样才能敢去新东方应聘，现在可能也只是一个吉林延边的文艺老愤青罢。\n你看，真正把事情做起来的人，考虑的问题的过程其实是这样，这件事我一定要做，缺什么东西我去想办法去争取。而什么做不起来的人，永远在等待时机成熟。\n无论是工作还是生活，成功的人必然是有勇有谋，但勇又大于谋。相比之下，勤奋专注聪明简直只能算雕虫小技，唯有勇气才是一个人出类拔萃的核心竞争力。\n最后，如果你的抽象思维能力实在有限，必须得看十分具体的例子去理解究竟什么才是寻找资源并整合资源，强烈推荐你上网看两个故事，一个是星巴克老板舒尔茨当年在西雅图开第一家咖啡店的始末，另一个是杨洁导演拍摄 86 版西游记的过程。\n以上，就是我在读了这么多年书，看了那么多案例，和自己在残酷的实践中，能给出的关于 “不是富二代，不是官二代，很想成功，是不是就会成功了” 的最好答案。至于你觉得它是醍醐灌顶还是勾兑鸡汤，看你的了。\n（三公子注：正文到此结束，知乎文章发出来后，作者被一堆人围攻，为此他又写了一个后续，大家接着看）\n06\n没有回复留言的习惯，但是鉴于逻辑有明显硬伤的小朋友开始成批量涌现，在这里简单更新一下：\n其实在上一次回答 “商业分析能力是怎样炼成的” 的问题时，我就惊奇的发现，近 700 条评论中，反对意见极少是关于我提出的那个 TTPPRC 商业模型的具体内容，而全集中在 “好像看明白了这个就能赚钱了” 和“你知道这么多也没见你多成功”。 说心里话，我之前实在缺乏拯救这些愚蠢的小朋友的兴趣，因为我觉得作为一个智力及格的成年人或者未成年人，最起码明白什么叫做 “充分条件，必要条件，既不充分也不必要但是会极大地增加实现该结果概率的条件”。 直到刚才我仔细思考了一下，也许这也是一种经典的穷人思维方式，就是对于他人提出的一切解决一个问题的方案，都把它们默认为必须是 “充分条件”，只要发现实现同样的结果的人采取了其他方案或者采取了该方案的人没有实现相应的结果（比如：有钱人也有没什么商业分析能力的，有很强商业分析能力的人却没有很有钱），穷人们就洋洋得意地以为自己才是更理智更清醒的。 天啦撸，怎么会有精神正常的成年人会相信：理解一个商业模型，就必然能导出赚钱的结果呢，这不是弱智么。TTPPRC 商业模型对于商业上的成功而言，很明显是一 “既不充分也不必要但是会极大地增加实现该结果概率的条件”。\n现在看看这个答案下面的一些留言： ————————————————— 1、批评了其他鸡汤，自己又做了一碗鸡汤 勇气么 你睁开眼看看多少人在折腾，他们缺乏勇气么。 感觉翻译过来其实就一句话：真的想做就去做且肯定会成功，否则就是你其实并没有那么想。 2、“然而其实又是另一碗鸡汤。说得好像你像富人一样去拼，去整合资源，去开拓市场然后就会成功一样。要真是那样，这世界不知道多少富人了。”\n3、” 你这种思维放在十五年前还可以说的过去，但是现在有思想，有行动的人多如牛毛，可是成功的还是极少的那几个人，个中因素其实就是你文章开头说的谁谁谁其实是富二代云云……” 4、“现在许多事情，绝不是会整合一下资源，有一颗勇敢的心就可以成功的 做到这些，充其量也就是个小老板罢了” ————————————————— 亲爱的朋友，你仔细看看，我在全文中可没有半句话提到，有魄力去整合资源”就一定”能成为富人，也没有提到 “有钱人 100% 就得是有魄力” 啊，王思聪就不用啊。 我给出的答案中的思路很清楚，清楚到完全没想到这么多逻辑混乱的小朋友原来需要单独这么一段： 绝大多数富人都是整合资源的人，而一个人没有背景，没有资源，白手起家，想实现财务自由这种包含高度不确定性的结果，拥有超出常人的勇气和强大内心驱动力是一个既不充分也不必要但是会极大地增加实现该结果的条件，而且在一个普通人在成为整合资源的富人这个结果的诸多条件中，可以算是最重要的（在做到了这一点之后，你还得需要勤奋专注坚持，锻炼商业技能，阅读 TTPPRC 等等一系列非充分条件，才可能大大提高成功的概率），重要到可以算是一个成为富人必要条件。 从这个答案中读出来 “有勇气就会成功” 的小朋友，你欠缺的确实不是勇气，是智力。 有勇有谋不一定能财务自由，但是朝九晚五确实可以避免饿死。上进体贴不一定能找到聪明漂亮的女朋友，只有嫖娼才能保证你睡到美女。\n这个世界上越是有价值的结果，越没有充分条件。（这句话的逻辑是：“没有充分条件”这件事，可以算是，“有价值的结果”的必要条件。也就是说，”没有充分条件 “的结果就不一定有价值，但是” 有价值的结果“必然没有充分条件）。 我能帮你的就到这了。\n（三公子注：希望这篇文章能够让大家悟出些什么。我非常认同作者的一个观点，穷人永远都为自己的 “不作为” 找借口，在所有的讨论场合中，都在努力寻找所谓的 “漏洞” 来攻击对方，以此给自己 “不需要努力” 的理由。但富人，或者说有潜在富人思维的人，会寻找一切可以拿来为自己所用的技巧和方式，对一切触发好奇心的事情都愿意投入时间和精力去尝试，并且永远不为失败找借口。）\n对我的启发 认清现实 就像文中所说，在中国现阶段畸形的经济结构下，不是技艺越高薪资越高，薪酬与承担责任和风险成正比。放弃幻想，认清现实，富贵险中求。\n打破自我标签 不要嫉妒，不要仇富，不要过度自我保护，别人比我能赚钱就是比我能赚钱，有差距不能一股脑地归咎于自身以外的条件，条件再困难，还是要想办法努力过得更好。就像罗胖说的\n他活了四十多年，观察人间就两种人。一种人的世界是：立场、感受、意见；另一种人的世界是：目标、方法、行动。他说四十岁开始创业就为把自己的思维方式从第一种切换到第二种。\n不要抱怨，嫉妒，酸腐，而要想想为什么？接着就是计划，执行，追赶。\n必须有勇有谋，勇字当先 开局需要勇气，老板的核心竞争力之一就是勇气。\n主观能动性很重要 社会在变，一门技艺吃不了一辈子的饭。我是学通信的，但是工作四年之后，我觉得技艺解决温饱问题，社会运行结构之复杂，有必要在温饱之余再了解其他的学问。目前的职位仅仅是初入社会交给我的角色，我不可能干一辈子的，就像刚刚出生的孩子，一旦熟悉了周围环境，我就要试图去做些什么改变自己的境遇，对社会亦如是。适应角色之后，如果觉得束缚，我就主动寻求改变。遵循自己的兴趣，不放过任何一个微改变的机会，玩玩树莓派，学学摄影，研究研究投资，学学 CSS，我的未来可能就在这里~\n","date":"2018-07-21T20:56:11Z","permalink":"https://blog.bugxch.top/p/%E8%BD%AC-%E4%BB%80%E4%B9%88%E6%89%8D%E6%98%AF%E5%AF%8C%E4%BA%BA%E6%80%9D%E7%BB%B4/","title":"[转] 什么才是富人思维？"},{"content":"现实生活中失败是必要的里程碑，它能带领我们离成功越来越近。学会拥抱失败，期待失败，接受失败，并准备直面失败。\n2 月份在上海书城闲逛时候看到《软技能》这本书，作者的很多观点让人耳目一新，当时在书城读了一半，回来后果断买了本，受益匪浅。全书最宝贵精神财富有两点：\n不怕失败。现实生活中失败是必要的里程碑，它能带领我们离成功越来越近。学会拥抱失败，期待失败，接受失败，并准备直面失败。 坚持不懈。坚定持续地做一件事，才能不断调整目标和方法，一步步接近最终目标。 书里的内容非常庞杂，作者分了职业、自我营销、学习、生产力、理财、健身、精神七大篇，我将其中的对我影响比较大的观点记录如下。\n职业 我不是公司的仆人，我是拥有自己产品或者服务的商人。 职业生涯第一要务：转变心态，从被卖身契束缚的 “仆人” 转变成拥有自己生意的商人，从每个月领着死工资的职场人员变成主动寻求业绩的小型公司。这是会对职业生涯产生深远影响的观念改变。接下来就要想作为一个企业我能提供什么？于是需要专注于某个细分领域中打磨技能，推销自己。\n人际交往远比你想象的重要。 即便是安安静静写代码，也是要写出来给人看的，发邮件，开会，制定计划，检查执行，总结报告…… 所有的这些都需要和人打交道。作者推荐了卡耐基的《人性的弱点》。\n专业化很重要，一定要在某个专业方向上有自己的专长。 不做面面俱到的 “通才”，而要做深耕细作的专才。不能简单地说 “我是 java 开发人员”，而要明确告诉别人，你是 Web 开发栈 / 嵌入式系统 / 特定操作系统 / 移动开发 / 软件系统的开发人员。任何技能都必须附着在某个细分领域才能发挥它的威力，专业化程度越深，潜在机会越少，但是获得这些机会的可能性更大。公司不需要通才，它们更需要在某个领域精深的专业人才，每个人的精力有限，不可能面面俱到，要想精通专业即周边领域已是难事。\n承担责任，引人注目，自学技能，成为 problem solver，才能继续攀登职业阶梯 更多金钱还是更多责任？选后者，金钱总是追随责任。显而易见，职位越高不仅仅意味着薪酬更高，还有与之而来的责任，但是很多人常常搞不清楚二者因果关系，先是主动承担责任而后才有升职加薪，而不是反过来。作者给出的建议有：去没人愿意涉足的领域，在新的领域深耕细作，建立自己未来帝国的根基，帮助团队的其他成员成长，培育自己在团队的影响力。\n及时反馈很重要啊！主动向老板交代任务的进度，即便项目进展很糟糕，也要即时给他一个进度条，让他知晓项目遇到的困难，取得的进展。日报，周报，这些东西还是有用处的。\n在任何公司里，最有用的就是那种看似没有克服不了的障碍的人，成为这种人是获得晋升的可靠方法，俗称 “救火队长”。\n应对职业倦怠的唯一方法，就是硬着头皮穿过那堵墙。制定计划，坚决执行。 自我营销 这是转换心态之后自然而然要做的事情，如何将自己的产品和服务推销出去？通过各种方式建立自己的专业品牌，就像图像处理就用 photoshop，工程建模使用 MATLAB，软件推荐就能想到异次元软件世界 - 软件改变生活！一样，一想到 java 程序员就能想到你。\n个人博客。建立自己的专业博客，使自己的技能和服务输出可见化，高质量输出，乐于分享，阮一峰的网络日志也是非常好的案例。如果你比较懒，不想自己搭博客，简书和知乎专栏也不错哦；\n社交媒体。Twitter/Facebook/Weibo/Linkedin，甚至包括别人的博客，多与大牛互动，多分享自己的文章（当然前提是有用有料高质量）；\n播客频道。youtube/youku，所有可以想得到的能够分享视频教程的地方，制作有趣的视频分享之；\n写书。难度系数相对较大，有人在 CSDN 上写博客最后出书成功的，先一篇篇高质量地写吧。另一个途径是翻译，比如阮一峰的黑客与画家 (豆瓣)，在程序员之外的圈子赢得不少知名度；\n培训 / 演讲 / 报告。当然最好是在有影响力的技术大会上作报告，但是如果水平不够，也可以在你们同事之间小范围写个 PPT 交流交流~\n技艺 这是一个大课题，方法比努力更重要。作者说了 “十步学习法”，宗旨是 “聚焦学习范围，关注重点内容”，我最容易犯的错误是，不知道学习的边界，容易从主干知识溜到旁枝末节上去，一次想把所有的东西都搞定不可能，所以对于旁枝末节的知识学会使用接口就可以了，没必要从上层到底层每个原理都搞清楚，太累了。\n确定范围，筛选资料，边学边做，乐为人师。这四点 hin 重要，聚焦学习目标，做持续有效的练习，付诸实践，并将心得分享给他人，具体可以参考《十步学习法》学习笔记。\n生产力 提升生产力的秘诀：设定大目标，然后分解成小目标，制定年度 / 季度 / 月 / 周计划，将所有的目标分解并落实到细小的时间点上，坚定执行，专注于当前的任务。\n缓慢稳定的节奏工作，要优于快速但缺乏持久和坚持的工作方式。 戒掉电视 / 新闻媒体 / 社交网站，将时间用在最好的地方。 创建惯例，让惯例常态化，避免还没干正事就耗尽意志力。 生产力的秘诀在于：长期坚持做一些小事。 任何行动都比不行动要好。不要掉入恐惧陷阱，优柔寡断会丧失机会。有时候，当完全不知道要做什么的时候，最好的行动就是做一些事情，然后在前进途中再调整方向。小步快跑，路上调整。 理财和健身一代而过，我昨天开了股票账户，开始学习金融知识，健身我现在在坚持跑步，每周 40 公里左右，这几天要加入无氧运动，锻炼出腹肌~~\n精神 这一章很重要，精神是笃志前行的动力源泉。打破别人和自己的贴在身上的标签，即时从小时候就这样，养成积极的思维习惯，构建积极的自我形象。\n一个持有积极心态的人看到好的一面往往比坏的一面多，并不是因为这些状况客观上是好的，而是因为他们认识到他们有选择的权利； 积极心态者不会认为自己是环境的受害者，相信无论身处何种环境，都有能力改变自己的境遇； 将挑战看成需要克服的困难，生活就是一关一关地打怪升级，而不认为自己被逼到绝境。 保持持积极心态的方法\n保证充足的睡眠，让大脑得到充分的休息； 相信自己能做到，不然肯定做不到。 劳逸结合，健身锻炼，不要小看这一点哦，身体和心灵是互相影响的，身体健朗，心理也会更健康； 坚定地、持续不断地、有意识地重复做一件事，将思想转向积极的方向，知道潜意识掌握大局； 在脑中构建清晰积极的自我形象，想象自己成功，找到清晰的成功路径，切实模仿，坚持不懈 我写完了，不过我发现有个人比我写的好的多，大家可以参考下简书笔记《软技能——代码之外的生存指南》 - 简书。\n","date":"2018-07-21T20:55:01Z","permalink":"https://blog.bugxch.top/p/%E8%BD%AF%E6%8A%80%E8%83%BD%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","title":"《软技能》读书笔记"},{"content":"为了更高效地吸收知识，需要对书籍的难易程度进行分类，不同类别的书籍阅读方法不同，投入精力不同，输出形式不同，阅读强度不同。\n阅读体系 阅读体系的核心思想是数字量化书籍的 “软硬程度”，根据不同硬度给予不同的学习强度，分层吸收，保证精力的科学分配。我自己设定阅读共有 4 个档次，其中 1 最 “硬”，信息密度最高，需要投入最多的精力，4 最 “软”，类似于随手翻到的传单或者在路上捡到的画册，信息密度很低，快速翻过即可。针对不同的硬度书籍，使用不同的阅读策略，可以在减少不必要的精力投入，充分利用学习时间，高效学习相关知识体系。阅读策略包括如下一些指标：\n系统性。这是衡量书籍的指标，书籍的知识体系是否完备，各个部分之间是否紧密联系，数学类书籍系统性最强，散文类书籍系统性就很弱。 完成度。这是个人精力投入完整性指标，是否有必要读完所有的内容？还是仅仅读取其中的部分信息即可？亦或是仅仅蜻蜓点水即可？该指标与阅读目的书籍信息密度相关，也与自己的知识储备相关。比如，已经读过相关的书籍就没必要面面俱到都看完了。 输出形式。学以致用，知识越硬，越需要高强度清晰的输出。一来整理知识，日后便于提纲挈领，将短时记忆转为长时记忆，固化于心；二来倒逼输入，逼迫自己将学习的东西讲清楚。 练习强度。学习最怕一曝十寒，所以保证单位时间内的足够的学习强度，持续不间断的输入才能将知识一步步踏踏实实地印到脑子里，不然很容易遗忘，重新进入这种状态又要花很多时间和精力。 累计时长。在阅读少许书籍内容之后，结合自己的需要，就可以将其分类，提前划拨阅读时长，不能超过这个界限，以免浪费时间。 下面从这几个维度对这 5 种书籍总结归纳。\n硬度 系统性 输出形式 练习强度 (次 / 周) 完成度（%） 阅读累计时长（小时） 举例 1 非常系统 博客系列文章 / github 代码 / 阅读笔记 5+ 95+ 30+ 《C Primer Plus》 2 比较系统 博客文章 / 阅读笔记 [3,5] 80~90 20- 《刻意练习》 3 系统性不强 阅读短评 2 50~60 5- 《打破自我的标签》 4 零碎片段 豆瓣标记 1- 10- 1- 《人生需要揭穿》 上面的表格只是初步的判断，之后会根据实际经验对参数进行修改。需要补充一点，5 级我没有写，因为影响不大，5 级的阅读类似于机场或者火车上翻阅杂志的强度，随便看看即可，不需要耗费什么精力和脑力，因此写不写无所谓。\n意义 标准只是参照，实际阅读可以遵循如下的步骤展开：\n提高硬书的比例。硬技能（通信 / 计算机 / 数学 / 工程能力 / 产品能力）是立身之本，目前还处在职业生涯初期，提高工作技能，就能快速提高收入，至少目前的两年之内需要急速提升自己的硬技能。 带着问题读书。这样效果最佳，首先明确自己阅读的目的何在，学习一门技术？还是改进自己的方法？了解一段历史？还是提升对不知道事物的认知？不能漫无目的瞎逛，浪费时间。 预估时间。拿到书本，大体浏览目录，作者，豆瓣评论，自己翻阅感兴趣的部分，迅速对书籍分档，之后预估阅读时长。结合番茄工作法，严苛按照时长推进阅读进度，不能超时。这就是阅读的 time schedule，初期可能会有差距，但是之后的预估时间需要越来越精确。 单刀直入。根据阅读的目的，直接、简单、粗暴地阅读强相关部分，如果强相关读不懂再回过头补充需要的知识，边补充边试验，带着问题尽快拿下这个知识点。 保持强度。依照强度持续学习，保证学习密度才能将其刻印在脑海中。 定期输出。保证输出质量，阅读后提炼总结，尤其需要明示自己的收获，以及需要改变的行动。 ","date":"2018-07-21T20:53:18Z","permalink":"https://blog.bugxch.top/p/%E5%BB%BA%E7%AB%8B%E9%98%85%E8%AF%BB%E4%BD%93%E7%B3%BB/","title":"建立阅读体系"},{"content":"当我们在提高自己时，我们才最像是人类。和其他任何动物不同，我们可以有意识地改造自己，以我们选择的方式来提高自己。这使得我们和当今世界以及有史以来的其他物种区别开来。\n这是第一本在网易蜗牛读书上看完的书，看这本书使我**相信使用合适的方法，通过长时间专注的有效努力，任何成年人都可以完成体力尤其是智力强相关的技能上的长足进步甚至重大突破。**怎么能将此书中的知识吸收利用呢？\n首先，行动的前提是破除错误的旧观念。\n破除旧观念 一万小时定律 一万小时定律是错的，要想成为顶尖高手仅仅靠单纯的努力是不行滴。简单重复的累计一万小时的练习并不能帮助你成为该领域的顶尖高手。\n一万块砖头简单堆砌在一块还是一万块砖头，只有工程师设计施工，经过精心布排之后才能成为雄伟的建筑。\n成功并不与练习时间完全成正比，天赋虽然不起决定性作用，也会是一大影响因子。 练习的效果并不与时间成正相关，与练习方法也很有关系。 任何行业都不存在一万小时的练习最低阈值。 以我的切身经历为例，我做 GSM 协议栈开发，目前以及累计快四年时间，但是很明显我的水平比起 2 年前并没有太大差别。还可以想想，如果一个傻子让他学习 coding 连续一万小时，会有效果吗？肯定不行啊。这个法则对的地方在于任何一个有着悠久历史的行业或领域，要想成就一番事业，致力于变成业内的杰出人物，需要付出许多年艰苦卓绝的努力。。关于一万小时的讨论也可以参见万维钢老师的这篇博文怎样练习一万小时。 你的大脑依然强大 身体和大脑适应力极强，个人的潜能可以通过训练重新构筑。这句话是说给成年人听的，虽然大多数情况下小孩子的学习能力比成年人强，但是成年人却也常常低估大脑的学习适应能力。哎呀，年纪大了学不动了，我父母第一次接触智能手机就觉得学习来很费劲，要弃掉，但是也有 80 岁高龄老太太，退休后自学编程半年，开发新款游戏成码农呢。大多数人又会说，人家有天赋啊，人家有基础啊，真正电脑普惠也就是上世纪 90 年代，最多 30 年前那会儿老奶奶也 50 多岁了，有毛基础有毛天赋？ 之所以大多数成年人无法做到老奶奶这么厉害，有如下几大原因：\n根植在大脑深处的自我设限。最典型的思维错误就是出了学校我的这辈子的学习过程就结束了，而且随着年龄的增长我的学习能力也越来越不如年轻人，即便我努力去学也不可能达到年轻人的水平了，我可以放弃继续学习了。在现代的高速发展的社会里，放弃学习就是放弃自己，放弃掌控自我命运的机会。我个人觉得随着人均寿命越来越长，我们这一代人**学校学习时间的占比会越来越低，也就是说即便毕业之后，还要不停学习大量的新技能，才能在这个社会里获得满意的生活状态。**成年人的身体和大脑的适应能力远超一般人的想象，虽然成年之后的身体能力下降很快，但是心理学习能力依然强大，你的大脑没有变得静止，通过适当的刺激与训练，大脑自己可以使用新方法达到你想要的学习效果。 练习过程中过早的自我放弃。很多技能的习得需要长时间的有效练习，练习一首小提琴可能就需要半年时间，学会操作手机可能只要一周，如果期望在一周之内学会小提琴就明显不现实，成年人对学习曲线估计不足，就很容易过早放弃。 身体和大脑很少受到挑战。俗语就叫待在舒适区太久，白领几乎不用做什么重体力活，所以如果不锻炼身体机能就会缓慢退化，很多人一辈子只干一份工作，而且是花费很多时间练习很有局限性的一小部分，所以怎么可能发展出新技能？ 懒。看书一小时就困，即便躺在床上睡懒觉也不愿意去游泳，每天就是肥皂剧，睡觉，吃饭，发呆，聊天，无聊，即便天才人物也要经过大量的有效训练才能达到高水准，更不要说普通的成年人了。 总结下就是，如果想在变化越来越迅速的现代社会立足，即便在离开学校之后仍然必须坚持学习，不断拓展新技能。虽然不及 20 多岁的能力，我的大脑依然具有强大的学习能力，足够发展出新的技能并达到可观的水准。学习新技能，使之达到一定的水准，仅仅依靠长时间高强度的刻苦练习还不够，还需要讲究合适的方法。\n任何人都可以进步，但需要正确的方法。如果你没有进步，并不是因为你缺少天赋，而是因为你没有用正确的方法练习。\n有了上面的意识，就自然引出下面的问题，那怎么才是正确的方法？我该如何有效学习新技能呢？\n刻意练习 下面以打篮球为例讲解刻意练习。\n初级篇：有目的的练习 刻意练习的初级阶段是有目的的练习，与一般的散漫的练习相比，有目的的练习有如下几个不同点：\n目标具体明确。这个月篮球罚球训练的目标是 50 次出手，罚中 30 次。为了达到这个目标，你会将目标分解成第一周投中 20 次，第二周投中 25 次，直到最终达成目标。定义明确的具体目标，可以有效运用于引导你的练习。 高专注度。要想取得进步，必须完全把注意力集中到你的任务上。如果投一会儿篮球，看一会风景，然后再歇一歇再停一停，训练效果可想而知。专业水准的篮球运动员必然专注于自己的训练目标，并且在训练过程中保持高度专注。 及时准确的反馈。幸运的是，投篮是一个反馈非常直观的运动，有没有投中一目了然。如果投不中，你就会自己思考，为什么总是失败？动作不标准？角度不准确？还是力量不够？或者还有其他什么问题？**不论你在努力做什么事情，都需要反馈来准确辨别你在哪些方面还有不足，以及怎么会存在这些不足。**如果没有反馈，你不可能搞清楚你在哪些方面还需要提高，或者你现在离实现你的目标有多远。他会迫使更加系统更加全面地磨砺技能，精进技艺。 走出舒适区。对于任何类型的练习 ，这是一条基本真理：如果你从来不迫使自己走出舒适区，便永远无法进步。我的关于协议栈的知识在两年前已经基本停滞，很大的原因就是那时的技能已经足以应付工作中 95% 以上的内容，没有被动或者主动地去学习别的知识的压力和动力，我一直舒服地呆在舒适区，就像呆在温水里的青蛙。要想取得进步，每次都精心挑选下训练的目标，挑战下处在自己能力边界的事情，让自己有那么点不舒服不顺手，但是又不至于远超过认知负担而心生畏惧，操作熟练之后你的技能也就获得提升。 以上是这本书里的观点，我还要补充一条，\n足够的训练强度。一个月读一本书和一年读一本书的效果是不同的，一天读 10 页和 10 天读 1 页的效果肯定也不同。训练强度需要适度，过于密集超出大脑的认知负担不仅容易产生疲劳感，而且吸收理解的内容并不会增多，过于稀疏则不足以在大脑内形成相关记忆，训练效果近乎于无。 进阶篇：刻意练习 其实如果能够做到有目的的练习中提到的几点，假以时日几乎可以肯定，每个人的技艺都能达到比较高的水平，但是如果要成为领域中的顶尖高手，仅仅做到上面的几点还不够。那还需要做些什么呢？刻意练习。刻意练习是有目的的练习的进阶版，它包含了之前的所有特点，除此之外，它还包含了其他两个重要的不同的地方：大量复杂丰富的心理表征和刻意模仿。\n心理表征 顶尖高手和优秀选手之间的重大差别在于，杰出人物经过年复一年的练习，已经改变了大脑中的神经回路，以创建高度专业化的心理表征。\n心理表征是一种与我们大脑正在思考的某个物体、某个观点、某些信息或者其他任何事物相对应的心理结构，或具体或抽象。维基百科上的解释是\nA mental representation (or cognitive representation), in philosophy of mind, cognitive psychology, neuroscience, and cognitive science, is a hypothetical internal cognitive symbol that represents external reality,[1] or else a mental process that makes use of such a symbol: “a formal system for making explicit certain entities or types of information, together with a specification of how the system does this.”\n翻译过来的大意就是，心理表征是外部现实在内心世界的符号映射。书中举例盲棋大师记忆，同时可以和十几个人下棋，而且不看棋盘可以迅速判断局势的优劣，很短时间就能明确对弈的策略，而普通人即便睁眼看棋看到的也只是分崩离析的棋子。大师与普通人的区别，不仅在于对棋子位置的编码记忆，而且在于棋子之间的联系和全局宏观形式的把握上。一方面，心理表征使大师着眼于全局来观察，看到 “一片森林”，这是新手无法做到的；另一方面，心理表征还使大师可以在必要时把注意力集中在具体的招法上，观察 “一棵树”。\n象棋大师看一眼棋局就能知道双方力量的悬殊差距，以及目前可行的致胜策略；优秀的球员具有超强的球场解读能力，可以感知各个球员的移动方向，与那些球员的互动最为重要，什么时候传球什么时候奔跑能做出更好的决策。书中举例数字记忆的实验者，每次将自己听到的数字分为若干组，每个组包含 3 个或 4 个数字，然后将这些组编码到长时记忆中，变成有意义的记忆，再将这些记忆与检索结构关联起来，这样一来，他能记住接下来的数字组是哪些。\n心理表征将复杂抽象的事物进行重组、抽象、转化和编码，使其具象化符号化存储在我们的大脑中，将短时记忆转化成长时记忆，这样利用之前具有的记忆优势就可以在短时间内迅速处理大量的信息，很快做出最优决策。杰出人物的心理表征包含从宏观到微观的各个层面，巨细无遗，层次丰富，架构完整，因而处理专业问题得心应手。\n刻意练习 实施步骤 刻意练习的基础是有目的的练习，除了之前提到的几点之外，还需要做到如下几点（需要说明的是，虽然这些目标之间有一些先后顺序，但是在实际操作过程中并没有明显的界限，互相之间可以互相促进，而且每一条都可以根据训练情况更改）：\n**模仿导师。**追随行业的杰出人物，得到他们的指点是提高自身技能最有效的方法，如果不能得到指点，针对性地思考他们都做了什么，使自己从同一个行业或者领域中那些成绩不太卓著的人之中脱颖而出，同时还要思考哪些训练方法帮助他们实现了卓越。我们只有努力去复制杰出人物的成就，失败了就停下来思考为什么会失败，然后再去复制，一旦失败了，再次停下来思考原因，如此一而再再而三地尝试，才能创建有效的心理表征。 精心设置目标。将漫长的旅程分解成一系列可控的目标，并且每次只关注它们中的一个，甚至可以在每次达到一个目标时，给自己小小的奖励。 专注和努力至关重要。要记住：如果你在走神，或者你很放松，并且只为了好玩，你可能不会进步。 大量重复的有针对性的练习。 有目的的练习，或者说刻意练习，其标志是你努力去做一些你无法做到的事情，去完成一些处在你的舒适区以外的任务，而且，你一而再再而三地练习，着重关注到底可以怎么做好它，在哪方面还有缺陷，以及你可以怎样进步。反复做一件事情，目的是找出你在哪些方面存在不足，并且聚焦于在那些方面取得进步，试着采用不同的方法来提高，直到你最终找到适合自己的方法。 跨越停滞阶段。跨越停滞阶段的一个有效方法，是以新的方式挑战自己的大脑或者身体。比如，变换日程，减少或者增加重复的次数，增加训练的花样，反复练习专攻弱点。 保持动机 保持动机也许是每个投入到有目的训练或者刻意练习中的人最终要面对的最大问题。\n长期保持有目的训练的人们通常培养了各种习惯，帮助自己继续前行。我觉得，所有希望提高在某一行业或领域中的技能水平的人，应当每天花 1 个小时或更多的时间，专心练习那些需要全神贯注投入才能做好的事情。这是一条经验法则。\n弱化停止脚步的理由。找出那些可能干扰你练习的事情，并想办法将其影响控制在最小。除此之外，还需要做两件有益的事情：**保持充足的睡眠并保持健康，将练习课时间限制在 1 小时之内。**在较短的时间内投入百分之百的努力来练习，比起在更长时间内只投入 70% 的努力来练习，效果更好。一旦你发现自己再也无法有效地专注于练习了，那便停下来。 强化坚持下去的理由。培养良好的习惯，并坚持相当长的一段时间；经过一段时间之后，如果技艺上有所进步，反过来这种技能本身就可以成为你动机的一部分；相信自己可以成功；将对同一件事情感兴趣的所有人狙击起来，或者吸引他们加入一个现有团体，大家制定相似的目标。 参考资料 （英文翻译）刻意练习：成就专家级水平 Deliberate Practice: What It Is, What It’s Not, and How to Use It Deliberate Practice: What It Is and Why You Need It – Expert Enough The Beginner’s Guide to Deliberate Practice | James Clear ","date":"2018-07-21T20:52:03Z","permalink":"https://blog.bugxch.top/p/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%E8%A1%8C%E5%8A%A8%E6%89%8B%E5%86%8C/","title":"刻意练习行动手册"},{"content":"从上个月专攻机器学习，从本篇开始，我会陆续写机器学习的内容，都是我的学习笔记。\n问题 梯度下降算法用于求数学方程的极大值极小值问题，这篇文章讲解如何利用梯度下降算法求解方程 $x^5+e^x+3x−3=0$ 的根；\n方法 首先来解决第一个问题，从方程的形式我们就能初步判断，它很可能没有闭式解。我能想到的最直观的解决方法就是画出函数图，函数图与 x 轴的交点就是方程的解，那先画个图看看\n从函数图像大体可以判断，方程的根在 0 附近，但是很明显 0 不是方程的根，看图只能猜出个大概，那怎么做才能得到更精确的解呢？\n有一个可行的方法在 x = 0 附近找一堆很接近的数字，比如 [−0.5:0.05:1][−0.5:0.05:1]，一个个代入方程的左边，看看它的值离 0 有多近：距离 0 越近，说明我们选取的值离方程的根也越近。数学上定义两个数距离就是绝对值，但是因为绝对值不便于计算，所以将其替换成等价的差的平方，即 F(x)=(f(x)−0)2F(x)=(f(x)−0)2，以此度量结果距离 0 的程度，称之为损失函数。\n我们代入计算得到如下的结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 x: -0.500, f(x): -3.9247, F(x): 15.4034 x: -0.450, f(x): -3.7308, F(x): 13.9191 x: -0.400, f(x): -3.5399, F(x): 12.5310 x: -0.350, f(x): -3.3506, F(x): 11.2263 x: -0.300, f(x): -3.1616, F(x): 9.9958 x: -0.250, f(x): -2.9722, F(x): 8.8338 x: -0.200, f(x): -2.7816, F(x): 7.7372 x: -0.150, f(x): -2.5894, F(x): 6.7048 x: -0.100, f(x): -2.3952, F(x): 5.7369 x: -0.050, f(x): -2.1988, F(x): 4.8346 x: -0.000, f(x): -2.0000, F(x): 4.0000 x: 0.050, f(x): -1.7987, F(x): 3.2354 x: 0.100, f(x): -1.5948, F(x): 2.5434 x: 0.150, f(x): -1.3881, F(x): 1.9268 x: 0.200, f(x): -1.1783, F(x): 1.3883 x: 0.250, f(x): -0.9650, F(x): 0.9312 x: 0.300, f(x): -0.7477, F(x): 0.5591 x: 0.350, f(x): -0.5257, F(x): 0.2763 x: 0.400, f(x): -0.2979, F(x): 0.0888 x: 0.450, f(x): -0.0632, F(x): 0.0040 x: 0.500, f(x): 0.1800, F(x): 0.0324 x: 0.550, f(x): 0.4336, F(x): 0.1880 x: 0.600, f(x): 0.6999, F(x): 0.4898 x: 0.650, f(x): 0.9816, F(x): 0.9635 x: 0.700, f(x): 1.2818, F(x): 1.6431 x: 0.750, f(x): 1.6043, F(x): 2.5738 x: 0.800, f(x): 1.9532, F(x): 3.8151 x: 0.850, f(x): 2.3334, F(x): 5.4445 x: 0.900, f(x): 2.7501, F(x): 7.5630 x: 0.950, f(x): 3.2095, F(x): 10.3008 可以看出，x = 0.5，结果已经很接近 0 了，方程的根应该在 0.45~0.50 之间，而且 0.45 时，F(x) 的值更小，说明离 0.45 距离更近。接下来，一个可行的方法是将这段再细分成更小的区间，再如上面这样尝试，直到结果满意为止。但是这样做太过机械，每次需要手动调整区间和步长，有没有一种方法可以自动调整呢？\n再回到我们的问题，求解方程的根，就是找到一个点使得损失函数最小，我们画出来这个函数的曲线看看\n我们假定方程的根是 x0x0，**除了 x0x0，其他点的函数值都比该点处的高，而且从两边向内，越是靠近 x0x0，函数的值越接近 0。**而且可以发现，从两边向 x0x0 移动，方向刚好就是该点处切线的斜率 F′(x)F′(x) 的相反数。\n于是得到启发，挑选一个初始点，沿着该点的斜率相反的方向迭代，必然越来越靠近方程的根，所以有下面的算法：\n对于方程 f(x)=0f(x)=0，舍设定损失函数 F(x)=(f(x)−0)2F(x)=(f(x)−0)2； 设定一个初值 x0x0，代入损失函数求得结果，如果大于 0，那么找到一个新的值 x1=x0−αF′(x0)x1=x0−αF′(x0)，考察损失函数是否为 0； 反复迭代第 2 步，直到达到满意的精度为止。 上面的算法中，有三个参数需要注意：\nαα，称为学习率，代表了曲线逼近的速度，这个参数可以自己设定； 迭代次数，第 2 步运行的次数，迭代次数越多，我们离理想的结果越接近； 精度，定义为 |F(x)||F(x)|，表示迭代的效果 这三个参数中，迭代次数和精度可以作为迭代的终止条件，比如迭代次数达到 10000 次或者精度达到某个很小的数值 σσ 就终止运行。\n下面我们使用 python 程序来演示该算法的效果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # _*_ coding: utf-8 _*_ import numpy as np # 定义函数f(x) e = 2.71828182845904590 return x**5 + e**x + 3*x - 3 #定义损失函数 def loss_fun(x): return (problem(x) - 0)**2 #计算损失函数的斜率 def slope_fx(x): delta = 0.0000001; return (loss_fun(x+delta) - loss_fun(x-delta))/(2.0*delta) #代入f(x)，计算数值 def calcu_loss_fun(x,maxTimes,alpha): for i in range(maxTimes): x = x - slope_fx(x)*alpha; print \u0026#39;times %d, x: %.13f, f(x): %.13f\u0026#39; % (i, x, problem(x)) alpha = 0.01 maxTimes = 100 x = 0.0; calcu_loss_fun(x,maxTimes,alpha) 其中的slope_fx计算方程的斜率，利用导数定义 f′(x)=f(x+Δx)−f(x)Δxf′(x)=f(x+Δx)−f(x)Δx。程序计算结果如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 times 1, x: 0.2724712244717, f(x): -0.8678788871194 times 2, x: 0.3478163723702, f(x): -0.5354882897920 times 3, x: 0.3958941025006, f(x): -0.3168805921512 times 4, x: 0.4251012218626, f(x): -0.1810687680246 times 5, x: 0.4420964369242, f(x): -0.1008566369730 times 6, x: 0.4516717013511, f(x): -0.0552506486831 times 7, x: 0.4569525930429, f(x): -0.0299651603458 times 8, x: 0.4598276021739, f(x): -0.0161585445219 times 9, x: 0.4613811940466, f(x): -0.0086856358075 times 10, x: 0.4622172450759, f(x): -0.0046606160693 times 11, x: 0.4626661379649, f(x): -0.0024984737671 times 12, x: 0.4629068614830, f(x): -0.0013387061269 times 13, x: 0.4630358664583, f(x): -0.0007170954782 times 14, x: 0.4631049762781, f(x): -0.0003840652503 times 15, x: 0.4631419923255, f(x): -0.0002056832476 times 16, x: 0.4631618165349, f(x): -0.0001101474736 times 17, x: 0.4631724329502, f(x): -0.0000589848326 times 18, x: 0.4631781181683, f(x): -0.0000315864570 times 19, x: 0.4631811626230, f(x): -0.0000169144811 times 20, x: 0.4631827929259, f(x): -0.0000090576372 times 21, x: 0.4631836659475, f(x): -0.0000048503201 times 22, x: 0.4631841334466, f(x): -0.0000025973198 times 23, x: 0.4631843837899, f(x): -0.0000013908497 times 24, x: 0.4631845178473, f(x): -0.0000007447918 times 25, x: 0.4631845896343, f(x): -0.0000003988315 times 26, x: 0.4631846280757, f(x): -0.0000002135719 times 27, x: 0.4631846486609, f(x): -0.0000001143664 times 28, x: 0.4631846596842, f(x): -0.0000000612425 times 29, x: 0.4631846655870, f(x): -0.0000000327950 times 30, x: 0.4631846687480, f(x): -0.0000000175615 times 31, x: 0.4631846704407, f(x): -0.0000000094041 times 32, x: 0.4631846713471, f(x): -0.0000000050358 times 33, x: 0.4631846718325, f(x): -0.0000000026967 times 34, x: 0.4631846720924, f(x): -0.0000000014440 times 35, x: 0.4631846722316, f(x): -0.0000000007733 times 36, x: 0.4631846723061, f(x): -0.0000000004141 times 37, x: 0.4631846723460, f(x): -0.0000000002217 times 38, x: 0.4631846723674, f(x): -0.0000000001187 times 39, x: 0.4631846723788, f(x): -0.0000000000636 times 40, x: 0.4631846723850, f(x): -0.0000000000340 times 41, x: 0.4631846723882, f(x): -0.0000000000182 times 42, x: 0.4631846723900, f(x): -0.0000000000098 times 43, x: 0.4631846723909, f(x): -0.0000000000052 times 44, x: 0.4631846723914, f(x): -0.0000000000028 times 45, x: 0.4631846723917, f(x): -0.0000000000015 times 46, x: 0.4631846723919, f(x): -0.0000000000008 times 47, x: 0.4631846723919, f(x): -0.0000000000004 times 48, x: 0.4631846723920, f(x): -0.0000000000002 times 49, x: 0.4631846723920, f(x): -0.0000000000001 times 50, x: 0.4631846723920, f(x): -0.0000000000001 times 51, x: 0.4631846723920, f(x): -0.0000000000000 times 52, x: 0.4631846723920, f(x): -0.0000000000000 times 53, x: 0.4631846723920, f(x): -0.0000000000000 times 54, x: 0.4631846723920, f(x): -0.0000000000000 迭代 52 次，就已经达到了理想的效果。\n参考资料 Gradient Descent 梯度下降法 Gradient Descent | Big Data Mining \u0026amp; Machine Learning ","date":"2018-07-21T20:41:31Z","permalink":"https://blog.bugxch.top/p/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E7%AE%97%E6%B3%95%E4%B9%8B%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3/","title":"梯度下降算法之方程求解"},{"content":"因为梯度下降算法需要绘制 3 维图像，故学习之，日后借鉴。\n本文稿翻译自 mplot3d tutorial — Matplotlib 2.0.2 documentation。\n使用 matplotlib 绘制 3D 图像，一般要加入一个新的 axes 类型 Axes3D:\n1 2 3 4 import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D fig = plt.figure() ax = fig.add_subplot(111, projection=\u0026#39;3d\u0026#39;) 其中的ax，就是添加一个三维坐标系Axes3D的对象，如下图所示\n3D 图形分为如下几类：\n线形图 Axes3D.plot(xs,ys,**args,**kwargs)\n绘制 2D 或者 3D 的数据。\nArgument Description xs, ys x, y coordinates of vertices zs z value(s), either one for all points or one for each point. zdir Which direction to use as z (‘x’, ‘y’ or ‘z’) when plotting a 2D set. 关键参数传给了plot()函数，例如下面的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import matplotlib as mpl from mpl_toolkits.mplot3d import Axes3D import numpy as np import matplotlib.pyplot as plt mpl.rcParams[\u0026#39;legend.fontsize\u0026#39;] = 10 fig = plt.figure() ax = fig.gca(projection=\u0026#39;3d\u0026#39;) theta = np.linspace(-4 * np.pi, 4 * np.pi, 100) z = np.linspace(-2, 2, 100) r = z**2 + 1 x = r * np.sin(theta) y = r * np.cos(theta) ax.plot(x, y, z, label=\u0026#39;parametric curve\u0026#39;) ax.legend() plt.show() 绘制的图形如下\n从这个例子可以看出，matplot 画图的基本步骤包括：导入必要的模块，创建 figure 对象，设置 3D 的 ax，创建自变量，写出函数关系式，绘制图形。\n散点图 Axes3D.scatter(*xs*, *ys*, *zs=0*, *zdir='z'*, *s=20*, *c=None*, *depthshade=True*, **args*, **\\*kwargs*)\nArgument Description xs, ys Positions of data points. zs Either an array of the same length as xs and ys or a single value to place all points in the same plane. Default is 0. zdir Which direction to use as z (‘x’, ‘y’ or ‘z’) when plotting a 2D set. s Size in points^2. It is a scalar or an array of the same length as x and y. c A color. c can be a single color format string, or a sequence of color specifications of length N, or a sequence of Nnumbers to be mapped to colors using the cmap and norm specified via kwargs (see below). Note that c should not be a single numeric RGB or RGBA sequence because that is indistinguishable from an array of values to be colormapped. c can be a 2-D array in which the rows are RGB or RGBA, however, including the case of a single row to specify the same color for all points. depthshade Whether or not to shade the scatter markers to give the appearance of depth. Default is True. 关键参数传给了scatter()函数，如下面的例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026#39;\u0026#39;\u0026#39; ============== 3D scatterplot ============== Demonstration of a basic scatterplot in 3D. \u0026#39;\u0026#39;\u0026#39; from mpl_toolkits.mplot3d import Axes3D import matplotlib.pyplot as plt import numpy as np def randrange(n, vmin, vmax): \u0026#39;\u0026#39;\u0026#39; Helper function to make an array of random numbers having shape (n, ) with each number distributed Uniform(vmin, vmax). \u0026#39;\u0026#39;\u0026#39; return (vmax - vmin)*np.random.rand(n) + vmin fig = plt.figure() ax = fig.add_subplot(111, projection=\u0026#39;3d\u0026#39;) n = 100 # For each set of style and range settings, plot n random points in the box # defined by x in [23, 32], y in [0, 100], z in [zlow, zhigh]. for c, m, zlow, zhigh in [(\u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, -50, -25), (\u0026#39;b\u0026#39;, \u0026#39;^\u0026#39;, -30, -5)]: xs = randrange(n, 23, 32) ys = randrange(n, 0, 100) zs = randrange(n, zlow, zhigh) ax.scatter(xs, ys, zs, c=c, marker=m) ax.set_xlabel(\u0026#39;X Label\u0026#39;) ax.set_ylabel(\u0026#39;Y Label\u0026#39;) ax.set_zlabel(\u0026#39;Z Label\u0026#39;) plt.show() 这个函数里画了 2 组散点图，分别用其中的小三角和红色的圆点表示。函数randrange产生[vmin,vmax]上的均匀分布的一列数。如下图所示\n线框图 Axes3D.plot_wireframe(X, Y, Z, args, kwargs)\n绘制 3D 的线框图，其中的参数rstride和cstride表示对输入数据的采样，它们不能和rcount以及ccount同时使用，不然会产生错误，后者表示从输入数据中采样多少以生成线框图。\nArgument Description X, Y, Data values as 2D arrays Z rstride Array row stride (step size), defaults to 1 cstride Array column stride (step size), defaults to 1 rcount Use at most this many rows, defaults to 50 ccount Use at most this many columns, defaults to 50 关键参数传给了Linecollection，返回一个Line3DCollection的类。举例如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026#39;\u0026#39;\u0026#39; ================= 3D wireframe plot ================= A very basic demonstration of a wireframe plot. \u0026#39;\u0026#39;\u0026#39; from mpl_toolkits.mplot3d import axes3d import matplotlib.pyplot as plt fig = plt.figure() ax = fig.add_subplot(111, projection=\u0026#39;3d\u0026#39;) # Grab some test data. X, Y, Z = axes3d.get_test_data(0.05) # Plot a basic wireframe. ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10) plt.show() 绘制图形如下\n其中rstride和cstride分别代表采样的密度，这里是每隔 10 个点计算一个 Z 值，如果设置成 1，绘制的图形会更密集，如下图所示\n表面图 Axes3D.plot_surface(X, Y, Z, *args, **kwargs)\n默认使用纯色为阴影着色，不过它也可以通过 cmap 支持颜色映射。\nArgument Description X, Y, Z Data values as 2D arrays rstride Array row stride (step size) cstride Array column stride (step size) rcount Use at most this many rows, defaults to 50 ccount Use at most this many columns, defaults to 50 color Color of the surface patches cmap A colormap for the surface patches. facecolors Face colors for the individual patches norm An instance of Normalize to map values to colors vmin Minimum value to map vmax Maximum value to map shade Whether to shade the facecolors 其他的参数传给Ploy3DCollection，举例如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026#39;\u0026#39;\u0026#39; ====================== 3D surface (color map) ====================== Demonstrates plotting a 3D surface colored with the coolwarm color map. The surface is made opaque by using antialiased=False. Also demonstrates using the LinearLocator and custom formatting for the z axis tick labels. \u0026#39;\u0026#39;\u0026#39; from mpl_toolkits.mplot3d import Axes3D import matplotlib.pyplot as plt from matplotlib import cm from matplotlib.ticker import LinearLocator, FormatStrFormatter import numpy as np fig = plt.figure() ax = fig.gca(projection=\u0026#39;3d\u0026#39;) # Make data. X = np.arange(-5, 5, 0.25) Y = np.arange(-5, 5, 0.25) X, Y = np.meshgrid(X, Y) R = np.sqrt(X**2 + Y**2) Z = np.sin(R) # Plot the surface. surf = ax.plot_surface(X, Y, Z, cmap=cm.coolwarm, linewidth=0, antialiased=False) # Customize the z axis. ax.set_zlim(-1.01, 1.01) ax.zaxis.set_major_locator(LinearLocator(10)) ax.zaxis.set_major_formatter(FormatStrFormatter(\u0026#39;%.02f\u0026#39;)) # Add a color bar which maps values to colors. fig.colorbar(surf, shrink=0.5, aspect=5) plt.show() 绘制图形如下\n参考图形知道cm用来做 color mapping，重新设置arange的步长为 0.01，可以得到如下的图形\n表面光滑细致多了。\n2D/3D 图形共存 这篇文章主要是用来画 3 维图形的，以上的几个图形已经够用，下面介绍一些其他的技能。现在的是在 2D 中画 3D 图形。直接上代码和图像\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026#34;\u0026#34;\u0026#34; ======================= Plot 2D data on 3D plot ======================= Demonstrates using ax.plot\u0026#39;s zdir keyword to plot 2D data on selective axes of a 3D plot. \u0026#34;\u0026#34;\u0026#34; from mpl_toolkits.mplot3d import Axes3D import numpy as np import matplotlib.pyplot as plt fig = plt.figure() ax = fig.gca(projection=\u0026#39;3d\u0026#39;) # Plot a sin curve using the x and y axes. x = np.linspace(0, 1, 100) y = np.sin(x * 2 * np.pi) / 2 + 0.5 ax.plot(x, y, zs=0, zdir=\u0026#39;z\u0026#39;, label=\u0026#39;curve in (x,y)\u0026#39;) # Plot scatterplot data (20 2D points per colour) on the x and z axes. colors = (\u0026#39;r\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;k\u0026#39;) x = np.random.sample(20*len(colors)) y = np.random.sample(20*len(colors)) c_list = [] for c in colors: c_list.append([c]*20) # By using zdir=\u0026#39;y\u0026#39;, the y value of these points is fixed to the zs value 0 # and the (x,y) points are plotted on the x and z axes. ax.scatter(x, y, zs=0, zdir=\u0026#39;y\u0026#39;, c=c_list, label=\u0026#39;points in (x,z)\u0026#39;) # Make legend, set axes limits and labels ax.legend() ax.set_xlim(0, 1) ax.set_ylim(0, 1) ax.set_zlim(0, 1) ax.set_xlabel(\u0026#39;X\u0026#39;) ax.set_ylabel(\u0026#39;Y\u0026#39;) ax.set_zlabel(\u0026#39;Z\u0026#39;) # Customize the view angle so it\u0026#39;s easier to see that the scatter points lie # on the plane y=0 ax.view_init(elev=20., azim=-35) plt.show() 从上面的代码，可以看出如何设置坐标轴的取值范围，设置 label 的方法。\n加入文字 Axes3D.text(x, y, z, s, zdir=None, **kwargs)\n在画图中我们可能需要在特定位置加入文字说明，下面就是一个例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026#39;\u0026#39;\u0026#39; ====================== Text annotations in 3D ====================== Demonstrates the placement of text annotations on a 3D plot. Functionality shown: - Using the text function with three types of \u0026#39;zdir\u0026#39; values: None, an axis name (ex. \u0026#39;x\u0026#39;), or a direction tuple (ex. (1, 1, 0)). - Using the text function with the color keyword. - Using the text2D function to place text on a fixed position on the ax object. \u0026#39;\u0026#39;\u0026#39; from mpl_toolkits.mplot3d import Axes3D import matplotlib.pyplot as plt fig = plt.figure() ax = fig.gca(projection=\u0026#39;3d\u0026#39;) # Demo 1: zdir zdirs = (None, \u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;z\u0026#39;, (1, 1, 0), (1, 1, 1)) xs = (1, 4, 4, 9, 4, 1) ys = (2, 5, 8, 10, 1, 2) zs = (10, 3, 8, 9, 1, 8) for zdir, x, y, z in zip(zdirs, xs, ys, zs): label = \u0026#39;(%d, %d, %d), dir=%s\u0026#39; % (x, y, z, zdir) ax.text(x, y, z, label, zdir) # Demo 2: color ax.text(9, 0, 0, \u0026#34;red\u0026#34;, color=\u0026#39;red\u0026#39;) # Demo 3: text2D # Placement 0, 0 would be the bottom left, 1, 1 would be the top right. ax.text2D(0.05, 0.95, \u0026#34;2D Text\u0026#34;, transform=ax.transAxes) # Tweaking display region and labels ax.set_xlim(0, 10)W ax.set_ylim(0, 10) ax.set_zlim(0, 10) ax.set_xlabel(\u0026#39;X axis\u0026#39;) ax.set_ylabel(\u0026#39;Y axis\u0026#39;) ax.set_zlabel(\u0026#39;Z axis\u0026#39;) plt.show() ","date":"2018-07-21T20:39:09Z","permalink":"https://blog.bugxch.top/p/matplot-%E4%B9%8B-3d-%E7%BB%98%E5%9B%BE%E6%8C%87%E5%8D%97/","title":"matplot 之 3D 绘图指南"},{"content":"C/C++中有些特殊的宏定义，面试时候被问到，写个短文总结下。\n宏定义中的#和##连字符 这两个字符在宏定义中代表连接和替换，\n#紧跟字母表示对应字符的字符串化，将对应的字符转换成对应的字符串，比如#hello就是\u0026quot;hello\u0026quot; ##表示将宏定义中的两个标识符连接在一起，组成一个新的标识符，类似胶水。它首先查看##两边的字符，是否有宏定义可以替换的字符串，替换之，之后将两个连接在一起。 下面举例说明。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; #define trace(x, format) printf(#x \u0026#34; = %\u0026#34; #format \u0026#34;\\n\u0026#34;, x) #define trace2(i) trace(x##i, d) int main(int argc, _TCHAR* argv[]) { int i = 1; char *s = \u0026#34;three\u0026#34;; float x = 2.0; trace(i, d); // 相当于 printf(\u0026#34;x = %d\\n\u0026#34;, x) trace(x, f); // 相当于 printf(\u0026#34;x = %f\\n\u0026#34;, x) trace(s, s); // 相当于 printf(\u0026#34;x = %s\\n\u0026#34;, x) int x1 = 1, x2 = 2, x3 = 3; trace2(1); // 相当于 trace(x1, d) trace2(2); // 相当于 trace(x2, d) trace2(3); // 相当于 trace(x3, d) return 0; } 又比如\n1 2 3 4 #define STACK_ADD_TASK_IRAM_POOL1(TASK_NAME, task_name, task_type){\\ task_info_g[INDEX_##TASK_NAME].task_entry_func = \\ (osa_task_func_ptr) stack_##task_type##_task;\\ } 上面的语句中，我们会将其中的TASK_NAME和task_type替换掉，并与前后的标识符相连接生成新的标识符。\n宏定义中的 do{} while(0) 经常在宏定义中会看到如下的语句\n1 2 3 4 5 6 7 #define STACK_ADD_MULTI_TASK(multi_sys_max, TASK_NAME, task_name, task_type) \\ do{ \\ if(multi_sys_max \u0026gt;= 1) \\ { \\ STACK_ADD_TASK_1_CARD(TASK_NAME, task_name, task_type); \\ } \\ }while(0) 这个语句的特点是宏定义之后紧跟一个do{...}while(0)的结构，看起来颇为繁琐，那这样的定义有什么好处呢？\n首先，C 中的宏定义，在预编译阶段就会将宏定义的结构替换掉，使用宏定义定义函数。在代码替换中肯定希望像使用定义的函数使用宏定义，比如上面的语句在代码中肯定是下面这样的\n1 STACK_ADD_MULTI_TASK(multi_sys_max, TASK_NAME, task_name, task_type); 所以注意到宏定义的while(0)后面没有分号。\n然后，这个结构和if..else...的控制结构可以完美结合，对照上面的宏定义，一般能想到的宏定义的结果修改如下\n1 2 3 4 5 6 7 #define STACK_ADD_MULTI_TASK(multi_sys_max, TASK_NAME, task_name, task_type) \\ { \\ if(multi_sys_max \u0026gt;= 1) \\ { \\ STACK_ADD_TASK_1_CARD(TASK_NAME, task_name, task_type); \\ } \\ } 如果正常替换之前的语句，替换之后的结果就是\n1 2 3 4 5 6 { \\ if(multi_sys_max \u0026gt;= 1) \\ { \\ STACK_ADD_TASK_1_CARD(TASK_NAME, task_name, task_type); \\ } \\ }; 注意最后的分号，这一行编译不通过，但是很明显如果换成do{}while(0)结构就不存在这个问题。\n其次，如果使用宏定义多行语句，那么使用大括号的宏定义嵌套在if...else...的结构中会遇到问题，比如定义\n1 #define BAR(X) f(x); g(x) 如果用在下面的程序中就会出现语法错误\n1 2 3 4 5 6 if(true) BAR(x) else { //do nothing } 但是使用do{...}while(0)结构就不会有这样的问题。\n__DATE__,__TIME__,__FILE__,__LINE__特殊宏定义 _LINE_：在源代码中插入当前源代码行号； _FILE_：在源文件中插入当前源文件名； _DATE_：在源文件中插入当前的编译日期 _TIME_：在源文件中插入当前编译时间； _STDC_：当要求程序严格遵循ANSI C标准时该标识被赋值为1； __cplusplus：当编写C++程序时该标识符被定义 具体的使用方式参考如下的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;stdio.h\u0026gt; int main(void) { int answer; short x = 1; long y = 2; float u = 3.0; double v = 4.4; long double w = 5.54; char c = \u0026#39;p\u0026#39;;; // __DATE__, __TIME__, __FILE__, __LINE__ 为预定义宏 printf(\u0026#34;Date : %s\\n\u0026#34;, __DATE__); printf(\u0026#34;Time : %s\\n\u0026#34;, __TIME__); printf(\u0026#34;File : %s\\n\u0026#34;, __FILE__); printf(\u0026#34;Line : %d\\n\u0026#34;, __LINE__); printf(\u0026#34;Enter 1 or 0 : \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;answer); // 这是一个条件表达式 printf(\u0026#34;%s\\n\u0026#34;, answer?\u0026#34;You sayd YES\u0026#34;:\u0026#34;You said NO\u0026#34;); // 各种数据类型的长度 printf(\u0026#34;The size of int %d\\n\u0026#34;, sizeof(answer)); printf(\u0026#34;The size of short %d\\n\u0026#34;, sizeof(x)); printf(\u0026#34;The size of long %d\\n\u0026#34;, sizeof(y)); printf(\u0026#34;The size of float %d\\n\u0026#34;, sizeof(u)); printf(\u0026#34;The size of double %d\\n\u0026#34;, sizeof(v)); printf(\u0026#34;The size of long double %d\\n\u0026#34;, sizeof(w)); printf(\u0026#34;The size of char %d\\n\u0026#34;, sizeof(c)); } __VA_ARGS__宏定义 当前主干代码的一个典型的用法如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 #define DEFINE_KERNEL(gobalFunc, ...) \\ extern \u0026#34;C\u0026#34; __global__ __aicore__ void gobalFunc(__gm__ half* tableAddr, TABLE_SIZE_INT64 tableSize) \\ { \\ __VA_ARGS__(tableAddr, tableSize); \\ } \\ \\ DLL_PUBLIC void run_##gobalFunc(uint32_t coreDim, void* l2ctrl, void* stream, \\ void* tableAddr, uint32_t tableSize) \\ { \\ gobalFunc\u0026lt;\u0026lt;\u0026lt;coreDim, (rtL2Ctrl_t*)l2ctrl, stream\u0026gt;\u0026gt;\u0026gt;( \\ (half*)tableAddr, static_cast\u0026lt;TABLE_SIZE_INT64\u0026gt;(tableSize)); \\ } #endif 上面代码中...对应__VA_ARGS__，表示在宏展开中将__VA_ARGS__替换成...的内容，此处的...可以表示表示一个或多个参数，但是常见的编译器也允许传递0个参数。再比如如下的代码\n1 # define MYLOG(FormatLiteral, ...) fprintf (stderr, \u0026#34;%s(%d): \u0026#34; FormatLiteral \u0026#34;\\n\u0026#34;, __FILE__, __LINE__, __VA_ARGS__) 对于下面的代码\n1 MYLOG(\u0026#34;Too many balloons %u\u0026#34;, 42); 可以扩展为\n1 fprintf (stderr, \u0026#34;%s(%d): Too many balloons %u\\n\u0026#34;, __FILE__, __LINE__, 42); 参考资料 C/C++ 宏定义中 #、##、#@的区别 - hellokandy 的博客 - CSDN 博客 c - Why use do {} while (0) in macro definition? - Stack Overflow c++ - Do you consider this technique “BAD”? - Stack Overflow c++ - Why use apparently meaningless do-while and if-else statements in macros? - Stack Overflow -C/C++中几个预定义的宏：DATE,TIME,FILE,__LINE___C语言中文网 可变参数宏 - Wikiwand ","date":"2018-07-21T20:33:48Z","permalink":"https://blog.bugxch.top/p/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AE%8F/","title":"C语言中的宏"},{"content":"大端和小端，到底是什么意思？\n字节序是数据在内存中存放顺序。字节分高有效位和低有效位，最左边是高位最右边是低位。我们按照地址生长的方向依次往内存写入数据，如果高有效位的数据先写入就是 big endian，如果低有效位先写入就是 little endian。字节序仅仅与数据的存储方式有关，与语言没有关系，没有 java 字节序或者 C 字节序的区分。\n举个例子，存入一个 4 字节的数据 0x0A0B0C0D，最高有效位的字节是 0A，最低有效位的字节是 0D，如果在内存存储中，0A 位于连续内存最小的那个就是 big endian，反之如果最小地址存储 0D 就是 little endian。\nbig endian 存放顺序是最高有效位，次高有效位，一直顺序存储到最低有效位，数据和内存都是按照顺序依次连续存储的。little endian 也是依次存储，但是高低位刚好相反，如下图所示\n需要注意的是，无论是 4 个字节还是 8 个字节，存储的顺序都是在连续内存上依照高位到低位或者低位到高位的顺序读取和写入，比如我们有 3 个字节 0x123456，如果内存中保存的数据从小内存地址到大内存地址依次位 0x12,0x34, 0x56，那么就是 big endian，反之是 little endian。\n附上 C 语言测试字节序的程序\n1 2 3 4 5 6 7 8 9 10 11 void judge_endian(void) { int a = 1; //存储0x00000001到内存 if(*(\u0026amp;a) == 1){ //\u0026amp;a是a的地址，保存了1个字节的数据，如果为1，说明低有效位先保存，则为小端 printf(\u0026#34;Little Endian\\n\u0026#34;); } else { printf(\u0026#34;Big Endian\\n\u0026#34;); } } ","date":"2018-07-21T20:32:35Z","permalink":"https://blog.bugxch.top/p/%E5%AD%97%E8%8A%82%E5%BA%8F/","title":"字节序"},{"content":"今后转行机器学习，现在补上操作系统的短板，边学习边总结，我会发布一系列操作系统的博客，此为第一篇。\n操作系统的发展，需要依赖电脑硬件的功能，按照发展技术的不同，OS 可以分为如下几个阶段：串行处理，简单批处理，多道批处理，分时系统。\n串行处理 20 世纪四五十年代是串行处理阶段，当时没有操作系统，程序员直接和硬件打交道，而且电脑每次只能处理一个任务，每个人预约顺序轮流使用机器半小时或者半小时的整数倍。如果发生故障，机器就亮灯并停止当前的任务。这是需要花费很长时间准备工作，往内存中加载编译器和源程序， 保存目标程序，链接目标程序和公用函数，往往需要准备很长的时间。为了加快串行处理的效率，发明了公共函数库，编译器，加载器，链接器，I/O 驱动和调试器。\n简单批处理 上世纪 50 年代中期，出现了一个简单的批处理操作系统（也是第一个操作系统）。核心思想是将所有用户的作业交给计算机操作员，他把这些作业按顺序组织成一批，将整个批处理作业放入输入设备。电脑中的监控程序自动加载用户程序，将控制权交给用户，作业完成之后用户程序将控制权返回给操作系统。\n监控程序负责程序的编译，加载和运行，这个系统引入了内存保护和中断机制，用户程序无法在运行时访问和修改监控程序的内存区域，监控程序通过中断完成控制权的交接。此外，有些机器指令设计成只有监控程序才能执行，称为特权指令，比如访问 I/O 设备。由此引申出用户态 / 内核态的概念，用户程序执行用户态有些内存区域不能访问，而且不能执行特权指令，而监控程序执行内核态，可以执行特权指令，而且内存区域可访问。\n多道程序批处理 多道批处理系统出现在可以将监控程序和多个用户程序同时载入到内存中，并行运算，这样就可以避免由于外设与 CPU 处理速度上的差异引起的 CPU 大量空闲等待的问题。\n多道处理程序需要更大的内存以并行载入更多的用户程序，因为内存中不止一个用户程序，操作系统还需要为每个程序分配内存空间，以及决定在什么时刻执行什么程序，引入了内存管理和调度的概念。\n分时系统 分时系统 (time sharing system) 允许多个用户同时访问相同的计算机资源。理论上如果有 n 个用户同时使用一台电脑，那么可以将 CPU 的时间切割成 n 块，每个用户占用其中的一块，由于 CPU 的处理速度很快，不同任务切换快到用户无法察觉以至于他们每个人都认为自己在独占 CPU 资源，这是分时系统的核心思想。\n分时系统比多道程序批处理更复杂，它需要额外保证 CPU 和内存在不同用户间能顺利切换，下表是二者的区别\n操作系统 多道批处理系统 分时系统 主要目标 充分使用处理器 减少响应时间 操作系统指令源 作业提供的控制语言命令 终端键入的命令 下图是一个分时系统某一个时刻的截取示意图，\n其中的用户 1～6 分时使用 CPU 资源，1～4 处于空闲态，5 在使用 CPU，6 处于 ready 状态，可以想象在公司中多个同事同事使用同一台服务器的情景。\n下表将以上的所有的操作系统进行了总结\n操作系统形态 年代 引入概念 硬件支持 优点 串行处理 20 世纪四五十年代 编译器，链接器，加载器，调试器 无 无 简单批处理 20 世纪 50 年代 内存保护，中断，用户态 / 内核态 内存和 CPU 性能提升 提高自动化，处理器的运行速率提高 多道处理 20 世纪 70 年代 内存管理，调度 大内存 并行处理多个程序，提高 CPU 运行效率 分时系统 现代 分时，用户等级，访问权限 性能进一步提升 多个用户可以同时使用同一台主机 参考资料 Time Sharing Operating System ","date":"2018-07-21T20:31:23Z","permalink":"https://blog.bugxch.top/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E5%8F%B2/","title":"操作系统简史"},{"content":"补码是如何产生的？\n今天读《数值分析》第 0 章的实数的浮点表示，对计算机存储数据的机制产生兴趣，所以自己写了个小程序结合现有资料探索总结下。\n我们现在遇到一个计算机的基本问题，\n给定一个数（整数或者实数）$X$，如何以 $w$个比特位的形式$[x_{w-1},x_{w-2},…,x_0]$将它存储在计算机的内存里？\n程序结果 我自己写的 C 程序如下，分别打印出整数120055,-411，浮点数102.3235， -3.256和双精度浮点数120.254， -56.2441在计算机内存中的二进制比特，这几个数字是我随手写的，但是均没有超出计算机的表示范围。程序如下所示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; typedef enum { INT = 4, //int和float有4个字节 FLOAT = 4, DOUBLE = 8 //double有8个字节 } TYPE_E; void showBytes(unsigned char *ch, TYPE_E len) { int i; for(i = 0; i \u0026lt; len; i++) { printf(\u0026#34; %.2x\u0026#34;, ch[i]); } printf(\u0026#34;\\n\u0026#34;); } int main(int argc, char *argv[]) { int a = 120055, b = -411; float a_f = 102.3235, b_f = -3.256; double a_d = 120.254, b_d = -56.2441; printf(\u0026#34;binary of a %d, 0x\u0026#34;, a); showBytes((unsigned char*)\u0026amp;a, INT); printf(\u0026#34;binary of b %d, 0x\u0026#34;, b); showBytes((unsigned char*)\u0026amp;b, INT); printf(\u0026#34;binary of a_f %f, 0x\u0026#34;, a_f); showBytes((unsigned char*)\u0026amp;a_f, FLOAT); printf(\u0026#34;binary of b_f %f, 0x\u0026#34;, b_f); showBytes((unsigned char*)\u0026amp;b_f, FLOAT); printf(\u0026#34;binary of a_d %f, 0x\u0026#34;, a_d); showBytes((unsigned char*)\u0026amp;a_d, DOUBLE); printf(\u0026#34;binary of b_d %f, 0x\u0026#34;, b_d); showBytes((unsigned char*)\u0026amp;b_d, DOUBLE); getchar(); return 0; } 程序运行完成之后的结果如下所示\n因为是小端存储，因此整理之后的结果如下所示\n数值 内存表示（十六进制） 120055 0001D4F7 -411 FFFFFE65 102.3235 42CCA5A2 -3.256 C050624E 120.254 405E104189374BC7 -56.2441 C04C1F3EAB367A10 从上面的结果可以看出不同数值的长度不同，因为计算机给每个不同的类型分配的内存大小不同，这个可以通过 C 中的sizeof函数看出来。下面我们需要搞清楚的是，**为什么这些数都是以这样的形式和内容存储在计算机中的？**这一篇文章，我们先谈比较简单的整数的表示，下一篇文章会解释浮点数的表示方法。\n编码机制 二进制表示 我们知道，计算机中以二进制的形式存储数字，所有的十进制的数字都需要转换成二进制存储起来。至于十进制和二进制如何转换，课本和网上已经有非常详尽的解释（可参考文末的文章），而且有非常完善的在线进制转换工具可以轻松实现多个进制之间的相互转换，这里不再赘述。为了便于对比，除非特殊情况，本文的内容均使用十六进制数。\n整数编码 我们先从简单的正整数入手，120055 = 0x1D4F7，考虑到计算机int类型使用 4 个字节，补齐前面的0，于是为0x0001D4F7，这个与我们程序验证结果一致。因此，可以断定正整数在计算机中存储的形式就是它转换成二进制的形式。\n引入负数 那么负整数是如何保存的呢？来看第二个数字-411，因为411 = 0x19b，所以我们直观的表示就是-0x19b，但是计算机不能表示负号，那么该如何处理这个问题呢？一个直接简单的想法是使用 1 个比特表示符号正负，自然的想法是取最高位，0 表示正数，1 表示负数，所以可以表示成0x8000019b。这样表示比较直观，但是有一个小问题。为了便于说明，我将问题的规模缩小，比如考虑 3 个比特的二进制和十进制数之间的转换。如果使用我们之前的换算方法，那么二进制编码的情况如下\n二进制 十进制 二进制 十进制 000 0 100 0 001 1 101 -1 010 2 110 -2 011 3 111 -3 很明显，十进制0有两种不同的编码方式，3 个比特本来可以表示不同的 8 个数，却只能表示 7 个不同的数，这是对信息比特的浪费。最佳的表示方式应该满足，在一个一致的运算关系之下，不同的二进制编码表示不同的十进制数，于是引入了补码的概念。\n补码 首先，补码如何计算？\n给定 $w$ 个比特，如何求一个十进制数 $X$ 的二进制补码 $[x_{w-1},x_{w-2},…,x_0]$？\n以 8 比特为例，如果求正整数 8 的相反数，我们用0-8 = -8，补码的取法类似，使用如下的计算\n００００００００ －００００１０００ －－－－－－－－－ １１１１１０００\n但是不够减，小学算术告诉我们可以向前借位，于是有\n１００００００００ －００００１０００ －－－－－－－－－ １１１１１０００\n问题解决，总结下这个变换过程：最高有效位表示正负号，正数 XX 的补码是其自身的二进制表示 XX，负数 XX 的补码是 2w−|X|2w−|X|。\n举个例子，比如使用 4 个 bit 表示 6 和 - 7 的补码，分别是 $(1100)2$和和$(2^4 - |7|){10} = (9)_{10} = (1001)_2$。这里需要特别说明下，经常听到求一个负数。这里需要特别说明下，经常听到求一个负数X的二进制补码，就是先求的二进制补码，就是先求$|X|$ 的二进制表示，除了符号位之外的所有位取反加 1，这和上面的方法等效，因为$2^w - |X| = (1000…0)_2 - |X| = (111…1 + 000…1)_2 - |X| = (111…1)_2 - |X| + 1$，一目了然。使用该方法编码 3 个比特的编码，如下所示\n二进制 十进制 二进制 十进制 000 0 100 -4 001 1 101 -3 010 2 110 -2 011 3 111 -1 很明显，使用补码，所有的十进制数都有与之对应唯一的二进制编码表示。使用这个方法可以计算出来 $(-411){10} = (FFFFE65){16}$，与之前程序的结果完全一致！！于是猜想计算机使用补码存储对应的整数！\n已知一个 $w$ 比特的二进制补码$[x_{w-1},x_{w-2},…,x_0]$，如何求它对应的十进制数 $X$？\n如果知道这个数的补码形式，根据《深入理解计算机系统》中给出二进制数补码表示$[x_{w-1},x_{w-2},…,x_0]$ 与十进制数之间的转换关系\n$$ X = -x_{w-1}2^{w-1} + \\sum_{i = 0}^{w-2}{x_i2_i} $$\n使用补码有什么好处？\n第一，0的表示唯一。 第二，所有整数的加法统一在一个法则之下，使用一套逻辑电路。现在有一个问题，异号两个数相加怎么计算，比如\n1 + (-3) = ?\n根据数字的表示不同，这个问题有如下几种解法。\n十进制解法，也就是我们人类自己的解法，首先我们会判断 3 和 - 2 那个绝对值大，之后符号取绝对值大的那个，最后绝对值大的减去绝对值小的作为新的数字的绝对值。听起来比较拗口，这里分了好几个步骤：1) 比较绝对值大小，决定符号；2) 绝对值相减确定结果的绝对值。\n使用之前的编码方案（为了简单，我们仍然使用 3 比特数举例，如果我们使用之前的表示方法），直接二进制相减，即 $(1 + (-3))_{10} = (001 + 111)_2 = (000)2 = (0){10}$，这是明显错误的结果。如果想要正确，我们需要借鉴十进制的解法，先判断绝对值，再确定符号，两个数字相加需要将符号单独拎出来处理，加法是计算机的最基础的运算操作，这样的处理逻辑增加了电路的设计复杂度，极大地影响计算机的性能。\n使用补码。$(1 + (-3))_{10} = (001 + 101)_2 = (110)2 = (-2){10}$，可以自行验证其他的所有的异号的和，都能得到正确的答案。可以看出，符号位直接当作数据的一部分参与运算，计算机并没有单独对其做处理，从计算机的角度来看简单粗暴有效，之所以会有这么神奇的结果，是因为 $$ [X]_补 + [Y]_补 = [X+Y]_补 $$ 这个定理可以按照两数同号，两数异号两种情况进行证明。正因为有这样的数学关系，所以计算机将补码作为整数存储的形式。\n参考资料 《数值分析》，0.2 和 0.3 节 《深入理解计算机系统》，第二章 二、八、十、十六进制转换（图解篇） - 听风吹雨 - 博客园 关于 2 的补码 Two’s Complement ","date":"2018-07-21T20:30:02Z","permalink":"https://blog.bugxch.top/p/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E8%A1%A5%E7%A0%81/","title":"为什么会有补码"},{"content":"python基本操作知识积累。\n排序是一个基本的数据操作，本文列举下 python 和 numpy 中的基本排序操作，以备后查。\n列表排序 列表排序常用reverse/sort/sorted这三种方法，举例如下\n1 2 3 4 5 6 7 8 9 10 11 In [28]: ls = [-1, 2, -4, 8, 3] In [29]: ls.sort() In [30]: ls Out[30]: [-4, -1, 2, 3, 8] In [31]: ls.sort(reverse=1) In [32]: ls Out[32]: [8, 3, 2, -1, -4] In [33]: b = ls.sort() In [34]: b In [35]: print b None #并不能生成新列表 使用sort是按照递增序列排序，使用参数reverse是递减序列排序，但是这样的方法改变了列表原来的值。\nsort 与 sorted 区别： sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。\n如果不想改变原来的值，可以使用sorted方法，举例如下\n1 2 3 In [34]: b = sorted(ls) In [35]: b Out[35]: [-4, -1, 2, 3, 8] #生成新列表 字典排序 可以使用 sorted 对字典排序，sorted的函数原型如下所示\nsorted(iterable, cmp=None, key=None, reverse=False) --\u0026gt; new sorted list，其中iterable代指可以迭代的数据类型，key表示按照什么排序，可以使用lambda函数，举例如下\n1 2 3 4 5 6 7 8 9 10 11 In [20]: x Out[20]: {\u0026#39;A\u0026#39;: 34, \u0026#39;B\u0026#39;: 23, \u0026#39;C\u0026#39;: 10, \u0026#39;Y\u0026#39;: 2} In [21]: x.items() Out[21]: [(\u0026#39;A\u0026#39;, 34), (\u0026#39;Y\u0026#39;, 2), (\u0026#39;C\u0026#39;, 10), (\u0026#39;B\u0026#39;, 23)] In [22]: y = sorted(x.items(),key = lambda item: item[1]) #按照元组的第2个元素排序 In [23]: y Out[23]: [(\u0026#39;Y\u0026#39;, 2), (\u0026#39;C\u0026#39;, 10), (\u0026#39;B\u0026#39;, 23), (\u0026#39;A\u0026#39;, 34)] In [24]: y = sorted(x.items(),key = lambda item: item[0]) #按照元组的第1个元素排序 In [25]: y Out[25]: [(\u0026#39;A\u0026#39;, 34), (\u0026#39;B\u0026#39;, 23), (\u0026#39;C\u0026#39;, 10), (\u0026#39;Y\u0026#39;, 2)] 还有一种更简单的方法，使用 python 的operator模块，举例如下\n1 2 3 4 5 6 7 In [33]: from operator import itemgetter In [34]: y = sorted(x.items(),key = itemgetter(0)) #取元组第一个元素 In [35]: y Out[35]: [(\u0026#39;A\u0026#39;, 34), (\u0026#39;B\u0026#39;, 23), (\u0026#39;C\u0026#39;, 10), (\u0026#39;Y\u0026#39;, 2)] In [36]: y = sorted(x.items(),key = itemgetter(1)) #取元组第二个元素 In [37]: y Out[37]: [(\u0026#39;Y\u0026#39;, 2), (\u0026#39;C\u0026#39;, 10), (\u0026#39;B\u0026#39;, 23), (\u0026#39;A\u0026#39;, 34)] 字典排序的本质就是将字典的 items 对转换成列表，使用列表的排序方式来排序，sorted还有更复杂的功能，对于复杂的元组列表，可以根据元组中的任意一个元素排序，具体如下所示\n1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; student_tuples = [ ... (\u0026#39;john\u0026#39;, \u0026#39;A\u0026#39;, 15), ... (\u0026#39;jane\u0026#39;, \u0026#39;B\u0026#39;, 12), ... (\u0026#39;dave\u0026#39;, \u0026#39;B\u0026#39;, 10), ... ] \u0026gt;\u0026gt;\u0026gt; sorted(student_tuples, key=lambda student: student[2]) # sort by age [(\u0026#39;dave\u0026#39;, \u0026#39;B\u0026#39;, 10), (\u0026#39;jane\u0026#39;, \u0026#39;B\u0026#39;, 12), (\u0026#39;john\u0026#39;, \u0026#39;A\u0026#39;, 15)] numpy 中的向量和矩阵的排序 numpy 中的排序方法与之前的类似，使用sort即可，不过 numpy 多了一个axis的选项，表示按行（axis = 1）还是按照列进行排序 (axis = 0)，具体举例如下\n1 2 3 4 5 6 7 8 9 In [7]: a = np.array([[1,4], [3,1]]) In [8]: a.sort(axis =1) In [9]: a Out[9]: array([[1, 4], [1, 3]]) In [10]: a.sort(axis =0) In [11]: a Out[11]: array([[1, 3], [1, 4]]) 如果需要获得排序的 index，可以使用argsort方法，比如\n1 2 3 4 In [16]: arr = np.array([1,3,2,6,3,4,-1]) In [17]: index = arr.argsort() In [18]: index Out[18]: array([6, 0, 2, 1, 4, 5, 3]) 参考资料 Python dict sort 排序 按照 key，value - All About Python - SegmentFault Sorting HOW TO — Python 3.6.3 documentation ","date":"2018-07-21T20:28:44Z","permalink":"https://blog.bugxch.top/p/python%E6%8E%92%E5%BA%8F/","title":"python排序"},{"content":"git笔记记录。\ngit 是目前全世界最流行的分布式版本控制工具，与之前的集中化的版本控制系统相比，它有如下的优势\n项目管理更安全。集中式版本控制系统，只要服务器崩溃，那所有人的代码都将丢失。git 的每个项目参与者都会在自己的本地保存一份完整的代码备份，即便其中的一个或者多个电脑出现问题，依然可以通过其他人的代码恢复。 不需要联网也可以管理。git 在本地有一套自己完整的版本管理机制，即便断网程序员也可以在本地进行修改，添加或者删除文件，将自己的代码提交到本地的版本库，所有的操作都被忠实得记录在本地版本库中，到时候只要联网恢复，将本地的所有修改 push 到远端的服务器即可。 核心概念 git 的版本管理基于如下的概念框架，只有掌握这些概念才能理解它指令之后的真正含义。核心的 git 框架如下图所示\n我们先不用管其中的横向的命令，仅仅关注其中的 4 个圆柱体，分别代表不同的实体，本地包括 workspace, index 和 local repository 三个部分，在服务器端有 remote repository，下面分别详细介绍它们\nworkspace， 本地的工作目录，它是 Git 用来保存元数据和对象数据库的地方，添加，修改，删除等操作就在这个目录里面进行； index， 暂存区域，这是 git 的缓存机制，在 workspace 的修改可以暂存在这个区域； local repository，本地仓库，我们将 index 区域的代码提交到本地仓库，就完成一次完整的修改。 remote repository，远端仓库，这是远端服务器存放代码的地方，比如现在非常流行的 GitHub，可以将本地仓库的代码推送到远端仓库，供其他人浏览和下载。 文件状态 workspace 里面的文件无外乎两种状态：已跟踪或者未跟踪。如果文件已经被纳入到版本管理中就为已跟踪，直观的理解就是之前在版本库里添加或者提交过该文件，版本库有该文件的记录，它已经感知到该文件的存在；如果该文件从未提交或者添加到版本库中，那么它就是未被跟踪的。\n如下图所示，比如你在 workspace 里面新建了一个文件，之后没有任何动作，此时该文件是未跟踪状态，但是如果你将它添加到暂存区域，或者之后又提交到本地仓库，那么就变成了已跟踪状态。\n基本流程 下面我们结合具体的实例，介绍下使用 git 在本地进行版本管理的流程，重点是熟悉基本的操作以及其中所用到的指令。我最近在学习 C++，需要根据《C++ primer plus》写一些小程序进行练习，及时记录学习的进度，所以我自己在本地新建一个 git 仓库管理这些文件。\n创建 git 仓库 1 2 git init //创建新仓库 git clone \u0026lt;url\u0026gt; //从url上下载已有的仓库 这是使用 git 的基础，我们有两种方式创建仓库\n本地新建。我在本地创建文件夹 C++ primer plus，然后在 windows 下切换到该目录下，使用敲入git init，命令行提示\n1 2 $ git init Initialized empty Git repository in D:/Study/C++ primer plus/.git/ 初始化后，在当前目录下会出现一个名为.git的目录，所有 Git 需要的数据和资源都存放在这个目录中。，自己不要去修改它。\n远端下载。我可如果想对某个开源项目出一份力，可以先把该项目的 Git 仓库复制一份出来，这就需要用到 git clone 命令。比如我想将 ss-qt5 的代码拉下来，可以使用如下的指令git clone git@github.com:shadowsocks/shadowsocks-qt5.git，拉下来的基本格式是git clone [url]，之后在我的本地电脑就有一份完整的该项目的代码 检查文件状态 1 git status 在添加文件之前，先介绍一个非常有用的命令git status，它可以查看当前版本库中的所有文件状态，包括已跟踪或者未跟踪的文件。\ngit status会将 workspace 和暂存区的文件比对，同时比对本地仓库有暂存区的文件。\n在当前的目录下，敲入该命令，输出如下\n1 2 3 $ git status On branch master nothing to commit, working directory clean 这个提示说明，现在的工作目录相当干净，所以已经跟踪的文件在上次提交之后没有被修改过。而且，在当前的目录中没有任何还没有被跟踪的新文件，当前工作的分支是master，凡事本地创建分支默认都是这个名字，后续分支管理可以改变分支，下篇再介绍。\n添加文件 1 2 git add \u0026lt;file\u0026gt; //添加并跟踪文件file（的修改） git add . //将workspace中的所有文件添加到暂存区 创建本地仓库之后，就可以在仓库里面添加文件了。我在仓库里面新建readme.txt文件，并在文件中写入\n1 This is the 1st line of the file. 使用git status查看当前的窗台状态，显示如下\n1 2 3 4 5 6 7 $ git status On branch master Initial commit Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) readme.txt nothing added to commit but untracked files present (use \u0026#34;git add\u0026#34; to track) 显示可能会有差异，我将其中的空行去掉了，这段话表明当前文件readme.txt还没有被跟踪 (untracked)，当前没有文件需要添加，使用git add \u0026lt;file\u0026gt;将其跟踪。那我们使用git add readme.txt跟踪该文件，命令行没有任何回应，表明一切正常。之后再次使用git status查看如下\n1 2 3 4 5 6 $ git status On branch master Initial commit Changes to be committed: (use \u0026#34;git rm --cached \u0026lt;file\u0026gt;...\u0026#34; to unstage) new file: readme.txt 显示当前的readme.txt已经进入暂存区，该文件可以被 committed。\n**git add 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area，同时未曾跟踪过的文件标记为需要跟踪。**如果一次需要添加所有的文件，可以使用git add .，其中的.表示当前工作区中的所有文件。\n我继续修改readme.txt文件，添加一行this is the 2nd line，之后再添加文件test.cc，查看文件状态，显示如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $ git status On branch master Initial commit Changes to be committed: (use \u0026#34;git rm --cached \u0026lt;file\u0026gt;...\u0026#34; to unstage) new file: readme.txt Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git checkout -- \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: readme.txt Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) test.cc 这里有比较有意思的地方，test.cc与之前的readme.txt一样，后来新加的文件，因此它显示该文件未被跟踪。这里需要详细说明一下readme.txt，现在在 workspace 和 index 的暂存区都有该文件，但是两个文件的内容不同，workspace 中的是最新的修改版本，包含了第 2 行，但是 index 中的仅仅包含第一行（因为第 2 次修改之后还没有git add），所以才会有两条显示信息。\n暂存区与本地版本库相比，还有些修改 (第 1 行) 没有 commit;\nworkspace 与暂存区相比，还有些修改 (第 2 行) 没有被跟踪。\n所以，可以看出 git 记录的是文件的修改而不是文件本身。现在使用git add readme.txt则将会把 workspace 中的新修改一并跟踪并记录在暂存区中，如下所示\n1 2 3 4 5 6 7 8 9 $ git status On branch master Initial commit Changes to be committed: (use \u0026#34;git rm --cached \u0026lt;file\u0026gt;...\u0026#34; to unstage) new file: readme.txt Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) test.cc 此时的readme.txt已经是 to be committed 状态了，之前的 workspace 中的修改已经被跟踪了。\n提交修改 提交修改就是将暂存区的文件以及它们的修改提交到本地仓库，使用git commit -m \u0026quot;balabla\u0026quot;，该命令将所有的暂存区中的文件提交到本地仓库，双引号中的字符是提交的说明，输入该命令将readme.txt提交到本地仓库，如下所示\n1 2 3 4 git commit -m \u0026#34;1st commit\u0026#34; [master 7aecba8] 1st commit 2 files changed, 1 insertion(+), 1 deletion(-) create mode 100644 test.cc 表示暂存区的所有文件已经提交，此时查看状态如下\n1 2 3 git status On branch master nothing to commit, working directory clean 说明工作区很干净，workspace/index/local repository 三个区的所有东西都是一致的没有任何的差异。\n查看提交历史 1 2 git log //查看提交历史 gitk //图形化界面查看提交历史 在下一节之前，先学会查看本地的提交历史，使用git log可以查看本仓库的从最近到最远的所有提交历史，如下图所示【图片暂缺】\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ git log commit 1655db95f38ef46cf846e4e8c8abb58866c30433 (HEAD -\u0026gt; master) Author: bugxch \u0026lt;bugxch@gmail.com\u0026gt; Date: Sun Apr 15 09:57:25 2018 +0800 2rd commit commit 8e740248d2d72e4188468094c7b4c4ccb0b5e050 Author: bugxch \u0026lt;bugxch@gmail.com\u0026gt; Date: Sun Apr 15 09:57:03 2018 +0800 2nd commit commit 2040c1ee8dc7bffd58fe0a206e97aa5a01db0275 Author: bugxch \u0026lt;bugxch@gmail.com\u0026gt; Date: Sun Apr 15 09:56:14 2018 +0800 1st commit 可以看出一共有 3 次提交，每个提交中包含自己的 commit_id，作者以及提交的具体时间。commit 之后的那一长串字母和数字，唯一标记每次 git 的提交，类似于 SVN 中的提交 id，之所以用这么一长串的十六进制的数字表示是为了避免很多人在同一版本库中提交时候发生冲突。如果提交的次数很多，这么看就比较长了，可以使用git log --pretty=oneline来查看比较简略的版本，如下所示\n1 2 3 4 $ git log --pretty=oneline 1655db95f38ef46cf846e4e8c8abb58866c30433 (HEAD -\u0026gt; master) 2rd commit 8e740248d2d72e4188468094c7b4c4ccb0b5e050 2nd commit 2040c1ee8dc7bffd58fe0a206e97aa5a01db0275 1st commit 仅仅包含每次提交的 id 以及说明，看起来一目了然。此外还可以使用gitk使用图形化界面查看提交历史，如下图所示\n撤销修改 1 2 3 git checkout -- \u0026lt;file\u0026gt; //撤销对workspace中文件file的修改 git reset HEAD \u0026lt;file\u0026gt; //撤销对暂存区中文件file的修改 git commit --amend //撤销本地仓库的上一次提交，并编辑新的说明重新提交 如果发现代码修改有问题，就需要撤销修改，这里依照不同的存储位置，分为如下三种情况。\n撤销 workspace 中的修改 我在readme.txt文件中不小心添加了一行字，文件内容如下\n1 2 3 This is the 1st line of the file. this is the 2nd lines my boss is a idiot 幸好及时发现，我们现在要做的就是将最后一行去掉，依然使用git status查看工作区的文件，可以看到如下的结果\n1 2 3 4 5 6 7 $ git status On branch master Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git checkout -- \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: readme.txt no changes added to commit (use \u0026#34;git add\u0026#34; and/or \u0026#34;git commit -a\u0026#34;) 明显可以看出文件的修改还没有被跟踪，而且提示我们使用git checkout -- \u0026lt;file\u0026gt;来放弃对工作区文件的修改，那我们试试看输入git checkout -- readme.txt，使用该命令后果然最后一行不见了。\n撤销暂存区中的修改 依然以上面的文件为例，我在文件末尾添加那一句my boss is an idiot，之后使用git add readme.txt添加到暂存库，查看状态\n1 2 3 4 5 6 $ git status On branch master Changes to be committed: (use \u0026#34;git reset HEAD \u0026lt;file\u0026gt;...\u0026#34; to unstage) modified: readme.txt 提示我可以使用git reset HEAD \u0026lt;file\u0026gt;放弃修改，使用该命令看看\n1 2 3 4 5 6 7 8 9 10 $ git reset HEAD readme.txt Unstaged changes after reset: M readme.txt $ git status On branch master Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git checkout -- \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: readme.txt 可以看出修改又回复到之前在工作区的状态，继续使用git checkout -- readme.txt彻底撤销之前的修改。\n撤销本地仓库中的修改 之前的撤销相对比较容易，如果已经提交到了本地仓库该撤销修改呢？现在我们修改readme.txt文件为如下内容\n1 2 3 This is the 1st line of the file. this is the 2nd lines my boss is a idiot 然后git add .,git commit -m \u0026quot;hahahaha\u0026quot;，这样就提交到了本地仓库，查看提交历史，如下所示\n1 2 3 4 5 6 $ git log --pretty=oneline 498ebae5cbbb94a9fc1c549b1bd0cdc2fea5c886 hahahahaha 72b68e57aa9b18fcdd031d5901407a83c408580e revert the file b250f9715a00d5f72caee1b6d0d7ab1d69e9c27b 2nd modification 27ed1eb9e7fb8a20176618e54c0464e721537da7 the 1st commit abbd1c9e580a35aefe453615620d27ab464066c7 第一次提交readme.txt 代码已经提交了。可以使用git reset --hard HEAD^放弃这次修改。这条指令的解析如下\ngit reset，表示回退，这个指令既可以将暂存区的数据回退到工作区，也可以回退版本。 --hard，表示回退版本的同时，将工作区和暂存区的文件内容也同步回退，这里还有两个选项，具体见下表 参数 意义 hard 仅仅回退版本，修改工作区和暂存区文件 mixed 回退版本，修改暂存区文件，不修改工作区 merge 回退版本，修改暂存区文件，修改工作区中那些被跟踪的文件 soft 仅仅回退版本，不修改工作区和暂存区文件 HEAD表示当前版本的指针所在，HAED^表示前一个版本，HEAD^^表示之前两个版本，如果是前 100 个版本则可以使用HEAD~100。 使用该命令之后的结果如下\n1 2 3 4 5 $ git log --pretty=oneline 72b68e57aa9b18fcdd031d5901407a83c408580e revert the file b250f9715a00d5f72caee1b6d0d7ab1d69e9c27b 2nd modification 27ed1eb9e7fb8a20176618e54c0464e721537da7 the 1st commit abbd1c9e580a35aefe453615620d27ab464066c7 第一次提交readme.txt 此外，也可以直接指定版本号，回退到特定的版本，比如我想回退到最早的那个版本，可以使用如下的命令git reset --hard abbd1c，后面的版本号就是第一次提交的 commit_id 的前几位，不必全部都写全，系统可以区分其他版本即可。输出结果如下\n1 2 3 4 $ git reset --hard abbd1c HEAD is now at abbd1c9 第一次提交readme.txt $ git log --pretty=oneline abbd1c9e580a35aefe453615620d27ab464066c7 第一次提交readme.txt 现在已经回退到之前最早的版本了。\n误删怎么办 如果误删，可以使用git reflog，它记录了我们所有的操作，可以看到之前的 commit_id 以及对应的说明，如下所示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ git reflog abbd1c9 HEAD@{0}: reset: moving to abbd1c 72b68e5 HEAD@{1}: reset: moving to HEAD^ 498ebae HEAD@{2}: commit: hahahahaha 72b68e5 HEAD@{3}: reset: moving to HEAD^ 461cb5a HEAD@{4}: commit: hahhaha 72b68e5 HEAD@{5}: reset: moving to HEAD^ 7ea5d40 HEAD@{6}: commit: my boss hahaha 72b68e5 HEAD@{7}: commit: revert the file b250f97 HEAD@{8}: commit: 2nd modification 27ed1eb HEAD@{9}: commit (amend): the 1st commit 7aecba8 HEAD@{10}: commit: 1st commit abbd1c9 HEAD@{11}: reset: moving to abbd1c 3325ee6 HEAD@{12}: commit: 1st commit 52c2155 HEAD@{13}: commit: 1st commit abbd1c9 HEAD@{14}: commit (initial): 第一次提交readme.txt 如果要恢复到hahahaha的版本，可以使用如下的指令\n1 2 3 4 5 6 7 8 9 $ git reset --hard 461cb5a HEAD is now at 461cb5a hahhaha $ git log --pretty=oneline 461cb5a8f35e5dc2b8dd4917d825b1b2d3c9bce3 hahhaha 72b68e57aa9b18fcdd031d5901407a83c408580e revert the file b250f9715a00d5f72caee1b6d0d7ab1d69e9c27b 2nd modification 27ed1eb9e7fb8a20176618e54c0464e721537da7 the 1st commit abbd1c9e580a35aefe453615620d27ab464066c7 第一次提交readme.txt 修改成功~\n所有上面的操作可以总结在如下的一张图里\n参考资料 Git Tutorial - Try Git Git 与 Repo 简单入门 - 简书 Pro Git 简体中文版，非常全面的 git 小书 Git 教程 - 廖雪峰的官方网站，有对应的 ios 的 Git App for iOS - 廖雪峰的官方网站 图解 Git ","date":"2018-07-21T20:26:54Z","permalink":"https://blog.bugxch.top/p/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/","title":"Git学习笔记（一）"},{"content":"接上一篇博客《为什么会有补码？》，我仅仅分析了整数在计算机中表示方式，但是计算机中的浮点数又是如何表示的呢？\n引子 首先，使用之前博客的程序，可以看到如下的这些实数在计算机中的计算结果是\n实际数值 数值类型 计算机中的表示 102.3235 float 42CCA5A2 -3.256 float C050624E 120.254 double 405E104189374BC7 -56.2441 double C04C1F3EAB367A10 右边的计算机中的数值表示是按照《IEEE 754-2008》的标准存储数据的，具体的规定如下所示。\nIEEE 754 标准 表示形式 IEEE 754规定了二进制浮点数在计算中的存储方式，我们以C语言中的float为例来具体说明。无论是32位系统还是64位系统，计算机中的float占用4个字节，我们就使用这些字节来存储任意的浮点数，可以参考下图\n转化成对应的数学表示形式，浮点数 V\n$$ V = (-1)^s\\times M\\times 2^E $$\ns 表示符号位，占据1个bit 位，如果是负数则s=1，如果是非负数则s=0； M表示尾数，占据23个比特，表示有效数字，表示的数字介于1和2之间； E为直属，表示基于2为基数的指数大小，占据8个比特。 因此，如果确认了上面3个参数，也就唯一确定了浮点数在计算机中的存储形式。我们以 102.3235为例，来看看上面的这几个数字是如何表示出来的？\n102.3235的二进制原码形式是 1100110.01010010110100001110 = 1.10011001010010110100001110*2^6； 确认s。因为是正数，因此 s=0。 确认M。M表示 1.xxxxxx之后的 xxxxxx的部分，即计算机内部保存M时，默认表示的第一位总是 1，可以舍弃表示 1 的这一位，而仅仅存储小数点之后的部分。因此 M=10011001010010110100001110，因为只能存储23个比特，将多余的位数部分截断得到M=10011001010010110100001。 确认E。它是个非负正数，按照第1步计算出来的结果，我们的指数应该是6。但是，IEEE规定根据二进制计算浮点数时，需要给指数减去一个偏置值，对于float类型这个数为127，对于double类型，这个数是1023。因此反过来，在将数字转换成二进制存储的时候，要加上这个偏置值，因此 E=6+127=133。 综合以上的所有计算结果，最后在计算机中存储的形式是 01000010110011001010010110100001，转换成16进制就是 42CCA5A2。 特别规定 依照上面的方法，可以依次确认其他3个浮点数的表示形式。这都是比较常规的规格化数据的处理方法，IEEE针对一些特殊的数字（绝对值特别接近0的数字或者无穷大无穷小），引入了一些特殊的规定，称为非规格化表示方法，总结如下。\n上一个章节介绍的是规格化的数据，除此之外，还有非规格化的数据和特殊的数据，总结如下\n规格化数据。如果指数部分既不是0也不是255（指数部分既不全为0或者不全为1），就是规格化存储方式，具体的计算方法与之前介绍的相同。此时$E = e - Bias$，这里的$e$是指数位宽$w$二进制比特对应的无符号整数，$Bias = 2^{w-1} - 1$，$M = 1.0 + f$。\n非规格化数据。指数全为0 就是非规格化的数据。此时$E = 1 - Bias$，$Bias$的值与规格化的相同，$M = f$。很明显，规格化数据不能表示0，非规格化的数据可以，而且0有两种表示。\n特殊数字。指数全为1 表示特殊的数字\n如果$f$全为0，表示无穷大，正负取决于符号$s$，分别表示$+\\infty$和$-\\infty$； 如果$f$不为0，表示这是一个非数NaN(Not a Number)。 float16的浮点表示 参考半精度浮点数，基于上面的理解，我们可以研究下float16的一些特点。float16是用16个bit表示浮点数，不同的bit位的表示如下\n因为负数和正数的值除了符号之外是对称的，所以我们仅仅研究所有的正整数表示即可，将16位比特从0到 $2^{16}-1$ 的比特逐个写出来，可以看到如下的表格\n说明 二进制比特 $E$ $M$ 准确值($M \\times 2^E$) 十进制数 最小非规格化数 0000000000000000 -14 $0\\times 2^{-10}$ $0.0 \\times 2^{-15}$ 0.0 0000000000000001 -14 $1\\times 2^{-10}$ $1\\times 2^{-10}\\times 2^{-14}$ $6\\times 10^{-8}$ 0000000000000010 -14 $2\\times 2^{-10}$ $2\\times 2^{-10}\\times 2^{-14}$ $1\\times 10^{-7}$ 0000000000000011 -14 $3\\times 2^{-10}$ $3\\times 2^{-10}\\times 2^{-14}$ $2\\times 10^{-7}$ 最大非规格化数 0000001111111111 -14 $(2^{10}-1)\\times 2^{-10}$ $(2^{10}-1)\\times 2^{-10}\\times 2^{-14}= 2^{-14}-2^{-24}$ $6\\times 10^{-5}$ 最小规格化数 0000010000000000 -14 $1 + 0 \\times 2^{-10}$ $2^{-14}$ $6.104\\times 10^{-5}$ 0000010000000001 -14 $1 + 1 \\times 2^{-10}$ $2^{-14}+2^{-24}$ $6.11\\times 10^5$ 1 0011110000000000 0 $1+0\\times 2^{-10}$ $1$ $1$ 最大规格化数 0111101111111111 15 $1+(2^{10}-1)\\times 2^{-10}$ $(2-2^{-10})\\times 2^{15}$ $65504$ 正无穷大 0111110000000000 \u0026ndash; \u0026ndash; \u0026ndash; $+\\infty$ 观察上面的表格，可以得到如下的一些结论：\n相对于数学上无穷多的实数，计算机可以精确表示的实数只有有限多个，半精度浮点数可以最多表示$2^{16}$个数，float最多表示$2^{32}$个数等。\n数字在数轴上的表示，越靠近0，可以表示浮点数的越稠密，相应的精度也越高，最高精度是在靠近0的非规格化数里面。假设指数的位宽是 $k$ bit，尾数的位宽是 $n$ 比特，那么最高精度为 $\\epsilon = 2^{-n}\\times 2^{2-2^{k-1}}= 2^{2-n-2^{k-1}}$，可以看出，k和n越长，精度越高，相对于n，k是精度的关键因素。下图是一个按照IEEE的标准的8bit位宽的浮点数表示图（1个bit符号位，3bit是指数位，4bit尾数位），明显可以看到在0的附近表示的数字越稠密。使用ctrl和鼠标中键放大之后，可以看到在0附近的浮点数是均匀分布的。\n从数字0开始，有连续$2\\times 2^{n} = 2^{n+1}$个数是等差数列，数列的公差是$\\epsilon$，这些数就是$e = [0000\\dots0]$和$e=[000\\dots01]$的那些数，也就是$E = 1-Bias$的这些数。如果将它们标示在数轴上，它们是最靠近0的那部分区域，这些点均匀分布在这一块区域；\n0和1都可以精确表示，而且因为符号有+-两个符号，所以0有两种表示。\n最大非规格化数和最小化规格数相差一个$\\epsilon$，这个差值与非规格数的之间的差值相同，二者平滑过渡。\n可以表示的最大规格化数是$(1-2^{-n-1})\\times 2^{2^{k-1}}$;\n如果将二进制比特看成u16的数，那么这些数本身表示的u16的数据大小与它们表示的float的大小关系相同，都是递增的。\n通过上面数据的分布，还可以看到一个有趣的现象，从0开始沿着数轴往右走，依次经过0 -\u0026gt; 最小非规格化数 -\u0026gt; 最大非规格化数 -\u0026gt; 最小规格化数 -\u0026gt; 1 -\u0026gt; 最大规格化数 -\u0026gt; 正无穷大\n下面的代码可以将所有的半精度浮点数的所有非负数表示出来（严格得说，不包括-0.0），可以都打印出来体会下上面的结论\n1 2 3 4 5 6 7 8 9 10 # -*- coding: utf-8 -*- import matplotlib.pyplot as plt import numpy as np udata = np.uint16(0) p1 = [] # all of non-negative float16 number for i in range(2**15): p1.append(udata.view(np.float16)) udata += 1 udata = np.uint16(udata) 参考资料 浮点数的二进制表示 - 阮一峰的网络日志 IEEE 754 - Wikiwand IEEE-754 Floating Point Converter 深入理解计算机系统（2.7） Fun with floating point - Presentation Source What you never wanted to know about floating point but will be forced to find out ","date":"2018-07-21T08:19:45Z","permalink":"https://blog.bugxch.top/p/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA/","title":"浮点数在计算机中的表示"},{"content":"C语言的链表基本操作。\n为何需要链表？ 学习 C 语言的开始，我们最早接触的数据类型是数组，它有两个特点：\n顺序存储所有的元素，连续占用内存空间； 创建数组时需要事先知道存储元素的个数，确定数组的长度； 查询元素复杂度是 O(1)O(1)，删除和插入的复杂度是 O(n)O(n)。 数组元素非常适合元素个数基本保持不变的场景，特别便于查阅操作，但是如果数据存储的元素个数经常发生变化，操作起来复杂度就很高，因此急需一种数据结构便于插入和删除，链表就很合适。\n概念 一个链表的示意图如下所示\n链表在内存中不是连续的顺序存储的，链表包括表头，表尾和中间结点。\n中间结点包括数据域和指针域 数据域用于储存当前结点的数据，通常是数据类型 指针域指示下一个结点在内存中的地址，是一个指针 表头是特殊的中间结点，它的数据域可以包括表的长度或者什么都没有，但是指针域必须指向单链表的第一个中间结点的位置 表尾也是特殊的中间结点，数据域可以存储数据，因为已经没有后继结点，指针域为空 优势 单链表和数组相比的优势体现在如下两个方面：\n空间存储更灵活，单链表不需要连续占用内存空间，因为每个结点都知道它的后继结点在内存中的位置，所以不需要连续存储； 空间申请更灵活，可以使用动态内存分配，在程序运行时候按需申请内存大小，避免数组申请过大造成的浪费。 空间释放和增加更灵活，删除一个元素仅仅需要将该元素的前置元素指针指向它的后继结点，释放该结点即可，增加元素只需要更改指针指向即可，复杂度是 O(1)O(1) 但是，单链表的劣势也很明显，单链表中的元素仅仅知道后继结点的位置，如果需要查询某个元素，只能从头结点开始一个一个地去遍历，而不像数组直接给出下标一步就能定位到，因此单链表的查询复杂度是 O(n)O(n)。\n代码示例 假定单链表的数据元素的数据类型是ElemType，那单链表可以定义如下\n1 2 3 4 5 typedef struct Node { ElemType data; struct Node *next; }Node; typedef struct Node * LinkList; 特别注意，有个特点，单链表有一个指向自身的指针，表示下一个结点next的位置。单链表的常用操作包括：创建，查询，插入，删除，清除。\n创建列表 创建有两种方法，头插法和尾插法，第一种是保持新插入的元素始终在表的第一个元素，第二个保持新插入的元素始终在表的最后一个元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /*头插法创建链表*/ void CreateListHead(LinkList *L, int n){ LinkList p; int i; srand(time(0)); *L = (LinkList)malloc(sizeof(Node)); (*L)-\u0026gt;next = NULL; for(i = 0; i \u0026lt; n; i++){ p = (LinkList)malloc(sizeof(Node)); p-\u0026gt;data = rand() % 100 + 1; p-\u0026gt;next = (*L)-\u0026gt;next; (*L)-\u0026gt;next = p; } } 尾插法代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /*尾插法创建链表*/ void CreateListTail(LinkList *L, int n){ LinkList p,r; int i; srand(time(0)); *L = (LinkList)malloc(sizeof(Node)); (*L)-\u0026gt;next = NULL; r = *L; for(i = 0; i \u0026lt; n; i++){ p = (LinkList)malloc(sizeof(Node)); p-\u0026gt;data = rand() % 100 + 1; r-\u0026gt;next = p; r = p; } r-\u0026gt;next = NULL; } 查询元素 工作的基本原理就是工作指针后移，这个技巧也是单链表操作的基础和关键。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* 单链表已经存在，用e返回L中的第i个元素的值*/ Status GetElem(LinkList L, int i, ElemType *e) { int j = 1; LinkList p = L-\u0026gt;next; while(p \u0026amp;\u0026amp; j \u0026lt; i) //p不为空并且j还没有和i相等时，继续往后查找 { p = p-\u0026gt;next; //一直指向下一个结点，顺藤摸瓜 ++j; } if(!p || j \u0026gt; i) return ERROR; *e = p-\u0026gt;data; return OK; } 插入元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* 单链表已经存在，在第i个元素位置插入新的元素e，L的表长加1*/ Status ListInsert(LinkList *L, int i, ElemType e) { int j = 1; LinkList p = *L-\u0026gt;next, s; while(p \u0026amp;\u0026amp; j \u0026lt; i) //p不为空并且j还没有和i相等时，继续往后查找 { p = p-\u0026gt;next; //一直指向下一个结点，顺藤摸瓜 ++j; } if(!p || j \u0026gt; i) return ERROR; s = (LinkList)malloc(sizeof(Node)); s-\u0026gt;data = e; s-\u0026gt;next = p-\u0026gt;next; p-\u0026gt;next = s; return OK; } 删除元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* 单链表已经存在，删除链表L的第i个元素，并用e返回其值，表长减1*/ Status ListInsert(LinkList *L, int i, ElemType *e) { int j = 1; LinkList p = *L-\u0026gt;next, q; while(p \u0026amp;\u0026amp; j \u0026lt; i) //p不为空并且j还没有和i相等时，继续往后查找 { p = p-\u0026gt;next; //一直指向下一个结点，顺藤摸瓜 ++j; } if(!p || j \u0026gt; i) return ERROR; q = p-\u0026gt;next; p-\u0026gt;next = q-\u0026gt;next; *e = q-\u0026gt;data; free(q); return OK; } 删除整表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /*顺序链表L已经存在，将L重置为空表*/ Status ClearList(LinkList *L) { LinkList p, q; p = (*L)-\u0026gt;next; while(p) { q = p-\u0026gt;next; free(p); p = q; } (*L)-\u0026gt;next = NULL; return OK; } 参考资料 链表的创建和遍历_C 语言中文网 C 语言链表的概念_C 语言中文网 C 语言单链表实现 19 个功能完全详解 - Lee.Kevin - 博客园 ","date":"2018-07-20T23:18:50Z","permalink":"https://blog.bugxch.top/p/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","title":"单链表基本操作"},{"content":"我们提交的代码，要求不能有多余的空格与 TAB 键，而且代码是在 linux 环境中编译和运行的，而我们经常使用 source insight 编辑代码，因此有必要针对性地配置以省去反复去掉空格和 TAB 键的麻烦。\n我们的配置基本上都在 Preference 的菜单里，下面逐个介绍如何设置。\n处理 TAB 和空格 去掉每行末尾的空格和 TAB 键：设置Options-\u0026gt;Perferences-\u0026gt;Files-\u0026gt; Remove extra white space when saving。 TAB 键可见：设置Options-\u0026gt;Document Options-\u0026gt;Editing Options-\u0026gt;Visible tabs，就可以在代码里面看到 TAB 键。 处理换行键 *nix 系统和 Windows 系统文件中的换行符不同。\n*nix 系统中的换行符只有一个字符，\\n； Windows 系统中的换行由两个字符组成，\\r\\n； 这种区别的影响包括\nUnix/Mac 系统下的文件在 Windows 里打开的话，所有文字会变成一行； Windows 里的文件在 Unix/Mac 下打开的话，在每行的结尾可能会多出一个 ^M 符号。 Linux 保存的文件在 windows 上用记事本看的话会出现黑点。 在 linux 下，可以使用命令unix2dos把 linux 文件格式转换成 windows 文件格式，命令dos2unix把 windows 格式转换成 linux 文件格式。\n为了保证在 Windows 环境下打开文件之后仍然保持 linxu 的文件的显示正确，设置Preference-\u0026gt;Other-\u0026gt;Default file format为 Unix(LF)。\n标题栏显示文件完整路径 这个功能在查看文档路径是非常有用，去掉Preference-\u0026gt;Display-\u0026gt;Options-\u0026gt;Trim long path names while elipses。\n文件名首字母不要大写 勾选Preference-\u0026gt;Display-\u0026gt;Options-\u0026gt;Show exact case of file names。\n其他设置 将 Preference 下面的所有 tab 页都过一遍。\nGeneral Project File Synchronization-\u0026gt;Remove missing file from project选上可以避免因文件找不到而弹出错误对话框； 把Misc-\u0026gt;Use stricter confirmation dialog选项去掉可以使确认时不输入”yes”。 Typing ource Editing-\u0026gt;Indent commands affect #-preprocessor statements去掉后（默认值），进行多行缩进时不会影响预处理语句（如 #if…#endif）。\nAuto Completion-\u0026gt;Use detailed completion window，选上后，联想时可以出现该函数的详细信息 。\nAuto Completion-\u0026gt;Insert paremeters for functions，去掉后，自动联想不会把整个参数都输出到当前行。\nBrowsing in Lists-\u0026gt;Match syllables while typing(slower)在 symbol list 框检索符号时是否采用音节匹配方式，如对于函数 FindNext，输入 find 或者 next 都可以找到该函数。该功能可能导致反应缓慢（视工程和机器配置而定），建议关闭，因为即使在关闭状态下也可以通过先输入空格再输入单词来动态启用该功能。\n注意 Browsing in Lists 里其实有两个功能，但一般我们只能看到 Match syllables while typing 这一条，应该是 si 的菜单设计没有做好，导致在中文 windows 下不能显示全，另一个功能是 Match members while typing，用于打开 / 关闭按成员变量名来检索类 / 结构体的功能。\nFiles Opening Files-\u0026gt;Sharing: Let other programs modify files，以共享方式打开文件，这个很重要，保证可以在其它编辑中同时编辑该文件。典型的场景就是用 ide 环境去动态编译调试，而用 si 静态阅读； Customize 'Open' Command...，用于设置 Ctrl+O 打开的页面，默认选项是 Project File list view in Project Window，建议保持默认。 Saving Files-\u0026gt;Preserve Undo data and revision marks after saving，如果发现保存后就不能 undo 了，请检查该选项是否选中。 Remove extra white space when saving。保存时自动去除每行尾部的空格和 tab。建议选中。 Languages 自定义其它编程语言的语法解析，这个… 还是另写一篇来讲吧。\nConditional Parsing不要错过了，这里的 Conditions 功能实在让人喜欢。Conditions 是什么意思呢？我们的代码中一般都会有一些开关宏，通过在 Conditions 中配置这些宏的默认值，可以让 si 把配置为不开启的宏视为无效代码，从而不进行符号检索。\n如果源代码中的开关宏太多，还可以使用 Condition Parsing 中的 Scan Files 来自动找出所有开关宏。\nSymbol Lookups 没有特别的。\nDisplay 显示配置和个人喜好和显示器的状态有关，偶用的 x60 小本，屏幕资源有限，所以在 Display Elements 里把 Project Window, Status Bar, Tool Bar，Clip Window 都关了，基本用快捷键可以代替它们。 Options-\u0026gt;Horizontal scroll bars for each new window。很多大师都教导我们说一行不要写太多代码。在这个指导思想下，我们不需要这个东东。 Show exact case of file names。如果看不惯 si 把所有的文件名首字母都大写就勾上这个选项吧。 Tile source and destination windows for Source Link commands。Source Link 很多时候用于外部命令输出结果的解析（如 Make, lint），这个功能会把解析结果与目标窗口自动 tile，很实用。 Trim long path names with ellipses。这个建议不要选中。事实上这个主要影响标题栏，但一般来说标题栏上的空间是充裕的，选上之后往往会令我们不知道所编辑文件的具体位置。 Color 自己配置。\nSyntax Decorations 可以把一些符号转换成特殊形式显示，如 -\u0026gt; 转换成→。如果要使用该功能，不能开启Syntax Formatting-\u0026gt;Basics-\u0026gt;Use only color formatting。 Auto annotations下的三个功能都比较有用; Show arrows at goto statements可以在 goto 时显示一个向上或向下的箭头，表示是向上 goto 还是向下 goto，不过我们还是尽量不要用 goto 了。 Annotate closing braces with end-statement。在”}” 后显示标识，表示该”}” 与哪个 if/switch 配对，而下面的Annotate closing braces only for long blocks则是一个补充选项，表示只在较长的语句块时才显示标识。 Syntax Formatting 如果让大家说出喜欢 si 的几个理由，我想语法着色一定会是其中之一。\nBasics-\u0026gt;Use only color formatting。只启用 style 中关于颜色的设置。其它如粗体、斜体、阴影等都不启用。 Apply Styles for Lanugage Elements。把分类启用 style，都选上吧。 Symbol Reference Lookups-\u0026gt;Qualify references to members。检测成员的有效性，如果不是类 / 结构体中的一部分，则不启用 style。虽然可能导致性能降低，但还是建议打开。同样Qualify references to functions也是。 这里有个按钮可以进入 Doc Types 页面（Options 菜单也可以进入），里面有很多重要选项： Editing Options中， Expand tabs, Visible tabs可以帮助我们发现并转换 tab。 Show right margint和Margin width可以提醒我们是否把一行写得太长。 Symbol Window选项建议关闭（因为有快捷键）。 Auto Indent对话框中， 如果没有特别喜好，建议把Smart Indent Options的两个勾都去掉，同时Auto Indent Type选Smart。 其他的没有什么特别的了，最后简单说下 si 的配置文件。可以通过Options-\u0026gt;Load Configuration/Save Configuration来导入 / 导出配置，可以导出全部，也可以导出某几个部分（如 style）。si 的配置有两级，一是全局配置，一是项目配置。出入方便考虑，统一一个配置就好了，在创建项目时选择用全局配置（默认值）。\n参考文档 Windows、Unix、Mac 不同操作系统的换行问题 - 剖析回车符 \\ r 和换行符 \\ n - CSDN 博客 source insight 保存时删除多余空格，去除多余空格 space tab 键 - CSDN 博客 ","date":"2018-07-20T23:08:38Z","permalink":"https://blog.bugxch.top/p/source-insight-%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/","title":"Source Insight 基础配置"},{"content":"前些天公司摸底 C 语言考试，得分比较难看，回来发了考试答案，这篇博客把我做错的题目拿出来理一理，补补课。\n判断对错：在定义数据结构时，没有特殊理由的话，都定义成四字节对齐；这样做可能浪费几个字节，但是不会出问题。\n这道题答案是对的，需要仔细 Google。\n以下程序运行 (64 位系统) 后的输出结果是 6 5 8 5\n1 2 3 4 5 6 7 int main() { char str1[] = \u0026#34;Hello\u0026#34;; char str2[] = {\u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;}; char *p = str1; printf(\u0026#34;%d %d %d %d\\n\u0026#34;, sizeof(str1), sizeof(str2), sizeof(p), strlen(p)); } 这道题我的答案是 6,5,4,5，原因在于 64 位的指针的长度大小是 8 个字节，而不是一般的 4 个字节。 考点为 字符串数组长度 (+1), 64 位指针长度 (8) 字符串数组 x 包含末尾的’\\0’\n如下程序, 在 64bit 系统运行输出为 24 4 8 16\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct s1 { char a; int b; short c; double d; }; int main(void) { printf(\u0026#34;%d %d %d %d\\n\u0026#34;, sizeof(struct s1), offsetof(struct s1, b), offsetof(struct s1, c), offsetof(struct s1, d) ) ; //注: offsetof 为计算偏移量的宏 return 0; } 我的答案是 48,8,16,32，错误成了 2 倍。主要为结构体对齐规则, 这部分需要强化 一般考生都可以看到 b 按 4 字节对齐，需要填充 忽视 double 也需要 8 字节对齐 double 在 32 位 linux 平台下可能按照 4 字节对齐\n如下指针计算, 结果为 4\n1 2 3 int *p1 = (int *)0x500; int *p2 = (int *)0x510; printf(“%d\\n”, (p2 - p1)); 我错成了 16，答案应该是 16/4，指针的减法，按照指针类型计算跨越的步长\n如下程序, 请问输出多少？ -128,128\n1 2 3 4 5 6 7 void main(void) { char x = 127; char a = x + 1; int b = x + 1; printf(\u0026#34;%d %d\u0026#34;, a, b); } 我的答案是 128,128，整型加法隐式提升到 int 然后运算，所以 x+1 就是 128 溢出出现在赋值运算，第一个溢出了，第二个没有。没有考虑到第一个溢出之后的数据显示问题\n如下程序片段, 输出为: 2 7\n1 2 3 4 int *p; int x[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; p = x[0] + 1; printf(\u0026#34;%d %d\\n\u0026#34;, *p, x[2][0]); 我的答案是 4 7 。x[0] 是对二级指针解引用，类型是指向整型的指针，指向 1，+1 后，指向 x[0][1] 没争议\n计算如下定义长度 (64 位系统)\n1 2 3 4 5 6 typedef union { int a; long b; char c[6]; }un; sizeof(un) = 8 我的答案是 48，联合体的内存大小不会算，共用体的占用空间的大小，按照其最大成员算 本题中 long 是 8 字节\n请问输出多少\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 union packet { struct packet_bit { unsigned char a:2; unsigned char b:3; unsigned char c:4; } bit; int i; } data; int main() { data.i = 0; data.bit.a = 1; data.bit.b = 2; data.bit.c = 0xF; printf(\u0026#34;0x%04x\\n\u0026#34;, data.i); } 我的答案是 0xf，这道题完全是蒙出来的，考察的是位域的概念，位域结构体，按地址从低到高依次存储 a、b、c 一个规则大家可能都不熟悉： 一个位域必须存储在同一个字节中，不能跨两个字节 所以 a 和 b 储存在一个字节，c 再进来存不下，所以 c 单独存放在一个字节 再就是注意输出格式\n如下程序, 请写出打印结果 A b\n1 2 3 4 5 6 7 8 9 10 11 12 13 void fun(char *a, char *b) { a = b; (*a)++; } void main() { char c1 = \u0026#39;A\u0026#39;, c2 = \u0026#39;a\u0026#39;; char *p1 = \u0026amp;c1; char *p2 = \u0026amp;c2; fun(p1, p2); printf(\u0026#34;%c %c\\n\u0026#34;, c1, c2); } 我的结果是 a b， 函数入参是按值传递的，只有通过传递地址才能改变函数外部的值，这里有一个陷阱，使用的地址，实际是从参数 b 传进来的，所以改变的也是参数 b 指向的值 。这道题不该错，因为在 fun 函数里，a 的值已经是 b 了，所以 a 指向的就是 b 指向的地址，因此改变的就是 c2 指向的字母啊\n下面函数的输出是 token3 = 4\n1 2 3 4 5 6 7 #define paster( n ) printf( \u0026#34;token\u0026#34; #n \u0026#34; = %d\u0026#34;, token##n ) void fun() { int token3 = 4; int tokenn = 3; paster( 3 ); } 我的答案是 token3 = 3，这是个知识盲点，可以参考 C 语言宏定义 ## 连接符和 #符的使用，# 将本身的字符替换之后再在两边加上双引号，## 是机械单纯得将两个 token 连接在一起\n如下程序, 输出为 100008 100001 100004\n1 2 3 4 5 6 7 8 9 10 struct test { int a; int b; }; int main () { struct test *p = (struct test *)0x100000; printf(\u0026#34;%x %x %x\\n\u0026#34;, (p+1), (long)p+1, (int *)p +1); } 我的答案是 0x100008,0x100001,0x11。这道题比较有意思，程序第 8 行已经说明了，p 的值就是 0x100000（也就是说 p 指向的地址是 0x100000），后面 (int *)p，说明了它指向的是 int 类型，那么 + 1 就是在原来的地址上一个 int 的字节数，也就是 0x100004。需要总结的是，指针前面的表明的是这个指针指向的数据类型。\n","date":"2018-07-20T22:54:24Z","permalink":"https://blog.bugxch.top/p/c%E8%AF%AD%E8%A8%80%E8%A1%A5%E9%81%97/","title":"C语言补遗"},{"content":"今天入手了一直心心念念的顶配级kindle oasis 2，非常感谢老婆大人的资金支持，在某宝上买了美版32G的版本，可以说是顶配版了，字迹清晰，屏幕适中，爱不释手。\n基础设置 更新版本 一般而言，kindle并不像手机连接wifi之后可以自动更新，我拿到kindle之后查看我的版本号落后整整半年，而且“更新您的kindle”显示也是灰色的，所以只能自己下载版本手动更新了。至于如何查看版本号以及更新的具体步骤，可以参考文章Kindle 阅读器固件下载大全及升级方法和Kindle 阅读器固件下载大全及升级方法，详实具体，亲测有效。\n更新字体 ko2（kindle oasis 2）设备自固件5.9.6之后就支持第三方字体，所以可以自行安装中英文字体，我推荐字体Kindle 中文字体推荐：更换一下字形口味，添加字体的步骤可以参考Kindle 设备已原生支持自定义字体（附操作步骤）。\n图书资源 获取方式 kindle获取图书有两个途径：推送和导入。推送就是在将图书文件以附件的形式发送到特定的邮箱，在下次kindle联网的饿时候可以同步将图书推送到你的kindle；导入就是原始方式，通过USB将kindle与电脑相连，之后将下载的图书复制到kindle根目录下的documents文件夹，图书就会自动导入。\n把电子书推送到云端和通过 USB 直接拷贝到 Kindle 中有什么区别呢？相比直接拷贝，你今后只需要使用同一账号，登录任何一部 Kindle 设备（或 Kindle APP）中，都可以很方便的从云端获取你所推送的电子书或文档，不仅可以避免今后重置 Kindle 系统造成电子书丢失的情况，还可以享受亚马逊提供的 Whispersync 同步功能，自动将你的阅读笔记、书签和标注等数据同步到云端，很实用方便。\n推送图书 所谓 Kindle 推送是指亚马逊提供的一个“Kindle 个人文档服务”，我们只需要一个亚马逊账号，就可以通过以电子邮箱发送附件的方式，免费把 Kindle 所支持的文档或电子书推送到亚马逊提供的个人文档云存储中。当云端接收到了你推送的文档，将会自动转换格式（比如你推送的是 txt 格式会转换成 azw 格式）并同步到与此账号绑定的 Kindle 设备中。\n推送的步骤和介绍可以参考文章Kindle 推送教程：教你用电子邮箱推送电子书，需要注意一定要使用邮箱的普通附件，不要使用诸如163 云附件、QQ 中的超大附件、Gmail 中的 Google Drive 附件之类的非普通附件。还需要注意亚马逊云端对文档大小的限制是 50MB，邮箱附件大小不要超过这个数值。不过一般邮箱的附件大小也都有自己的限制，如 Gmail 最大支持 25MB，如果你想要推送超过 20MB 的附件，推荐使用 163 邮箱、QQ邮箱、新浪邮箱等，它们的附件最大限制刚好是 50 MB。\n删除云端个人文档 如果想要彻底删除推送到云端的个人文档，可以登陆亚马逊账户，进入“管理我的内容和设备”的【我的内容】，把“显示”切换到“个人文档”，即可对个人文档列表进行删除操作。在这里还可以对列表进行多选，批量删除推送到云端的内容。\n推送资源 除了看书，kindle还可以订阅微信公众号，RSS，新闻以及网页上的任意内容，具体的推送内容可以参考书伴推送服务，我没有订阅，但是应该质量满不错。\n订阅微信公众号， RSS 新闻订阅 网页推送 纽约客、经济学人等外文资源。 获取图书 参考Kindle 图书资源和书籍资源📚 | WDYFancy两篇博文，写得非常详尽，我个人体验了下，推荐如下几个网站。\nmLook 看书，上面有很多精校的电子书 走读派 - Kindle电子书瀑布流，很多优质电子书资源 优化电子书排版 参考Calibre 使用教程之优化电子书的排版 – 书伴，使用calibre能够将排版比较糟糕的电子书重新排版成美观的格式，非常赞！\n参考文章 kindle订阅整理成册的微信公众号文章 ","date":"2018-06-29T22:17:59Z","image":"https://pic.downk.cc/item/5feb4e063ffa7d37b31957b7.jpg","permalink":"https://blog.bugxch.top/p/kindle%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/","title":"Kindle使用小记"}]