<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>CSAPP on 巴巴变的博客</title>
        <link>https://blog.bugxch.top/tags/csapp/</link>
        <description>Recent content in CSAPP on 巴巴变的博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>bugxch</copyright>
        <lastBuildDate>Sat, 01 Jun 2024 21:54:52 +0800</lastBuildDate><atom:link href="https://blog.bugxch.top/tags/csapp/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>CSAPP之四——处理器体系结构</title>
        <link>https://blog.bugxch.top/p/csapp%E4%B9%8B%E5%9B%9B%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</link>
        <pubDate>Sat, 01 Jun 2024 21:54:52 +0800</pubDate>
        
        <guid>https://blog.bugxch.top/p/csapp%E4%B9%8B%E5%9B%9B%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</guid>
        <description>&lt;img src="https://image-1258996033.cos.ap-shanghai.myqcloud.com/staircase-7718335_1280.jpg?imageSlim" alt="Featured image of post CSAPP之四——处理器体系结构" /&gt;&lt;p&gt;这是CSAPP第四章，作者想通过自己定义的Y86-64的ISA指令集定义、设计、编码以及制造一个简单的单周期流水线化的处理器。作者的思路也非常清晰，包括了上述的所有步骤，在每一步描述了嵌入了处理器设计的基本原则以及需要注意的技术细节。下面是设计的ISA的指令&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image-1258996033.cos.ap-shanghai.myqcloud.com/20240602062649.png?imageSlim&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;前置知识&#34;&gt;&lt;a href=&#34;#%e5%89%8d%e7%bd%ae%e7%9f%a5%e8%af%86&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;前置知识
&lt;/h1&gt;&lt;h2 id=&#34;堆栈操作&#34;&gt;&lt;a href=&#34;#%e5%a0%86%e6%a0%88%e6%93%8d%e4%bd%9c&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;堆栈操作
&lt;/h2&gt;&lt;p&gt;作者在4.1.6和4.3.3两次提到堆栈操作的特殊性，此处做一个基本的回顾。堆栈指令包括 &lt;code&gt;popq&lt;/code&gt; 和 &lt;code&gt;pushq&lt;/code&gt; 两条，作者设计假定栈顶的地址始终保存在寄存器 &lt;code&gt;%rsp&lt;/code&gt; 中，参考&lt;a class=&#34;link&#34; href=&#34;https://blog.bugxch.top/p/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;程序的机器级表示&lt;/a&gt;中的内容，有如下示意图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.imgdb.cn/item/6278fd150947543129801e44.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
在理解上面过程之前，我们假设：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆栈中保存的是 &lt;strong&gt;8字节&lt;/strong&gt;的元素，而且按照小端法存储的，即低有效位对应低地址；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据在内存中的地址&lt;/strong&gt;，指的是整个数据的&lt;strong&gt;第一个字节在内存中的地址&lt;/strong&gt;，例如保存一个2字节的数据 &lt;code&gt;0x1234&lt;/code&gt; 在内存地址0x100处，那么0x100地址保存字节0x34，0x101处保存字节0x12。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结合上面的假设，很容易看出，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆栈是从高地址向低地址增长的，推入一个元素栈顶指针地址变小，弹出一个元素则变大；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%rsp&lt;/code&gt; 始终指向栈顶的最后一个元素的地址，也就是最后一个元素在内存中的&lt;strong&gt;起始地址&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于上面的两点，程序的操作就比较好理解了，初始状态 &lt;code&gt;%rsp&lt;/code&gt; 中地址是0x108，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 &lt;code&gt;%rax&lt;/code&gt; 寄存器中的数据push进去，所以堆栈元素要增加8字节，为了将新的元素放到堆栈里面，先执行 &lt;code&gt;%rsp = %rsp - 8&lt;/code&gt;，此时 &lt;code&gt;%rsp&lt;/code&gt; 指向要入栈的新元素的起始地址0x100，这时就可以根据 &lt;code&gt;%rsp&lt;/code&gt; 的起始地址连续存储8个字节的新元素了，这个操作类似于
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;subq&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rsp&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// rsp = rsp - 8
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;movq&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rbp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rsp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// %rbp的元素拷贝到%rsp存储的地址处
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;出栈就是相反的，当前的 &lt;code&gt;%rsp&lt;/code&gt; 保存的就是需要弹出元素的地址，那么可以直接将该地址开始的连续8个字节先拷贝到目的地址，然后 &lt;code&gt;%rsp = %rsp + 8&lt;/code&gt;，此时 &lt;code&gt;%rsp&lt;/code&gt; 指向堆栈的&lt;strong&gt;新的&lt;/strong&gt;最后一个元素的地址。等价于如下的操作
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;movq&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rsp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;subq&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rsp&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面的操作可以保证，&lt;strong&gt;&lt;code&gt;%rsp&lt;/code&gt; 始终指向栈顶元素的起始地址&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;条件传送-vs-条件分支&#34;&gt;&lt;a href=&#34;#%e6%9d%a1%e4%bb%b6%e4%bc%a0%e9%80%81-vs-%e6%9d%a1%e4%bb%b6%e5%88%86%e6%94%af&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;条件传送 vs 条件分支
&lt;/h2&gt;&lt;p&gt;条件分支是我们认识的C语言比较常规的分支程序的处理方式，下面是条件分支的一个例子&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image-1258996033.cos.ap-shanghai.myqcloud.com/20240621073237.png?imageSlim&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;计算 $|x- y|$，查看汇编指令，可以看到第8行有一个跳转到L2的过程，这里的问题在于CPU执行程序时候需要根据bool(x&amp;lt;y)判断是否需要跳转，如果判断的bool条件比较复杂，需要经过比较长的时钟周期才可以计算出结果的话，现代CPU不会等待这个结束才继续下面的计算，而是按照分支预测的方式先执行概率比较大的那个分支。如果预测分支执行中，计算得到的bool值跟预期的不一致，就需要丢弃已经执行的分支指令，重新跳转回去执行另一个没有被预测命中的分支，那这样的话计算时间就很长了。&lt;/p&gt;
&lt;p&gt;作者介绍了x86下面的传送指令，这些指令会先将源地址S中的数据读取出来，然后检查对应的条件码，根据条件码的值确认是否需要将读出来的值写入到目的寄存器R中，C语言中三目运算符编译器一般会翻译成条件传送指令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image-1258996033.cos.ap-shanghai.myqcloud.com/20240621073748.png?imageSlim&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;使用传送指令编译之前的计算绝对值的代码，如下所示，&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image-1258996033.cos.ap-shanghai.myqcloud.com/20240621074758.png?imageSlim&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image.png&#34;
	
	
&gt;
上面代码有2个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算x - y和y - x两个值；&lt;/li&gt;
&lt;li&gt;没有跳转指令，所以没有之前说的分支预测错误运行时间变长的问题，而且按照现代CPU的逻辑，推理这段代码的ALU单元基本上是满载的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;参考文献&#34;&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;参考文献
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/35038473/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;汇编语言（第4版） (豆瓣)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;本文原载于 &lt;a class=&#34;link&#34; href=&#34;http://blog.bugxch.top&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;巴巴变的博客&lt;/a&gt;，遵循 CC BY-NC-SA 4.0协议，复制请保留原文出处。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>CSAPP读书笔记</title>
        <link>https://blog.bugxch.top/p/csapp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Sun, 08 May 2022 07:32:49 +0800</pubDate>
        
        <guid>https://blog.bugxch.top/p/csapp%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;img src="https://image-1258996033.cos.ap-shanghai.myqcloud.com/csapptotal.jpeg" alt="Featured image of post CSAPP读书笔记" /&gt;&lt;p&gt;这是之前&lt;a class=&#34;link&#34; href=&#34;https://bugxch.github.io/read/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;读书计划&lt;/a&gt;中《深入理解计算机系统》的读书笔记。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;章节&lt;/th&gt;
&lt;th&gt;读书笔记&lt;/th&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;第2章&lt;/td&gt;
&lt;td&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.bugxch.top/p/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;信息的表示和处理&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;完成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第3章&lt;/td&gt;
&lt;td&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.bugxch.top/p/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;程序的机器级表示&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;在写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第4章&lt;/td&gt;
&lt;td&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.bugxch.top/p/csapp%E4%B9%8B%E5%9B%9B%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CSAPP之四——处理器体系结构&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;在写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第5章&lt;/td&gt;
&lt;td&gt;计划中&lt;/td&gt;
&lt;td&gt;计划中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;全文完🚀&lt;/p&gt;
</description>
        </item>
        <item>
        <title>程序的机器级表示</title>
        <link>https://blog.bugxch.top/p/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</link>
        <pubDate>Sun, 08 May 2022 07:27:38 +0800</pubDate>
        
        <guid>https://blog.bugxch.top/p/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</guid>
        <description>&lt;img src="https://pic.imgdb.cn/item/6277012f0947543129b619f5.jpg" alt="Featured image of post 程序的机器级表示" /&gt;&lt;p&gt;继续之前的&lt;a class=&#34;link&#34; href=&#34;https://bugxch.github.io/csapp_notes/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CSAPP读书笔记&lt;/a&gt;，这是第3章的读书笔记。&lt;/p&gt;
&lt;p&gt;第3章介绍计算机的底层机器编码，包括常见的基本数据、为了执行机器指令而设置的寄存器、算术和逻辑操作以及控制的指令。3.7节详细介绍了&lt;strong&gt;过程&lt;/strong&gt;的概念，最后是其他数据结构在计算机机器代码的表示。&lt;/p&gt;
&lt;h2 id=&#34;实验工具&#34;&gt;&lt;a href=&#34;#%e5%ae%9e%e9%aa%8c%e5%b7%a5%e5%85%b7&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;实验工具
&lt;/h2&gt;&lt;p&gt;要想研究底层机器指令，最直观的就是汇编程序，参考书本里面的介绍，以linux系统的gcc程序为工具，有两种方式可以得到。如下图所示，是一个 &lt;code&gt;hello.c&lt;/code&gt;的程序从高级语言程序编译成机器代码的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.imgdb.cn/item/6278b71f0947543129c38bee.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;strong&gt;编译器&lt;/strong&gt;运行如下命令&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gcc -Og -S hello.c
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以得到 &lt;code&gt;hello.s&lt;/code&gt;的汇编文件，该文件仅仅包括汇编指令，没有二进制的机器码，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.imgdb.cn/item/6278f45e09475431296b2e6b.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;不过对于&lt;strong&gt;理解本章节的内容已经足够&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用汇编器进一步可以将 &lt;code&gt;hello.s&lt;/code&gt;翻译成机器语言指令，称为&lt;em&gt;可重定位目标程序&lt;/em&gt;，里面全是二进制码，这个就是底层机器指令，肉眼看过去就是一串二进制码，根本不知道是什么东西。可以基于&lt;strong&gt;反汇编&lt;/strong&gt;的方法将该文件反汇编成汇编的代码，&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;gcc -Og -c hello.c &lt;span class=&#34;c1&#34;&gt;#生成hello.o文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;objdump -d hello.o &lt;span class=&#34;c1&#34;&gt;#反汇编文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;得到的文件，如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.imgdb.cn/item/6278f59b09475431296e2a64.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;与上面的方法相比，除了汇编指令之外，还有这些指令的二进制编码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基础概念&#34;&gt;&lt;a href=&#34;#%e5%9f%ba%e7%a1%80%e6%a6%82%e5%bf%b5&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;基础概念
&lt;/h2&gt;&lt;h3 id=&#34;数据格式和指令&#34;&gt;&lt;a href=&#34;#%e6%95%b0%e6%8d%ae%e6%a0%bc%e5%bc%8f%e5%92%8c%e6%8c%87%e4%bb%a4&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;数据格式和指令
&lt;/h3&gt;&lt;p&gt;这些是本章的主要内容，也是理解汇编代码的基础。具体的技术细节书本里面已经说清楚了，此处仅仅对于需要特别注意的地方做一个总结。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ISA指令包括16个长度是64bit的寄存器，这是计算机运行的数据保存的地方。需要注意，每个寄存器有长度，可以覆盖1、2、4和8个字节的所有长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算机的寻址方式有如下几种&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.imgdb.cn/item/6278f8460947543129747901.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据传送指令需要注意下面的点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;传送的指令的&lt;strong&gt;两个操作数不能都指向内存位置&lt;/strong&gt;。因此，没有指令可以直接将&lt;strong&gt;内存中的位置&lt;/strong&gt;A搬移到&lt;strong&gt;内存中的位置&lt;/strong&gt;B，必须先将A搬移到寄存器，之后再从寄存器搬移到内存B；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;movl&lt;/code&gt;这个指令比较特殊，它是传送双字（4个字节）的数据，但是也会同时将目的寄存器的高4个字节一并清零。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有的汇编指令的立即数都是二进制补码编码的，如果是十进制数，也是有符号的整数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般的栈结构，栈底是高地址，栈顶是低地址，数据在栈顶进出，&lt;code&gt;%rsp&lt;/code&gt;指向栈顶。常见的栈结构如下所示&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.imgdb.cn/item/6278fd150947543129801e44.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;算术指令的所有操作都是在寄存器中进行的，换句话说，如果需要将内存中的两个数相加，第一步是先把它们搬移到寄存器中，然后调用ADD指令再相加，结果也会保存在寄存器中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据&lt;code&gt;TEST&lt;/code&gt;指令可以判断一个数的正负或者零。因为&lt;code&gt;testq %rax %rax&lt;/code&gt;指令不会改变寄存器里面的值，但是会根据&lt;code&gt;(%rax) &amp;amp;&amp;amp; (%rax) = (%rax)&lt;/code&gt;的值来设置条件码的标志位。比如，可以根据指令结束之后的ZF的值判断是否是0，SF的值判断是否是负数等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据上一条指令的cmp结果设置指定寄存器的值，使用下面的表格实现，想起来挺烧脑，了解即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.imgdb.cn/item/6279003f094754312987963d.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跳转指令的底层机器编码中的跳转地址使用相对编码的形式。注意，汇编器生成的&lt;code&gt;*.s&lt;/code&gt;中是汇编语言，里面跳转指令的地址偏移是绝对值，但是通过链接器或者反汇编得到的&lt;strong&gt;二进制编码就是用相对寻址编码的&lt;/strong&gt;。还是书里面的例子。汇编文件如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.imgdb.cn/item/627902eb09475431298e2160.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;*.o&lt;/code&gt;反汇编之后的文件如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.imgdb.cn/item/6279031d09475431298ea166.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;注意第2行的跳转指令的地址二进制编码是03，这个是下一条指令地址的相对值，也就是&lt;strong&gt;跳转的地址（8) = 下一条指令的地址(5) + 偏移量(3)&lt;/strong&gt;。第5行也一样，5 = 0xd + f8(-8)。这样做的好处之一，是可重定位目标程序通过链接器链接之后，指令的虚拟地址发生变化，但是&lt;strong&gt;二进制编码依然保持不变&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;函数跳转&#34;&gt;&lt;a href=&#34;#%e5%87%bd%e6%95%b0%e8%b7%b3%e8%bd%ac&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;函数跳转
&lt;/h3&gt;&lt;h2 id=&#34;问题解答&#34;&gt;&lt;a href=&#34;#%e9%97%ae%e9%a2%98%e8%a7%a3%e7%ad%94&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;问题解答
&lt;/h2&gt;&lt;p&gt;学习本章的内容之后，应该可以回答下面的问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么switch的case必须是整数？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;还没写完🚀&lt;/p&gt;</description>
        </item>
        <item>
        <title>信息的表示和处理</title>
        <link>https://blog.bugxch.top/p/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</link>
        <pubDate>Fri, 22 Apr 2022 17:13:44 +0800</pubDate>
        
        <guid>https://blog.bugxch.top/p/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</guid>
        <description>&lt;img src="https://pic.imgdb.cn/item/627703420947543129b87e9a.jpg" alt="Featured image of post 信息的表示和处理" /&gt;&lt;p&gt;疫情居家办公，利用时间好好系统学习下CSAPP，年龄大了，好记性不如烂笔头，写写笔记。&lt;/p&gt;
&lt;h2 id=&#34;计算机的字长&#34;&gt;&lt;a href=&#34;#%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%9a%84%e5%ad%97%e9%95%bf&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;计算机的字长
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;每一台计算机都有字长，指明指针数据的标称大小，字长决定了的最重要的系统参数是虚拟地址空间的最大大小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;字长决定了指针的存储大小，32位的字长的指针存储空间是4字节，64位是8个字节；&lt;/li&gt;
&lt;li&gt;字长决定了虚拟地址的最大大小，所以32位的寻址空间最大是$2^{32}$Byte = 4GB，64位的是$2^{64}$Byte = 16EB。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;典型的C语言的数据类型的大小参考下表&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;C声明&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;32bit&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;64bit&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short int&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long int&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long long int&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char *&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;查看上面的表格，32bit和64bit的大部分数据类型的字节长度是一样的，仅有两个不同，long int和char *。可以使用下面的代码查看每个不同类型的字节的大小&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt;&lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt;&lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;size of char is %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;size of short is %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;size of int is %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;size of long is %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;size of long long is %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;size of double is %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;size of float is %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;size of char* is %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我在自己的64位字长的win10电脑上试了下，除了char *的字节数是4，其他的与上面表格的结果一样。&lt;/p&gt;
&lt;h2 id=&#34;整数的表示&#34;&gt;&lt;a href=&#34;#%e6%95%b4%e6%95%b0%e7%9a%84%e8%a1%a8%e7%a4%ba&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;整数的表示
&lt;/h2&gt;&lt;h3 id=&#34;整数范围&#34;&gt;&lt;a href=&#34;#%e6%95%b4%e6%95%b0%e8%8c%83%e5%9b%b4&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;整数范围
&lt;/h3&gt;&lt;p&gt;整数分为无符号和有符号整数，如果表示整数$w$位比特，那么无符号表示的范围是$[0, 2^w-1]$，有符号整数表示的范围是$[-2^{w-1},2^{w-1}-1]$。下面是一些典型值，&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.imgdb.cn/item/6263b5f9239250f7c5732b75.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;参考下表，可以在自己的PC上可以通过下面的代码，得到上面的值&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Macro&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CHAR_BIT&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;Defines the number of bits in a byte.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SCHAR_MIN&lt;/td&gt;
&lt;td&gt;-128&lt;/td&gt;
&lt;td&gt;Defines the minimum value for a signed char.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SCHAR_MAX&lt;/td&gt;
&lt;td&gt;+127&lt;/td&gt;
&lt;td&gt;Defines the maximum value for a signed char.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UCHAR_MAX&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;td&gt;Defines the maximum value for an unsigned char.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CHAR_MIN&lt;/td&gt;
&lt;td&gt;-128&lt;/td&gt;
&lt;td&gt;Defines the minimum value for type char and its value will be equal to SCHAR_MIN if char represents negative values, otherwise zero.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CHAR_MAX&lt;/td&gt;
&lt;td&gt;+127&lt;/td&gt;
&lt;td&gt;Defines the value for type char and its value will be equal to SCHAR_MAX if char represents negative values, otherwise UCHAR_MAX.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MB_LEN_MAX&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;Defines the maximum number of bytes in a multi-byte character.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SHRT_MIN&lt;/td&gt;
&lt;td&gt;-32768&lt;/td&gt;
&lt;td&gt;Defines the minimum value for a short int.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SHRT_MAX&lt;/td&gt;
&lt;td&gt;+32767&lt;/td&gt;
&lt;td&gt;Defines the maximum value for a short int.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;USHRT_MAX&lt;/td&gt;
&lt;td&gt;65535&lt;/td&gt;
&lt;td&gt;Defines the maximum value for an unsigned short int.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT_MIN&lt;/td&gt;
&lt;td&gt;-2147483648&lt;/td&gt;
&lt;td&gt;Defines the minimum value for an int.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INT_MAX&lt;/td&gt;
&lt;td&gt;+2147483647&lt;/td&gt;
&lt;td&gt;Defines the maximum value for an int.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UINT_MAX&lt;/td&gt;
&lt;td&gt;4294967295&lt;/td&gt;
&lt;td&gt;Defines the maximum value for an unsigned int.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LONG_MIN&lt;/td&gt;
&lt;td&gt;-9223372036854775808&lt;/td&gt;
&lt;td&gt;Defines the minimum value for a long int.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LONG_MAX&lt;/td&gt;
&lt;td&gt;+9223372036854775807&lt;/td&gt;
&lt;td&gt;Defines the maximum value for a long int.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ULONG_MAX&lt;/td&gt;
&lt;td&gt;18446744073709551615&lt;/td&gt;
&lt;td&gt;Defines the maximum value for an unsigned long int.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt;&lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt;&lt;span class=&#34;cpf&#34;&gt;&amp;lt;limits.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;int max is %d, int min is %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;INT_MAX&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;INT_MIN&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;char max is %d, char min is %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CHAR_MAX&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CHAR_MIN&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;补码表示&#34;&gt;&lt;a href=&#34;#%e8%a1%a5%e7%a0%81%e8%a1%a8%e7%a4%ba&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;补码表示
&lt;/h3&gt;&lt;p&gt;$w$bit的有符号整数数学表示如下，&lt;/p&gt;
&lt;p&gt;$$
B 2 T_{w}(\vec{x}) \doteq-x_{w-1} 2^{w-1}+\sum_{i=0}^{w-2} x_{i} 2^{i}
$$&lt;/p&gt;
&lt;p&gt;有一个理解的小技巧，与无符号的整数相比，对于这$w$位bit解读差异仅仅在最高位$x_{w-1}$，有符号数的权重是$-2^{w-1}$，无符号数的权重是$2^{w-1}$。这个是理解书本里面内容的技巧。典型数值的补码表示如下所示，&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.imgdb.cn/item/6263bb95239250f7c5832dd2.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;从上面的表格可以看出，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;相同位宽的无符号整数最大值与有符号整数的-1的底层bit一样；&lt;/li&gt;
&lt;li&gt;$TMin_w = -TMax_w - 1$。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;假如 &lt;code&gt;0xFA&lt;/code&gt;是某个2字节数的补码表示，那么它实际表示的数字是十进制的多少？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个问题的解答可以通过补码的定义（参考上文）逐位计算，&lt;/p&gt;
&lt;p&gt;$$
B2T_{w}(\vec{x}) \doteq-x_{w-1} 2^{w-1}+\sum_{i=0}^{w-2} x_{i} 2^{i} = -x_{w-1} 2^{w-1}+A
$$&lt;/p&gt;
&lt;p&gt;但是还有更简单直观的计算方法，我们知道二进制的无符号整数的定义是&lt;/p&gt;
&lt;p&gt;$$
B2U_{w}(\vec{x}) \doteq x_{w-1} 2^{w-1}+\sum_{i=0}^{w-2} x_{i} 2^{i} = x_{w-1} 2^{w-1}+A
$$&lt;/p&gt;
&lt;p&gt;所以，可以得到$B2U_{w}(\vec{x})  =  B2T_{w}(\vec{x})  + x_{w-1} 2^{w}$，因此，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果最高位是0，二者的结果是一样的；&lt;/li&gt;
&lt;li&gt;如果最高位是1，那么可以进一步推导&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$
B2T_{w}(\vec{x}) = B2U_{w}(\vec{x}) - x_{w-1} 2^{w} =  -\left[(2^{w} - 1) -B2U_{w}(\vec{x})\right] - 1
$$&lt;/p&gt;
&lt;p&gt;而$(2^{w} - 1) -B2U_{w}(\vec{x}) = x按位取反$，所以可以将这个补码的表示理解成unsigned的数，然后减去长度为$w$的全1的二进制比特，再减去1。&lt;/p&gt;
&lt;p&gt;所以，0xFA是情况2，补码表示的是 &lt;code&gt;-(~0xFA) - 1 = -0x05 - 1 = -6&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;c语言中无符号和有符号的转换&#34;&gt;&lt;a href=&#34;#c%e8%af%ad%e8%a8%80%e4%b8%ad%e6%97%a0%e7%ac%a6%e5%8f%b7%e5%92%8c%e6%9c%89%e7%ac%a6%e5%8f%b7%e7%9a%84%e8%bd%ac%e6%8d%a2&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;C语言中无符号和有符号的转换
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;位宽一样的无符号和有符号的整数之间的转换，遵循&lt;strong&gt;底层的bit不变&lt;/strong&gt;的原则，互相进行转换，也就是说无论如何转换，仅仅是底层bit的解读方法不同而已。&lt;/li&gt;
&lt;li&gt;C语言中的无符号数和有符号数的二元计算，都会将&lt;strong&gt;有符号数强制转换为无符号整数&lt;/strong&gt;进行计算。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;整数的扩展和截断&#34;&gt;&lt;a href=&#34;#%e6%95%b4%e6%95%b0%e7%9a%84%e6%89%a9%e5%b1%95%e5%92%8c%e6%88%aa%e6%96%ad&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;整数的扩展和截断
&lt;/h3&gt;&lt;p&gt;整数的扩展分为无符号扩展和有符号数的扩展，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无符号数的扩展就往高位bit填充0；&lt;/li&gt;
&lt;li&gt;有符号数的扩展方式是符号扩展，即最高位符号位填充空位。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;整数截断逻辑很简单，就是底层的bit表示按照目的的位宽直接截断。这一小节有一个技巧，如果是位宽较小的有符号转换成为位宽较宽的无符号数，则是&lt;strong&gt;保持符号不变，先改变位宽&lt;/strong&gt;，&lt;strong&gt;再进行转换&lt;/strong&gt;，比如下面的代码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;12345&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;uy&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;uy = %u: &lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\t&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;uy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;上面的代码中，第2行等价于(unsigned int)(int)sx，先应用符号扩展将short扩展到int，然后再使用等宽bit位的无符号的转换。&lt;/p&gt;
&lt;h3 id=&#34;编程建议&#34;&gt;&lt;a href=&#34;#%e7%bc%96%e7%a8%8b%e5%bb%ba%e8%ae%ae&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;编程建议
&lt;/h3&gt;&lt;p&gt;在实际的软件开发中，尤其要注意无符号整数和有符号整数的转换，比如下面的代码的第4行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sum_element&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.0f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果length的初始值为0，那么length - 1会是一个非常大的正数，导致对于数组a的越界访问。&lt;/p&gt;
&lt;h2 id=&#34;整数计算&#34;&gt;&lt;a href=&#34;#%e6%95%b4%e6%95%b0%e8%ae%a1%e7%ae%97&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;整数计算
&lt;/h2&gt;&lt;p&gt;这一部分的推导看起来比较复杂，刚开始读比较吃力，但是如果看懂了推导中的原则，理解起来就比较清晰了，作者在这一段的推理非常严谨。&lt;/p&gt;
&lt;h3 id=&#34;整数加法&#34;&gt;&lt;a href=&#34;#%e6%95%b4%e6%95%b0%e5%8a%a0%e6%b3%95&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;整数加法
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;无符号加法很简单，直观来讲，就是逐位相加，超过bit表示范围的高位直接截断。有符号数的加法，推理的原则是&lt;strong&gt;有符号数加法补码之和与无符号之和有完全相同的位级表示&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于加法的比较直观的理解，无论是无符号还是有符号数，两个数的加法依然需要在特定位宽的bit位上表示出来，也就是说最终的结果肯定是要落在合理的表示区间的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果$w$位宽的无符号数超过表示区间，那么就$\mod 2^w$，也就是减去$2^w$；&lt;/li&gt;
&lt;li&gt;如果$w$位宽的有符号数超过表示区间，同样是$\mod 2^w$，但是分两种，如果是负溢出，就$+2^w$，如果是负溢出就$-2^w$，举例4bit位宽的（-6）+（-3）= -9，小于-8，所以是负溢出，需要再加16，结果就是7。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要注意这里没有整数减法章节，但是介绍了&lt;strong&gt;逆元&lt;/strong&gt;的概念，$x-^t_w{y} = x + (-^t_w{y})$，两个数相减相当于加上第二个数的逆元。计算的原则同上面的2，如果超过表示区间，就做模运算。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;补码的逆元，有一种比较巧妙的方法，所有比特位取反，然后最低位+1，累进相加。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;整数乘法&#34;&gt;&lt;a href=&#34;#%e6%95%b4%e6%95%b0%e4%b9%98%e6%b3%95&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;整数乘法
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;无符号数乘法也很简单，相乘之后取模；&lt;/li&gt;
&lt;li&gt;有符号数的乘法，推理的原则是&lt;strong&gt;有符号数加法补码之积与无符号之积有完全相同的位级表示&lt;/strong&gt;。所以可以将有符号数的乘法，先转换成为无符号数的乘法计算，之后再以有符号数的补码解读位级表示即可。&lt;/li&gt;
&lt;li&gt;与常数的乘积可以转化成为右移位、加法和减法的组合，时钟周期比单纯的乘法更少。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;整数除法&#34;&gt;&lt;a href=&#34;#%e6%95%b4%e6%95%b0%e9%99%a4%e6%b3%95&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;整数除法
&lt;/h3&gt;&lt;p&gt;书里面没有介绍整数的通用除法，详细推理了整数除以2的幂的过程，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无论无符号还是有符号整数，$x\gg k = \lfloor {x/2^k}\rfloor$；&lt;/li&gt;
&lt;li&gt;对于有符号整数，$(x + (1\ll k) - 1)\gg k = \lceil x/2^k\rceil$，这里实际上是一个数学的小技巧，$(m+n-1)/n = \lceil m/n\rceil$。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;习题2.44是掌握整数运算的试金石。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;浮点数表示&#34;&gt;&lt;a href=&#34;#%e6%b5%ae%e7%82%b9%e6%95%b0%e8%a1%a8%e7%a4%ba&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;浮点数表示
&lt;/h2&gt;&lt;h3 id=&#34;ieee-754浮点数的表示法&#34;&gt;&lt;a href=&#34;#ieee-754%e6%b5%ae%e7%82%b9%e6%95%b0%e7%9a%84%e8%a1%a8%e7%a4%ba%e6%b3%95&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;IEEE 754浮点数的表示法
&lt;/h3&gt;&lt;p&gt;参考&lt;a class=&#34;link&#34; href=&#34;https://bugxch.github.io/floatincomputer/#&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;浮点数在计算机中的表示&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;舍入rounding&#34;&gt;&lt;a href=&#34;#%e8%88%8d%e5%85%a5rounding&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;舍入（Rounding）
&lt;/h3&gt;&lt;p&gt;上面的IEEE的浮点数的表示方法解决了二进制bit到浮点数的映射问题，但是如果给定一个任意精度的实数$x$，如果使用给定位宽的浮点数表示这个数呢？这里就要引入舍入的概念。&lt;strong&gt;舍入解决了将数学上的任意精度的实数集合到计算机表示的有限元素的浮点数集合的映射问题&lt;/strong&gt;。从之前的浮点数的表示可以看出，计算机表示的浮点数不可能有无限的精度，将半精度浮点数在数轴上标示出来，它在数轴上的分布是离散的，任意两个离散标示值之间的实数是无穷多的，这些实数如果要用半精度表示就只能通过某种方法&lt;strong&gt;舍入&lt;/strong&gt;到标示的某个值上。以下面的问题为例，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;半精度浮点数有下面的点，[0.01118, 0.011185, 0.01119]，那么0.011183该如何表示成半精度浮点数结果是什么呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;十进制的舍入&#34;&gt;&lt;a href=&#34;#%e5%8d%81%e8%bf%9b%e5%88%b6%e7%9a%84%e8%88%8d%e5%85%a5&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;十进制的舍入
&lt;/h4&gt;&lt;p&gt;直觉告诉我，这个数要么就是0.01118，要么就是0.011185，因为这个数字介于二者之间，如果按照误差尽量小的原则，那么可以计算一下与两个备选数字的差的绝对值，然后舍入到绝对值最小的那个上。这个就是C语言当前使用的舍入方法，称为最接近值的舍入（round to nearest)。这里面还有一个特殊的地方，以对于十进制的数字为例，舍入到最近的整数，如果这个数是两个整数的中间的值，也就是X.5的形式，那么舍入到最近的偶数。比如0.5是0和1的中间值，它举例两个数的举例是一样的，舍入到0，3.5是3和4的中间值，舍入到4。这样做可以最小化一组数的舍入误差的均值。因此，这种舍入方法又称为round to even。除此之外，还有如下的舍入方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;向0舍入，数轴上向着0的方向舍入；&lt;/li&gt;
&lt;li&gt;向下舍入，也是向$-\infty$舍入；&lt;/li&gt;
&lt;li&gt;向上舍入，即向$+\infty$舍入&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如下图所示，表示了上面的三种情况，
&lt;img src=&#34;https://pic.imgdb.cn/item/6269d201239250f7c523458b.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;二进制的舍入&#34;&gt;&lt;a href=&#34;#%e4%ba%8c%e8%bf%9b%e5%88%b6%e7%9a%84%e8%88%8d%e5%85%a5&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;二进制的舍入
&lt;/h4&gt;&lt;p&gt;那如何将十进制的舍入类推到二进制的舍入呢？这里包括两个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定舍入的位数，对于某个二进制数$0.001001_{2}$，如果是舍入到小数点后3位，那么这个位数就是3；&lt;/li&gt;
&lt;li&gt;确定需要舍入的数是否位于两个数的中间位置。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;如果在中间位置，那么向偶数方向舍入，对于二进制来讲，偶数就是最低有效位为0的数；&lt;/li&gt;
&lt;li&gt;如果不在中间位置，就向最近的数字舍入。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上面的数$0.001001_2$为例，就是确认这个数是否在$0.001_2$和$0.010_2$的中间位置，这个位置的数字是$0.0011_2$。很明显$0.001001_2$不是$0.0011_2$，而且小于该值，所以舍入到$0.001_2$。&lt;/p&gt;
&lt;p&gt;可以归纳一下，对于给定小数位的浮点数的舍入，对于形如$x.xxxyxxx_2$的二进制数（x和y是0或者1，而且不同位上的数字相互独立），假如舍入到小数点后4位，那么$y=0$或者$y=1$。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果$y=0$，那么可能舍入的两个二进制数是$x.xxx0_{2}$和$x.xxx1_{2}$，两个的中间值是$x.xxx01_2$（逐位相加，左移1个bit）；&lt;/li&gt;
&lt;li&gt;如果$y=1$，那么可能舍入的两个二进制数是$x.xxx1_{2}$和$x.xx(x+1)0_{2}$，两个的中间值是$x.xxx11_2$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，无论要舍入的小数位是0或者1，需要舍入的中间值一定是$x.xxxy1_2$形式。&lt;/p&gt;
&lt;h4 id=&#34;问题解答&#34;&gt;&lt;a href=&#34;#%e9%97%ae%e9%a2%98%e8%a7%a3%e7%ad%94&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;问题解答
&lt;/h4&gt;&lt;p&gt;回到最初的问题，$0.01118_{10}$的二进制表示是0010000110111001，按照浮点数的表示法，也就是$1.0110111001_2\times 2^{-7}$，同样的$0.011185_{10}$的二进制表示是0010000110111010，也就是$1.0110111010_2\times 2^{-7}$，如果按照精确到二进制小数点后10位（因为半精度浮点数的尾数是用10个bit来表示的），那么这两个数的中间数应该是$1.01101110011_2\times 2^{-7}$&lt;/p&gt;
&lt;p&gt;$0.011183_{10}$，转换成二进制是$1.0110111001110_2 \times 2 ^{-7}$，与中间数的二进制相比，明显大于中间数，所以舍入到比较大的$0.011185_{10}$。如果按照十进制的方式来处理也是一样的，$0.01118_{10}$和$0.011185_{10}$的中间数是$0.0111825_{10}$，明显大于这个中间数，也是舍入到较大的数。&lt;/p&gt;
&lt;h2 id=&#34;浮点数计算&#34;&gt;&lt;a href=&#34;#%e6%b5%ae%e7%82%b9%e6%95%b0%e8%ae%a1%e7%ae%97&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;浮点数计算
&lt;/h2&gt;&lt;p&gt;书本里面没有做详细的计算规则的说明，参考&lt;a class=&#34;link&#34; href=&#34;https://courses.engr.illinois.edu/cs357/sp2020/notes/ref-5-rounding.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Rounding - CS 357&lt;/a&gt;做一下说明。两个浮点数做加法需要完成下面的3个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将两个浮点数调整到相同的指数；&lt;/li&gt;
&lt;li&gt;做简单的数学的二进制加法；&lt;/li&gt;
&lt;li&gt;对结果进行舍入。
以二进制数$a =(1.101)_2$和$b=(1.001)_2\times 2^{-1}$为例，假设计算机系统表示尾数的只有3bit，那么计算就会是这样&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$
\begin{aligned}
a &amp;amp;=1.101 \times 2^{1} \
b &amp;amp;=0.01001 \times 2^{1} \
a+b &amp;amp;=1.111 \times 2^{1}
\end{aligned}
$$&lt;/p&gt;
&lt;p&gt;最后的结果以小数点后3位作为舍入精度位。可以看到无论是哪个数，有效的数字为是4位，所以没有有效数字位的丢失。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;全文完🚀&lt;/p&gt;</description>
        </item>
        <item>
        <title>浮点数在计算机中的表示</title>
        <link>https://blog.bugxch.top/p/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA/</link>
        <pubDate>Sat, 21 Jul 2018 08:19:45 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/p/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA/</guid>
        <description>&lt;p&gt;接上一篇博客&lt;a class=&#34;link&#34; href=&#34;https://bugxch.github.io/2017/12/13/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E8%A1%A5%E7%A0%81%EF%BC%9F/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《为什么会有补码？》&lt;/a&gt;，我仅仅分析了整数在计算机中表示方式，但是计算机中的浮点数又是如何表示的呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image-1258996033.cos.ap-shanghai.myqcloud.com/bridge-8291058_1920.jpg?imageSlim&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;bridge-8291058_1920.jpg&#34;
	
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;引子&#34;&gt;&lt;a href=&#34;#%e5%bc%95%e5%ad%90&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;引子
&lt;/h2&gt;&lt;p&gt;首先，使用之前博客的程序，可以看到如下的这些实数在计算机中的计算结果是&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实际数值&lt;/th&gt;
&lt;th&gt;数值类型&lt;/th&gt;
&lt;th&gt;计算机中的表示&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;102.3235&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;42CCA5A2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-3.256&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;C050624E&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;120.254&lt;/td&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;405E104189374BC7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-56.2441&lt;/td&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;C04C1F3EAB367A10&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;右边的计算机中的数值表示是按照&lt;a class=&#34;link&#34; href=&#34;https://ieeexplore.ieee.org/document/4610935/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《IEEE 754-2008》&lt;/a&gt;的标准存储数据的，具体的规定如下所示。&lt;/p&gt;
&lt;h2 id=&#34;ieee-754-标准&#34;&gt;&lt;a href=&#34;#ieee-754-%e6%a0%87%e5%87%86&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;IEEE 754 标准
&lt;/h2&gt;&lt;h3 id=&#34;表示形式&#34;&gt;&lt;a href=&#34;#%e8%a1%a8%e7%a4%ba%e5%bd%a2%e5%bc%8f&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;表示形式
&lt;/h3&gt;&lt;p&gt;IEEE 754规定了二进制浮点数在计算中的存储方式，我们以C语言中的float为例来具体说明。无论是32位系统还是64位系统，计算机中的float占用4个字节，我们就使用这些字节来存储任意的浮点数，可以参考下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.imgdb.cn/item/62672c03239250f7c5f6394d.gif&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;转化成对应的数学表示形式，浮点数 V&lt;/p&gt;
&lt;p&gt;$$
V = (-1)^s\times M\times 2^E
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;s 表示符号位，占据1个bit 位，如果是负数则s=1，如果是非负数则s=0；&lt;/li&gt;
&lt;li&gt;M表示尾数，占据23个比特，表示有效数字，表示的数字介于1和2之间；&lt;/li&gt;
&lt;li&gt;E为直属，表示基于2为基数的指数大小，占据8个比特。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，如果确认了上面3个参数，也就唯一确定了浮点数在计算机中的存储形式。我们以 &lt;code&gt;102.3235&lt;/code&gt;为例，来看看上面的这几个数字是如何表示出来的？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;102.3235&lt;/code&gt;的二进制原码形式是 &lt;code&gt;1100110.01010010110100001110 = 1.10011001010010110100001110*2^6&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;确认s。因为是正数，因此 s=0。&lt;/li&gt;
&lt;li&gt;确认M。M表示 &lt;code&gt;1.xxxxxx&lt;/code&gt;之后的 &lt;code&gt;xxxxxx&lt;/code&gt;的部分，即&lt;strong&gt;计算机内部保存M时，默认表示的第一位总是 1，可以舍弃表示 1 的这一位，而仅仅存储小数点之后的部分&lt;/strong&gt;。因此 M=10011001010010110100001110，因为只能存储23个比特，将多余的位数部分截断得到M=10011001010010110100001。&lt;/li&gt;
&lt;li&gt;确认E。它是个非负正数，按照第1步计算出来的结果，我们的指数应该是6。但是，IEEE规定根据二进制计算浮点数时，需要给指数减去一个偏置值，对于float类型这个数为127，对于double类型，这个数是1023。因此反过来，在将数字转换成二进制存储的时候，要加上这个偏置值，因此 E=6+127=133。&lt;/li&gt;
&lt;li&gt;综合以上的所有计算结果，最后在计算机中存储的形式是 &lt;code&gt;01000010110011001010010110100001&lt;/code&gt;，转换成16进制就是 &lt;code&gt;42CCA5A2&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;特别规定&#34;&gt;&lt;a href=&#34;#%e7%89%b9%e5%88%ab%e8%a7%84%e5%ae%9a&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;特别规定
&lt;/h3&gt;&lt;p&gt;依照上面的方法，可以依次确认其他3个浮点数的表示形式。这都是比较常规的&lt;strong&gt;规格化&lt;/strong&gt;数据的处理方法，IEEE针对一些特殊的数字（绝对值特别接近0的数字或者无穷大无穷小），引入了一些特殊的规定，称为&lt;strong&gt;非规格化&lt;/strong&gt;表示方法，总结如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image-1258996033.cos.ap-shanghai.myqcloud.com/20240322210012.png?imageSlim&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;上一个章节介绍的是规格化的数据，除此之外，还有非规格化的数据和特殊的数据，总结如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;规格化数据。如果指数部分既不是0也不是255（&lt;strong&gt;指数部分既不全为0或者不全为1&lt;/strong&gt;），就是规格化存储方式，具体的计算方法与之前介绍的相同。此时$E = e - Bias$，这里的$e$是指数位宽$w$二进制比特对应的无符号整数，$Bias = 2^{w-1} - 1$，$M = 1.0 + f$。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非规格化数据。&lt;strong&gt;指数全为0&lt;/strong&gt; 就是非规格化的数据。此时$E = 1 - Bias$，$Bias$的值与规格化的相同，$M = f$。很明显，规格化数据不能表示0，非规格化的数据可以，而且0有两种表示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特殊数字。&lt;strong&gt;指数全为1&lt;/strong&gt; 表示特殊的数字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果$f$全为0，表示无穷大，正负取决于符号$s$，分别表示$+\infty$和$-\infty$；&lt;/li&gt;
&lt;li&gt;如果$f$不为0，表示这是一个非数NaN(Not a Number)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;float16的浮点表示&#34;&gt;&lt;a href=&#34;#float16%e7%9a%84%e6%b5%ae%e7%82%b9%e8%a1%a8%e7%a4%ba&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;float16的浮点表示
&lt;/h2&gt;&lt;p&gt;参考&lt;a class=&#34;link&#34; href=&#34;https://www.wikiwand.com/zh-hans/%E5%8D%8A%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;半精度浮点数&lt;/a&gt;，基于上面的理解，我们可以研究下float16的一些特点。float16是用16个bit表示浮点数，不同的bit位的表示如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.imgdb.cn/item/6268ee4a239250f7c584e614.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;因为负数和正数的值除了符号之外是对称的，所以我们仅仅研究所有的整数表示即可，将16位比特从0到$2^{16}-1$的比特逐个写出来，可以看到如下的表格&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;二进制比特&lt;/th&gt;
&lt;th&gt;$E$&lt;/th&gt;
&lt;th&gt;$M$&lt;/th&gt;
&lt;th&gt;准确值($M \times 2^E$)&lt;/th&gt;
&lt;th&gt;十进制数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;最小非规格化数&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0000000000000000&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-14&lt;/td&gt;
&lt;td&gt;$0\times 2^{-10}$&lt;/td&gt;
&lt;td&gt;$0.0 \times 2^{-15}$&lt;/td&gt;
&lt;td&gt;0.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0000000000000001&lt;/td&gt;
&lt;td&gt;-14&lt;/td&gt;
&lt;td&gt;$1\times 2^{-10}$&lt;/td&gt;
&lt;td&gt;$1\times 2^{-10}\times 2^{-14}$&lt;/td&gt;
&lt;td&gt;$6\times 10^{-8}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0000000000000010&lt;/td&gt;
&lt;td&gt;-14&lt;/td&gt;
&lt;td&gt;$2\times 2^{-10}$&lt;/td&gt;
&lt;td&gt;$2\times 2^{-10}\times 2^{-14}$&lt;/td&gt;
&lt;td&gt;$1\times 10^{-7}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0000000000000011&lt;/td&gt;
&lt;td&gt;-14&lt;/td&gt;
&lt;td&gt;$3\times 2^{-10}$&lt;/td&gt;
&lt;td&gt;$3\times 2^{-10}\times 2^{-14}$&lt;/td&gt;
&lt;td&gt;$2\times 10^{-7}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;最大非规格化数&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0000001111111111&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-14&lt;/td&gt;
&lt;td&gt;$(2^{10}-1)\times 2^{-10}$&lt;/td&gt;
&lt;td&gt;$(2^{10}-1)\times 2^{-10}\times 2^{-14}= 2^{-14}-2^{-24}$&lt;/td&gt;
&lt;td&gt;$6\times 10^{-5}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;最小规格化数&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0000010000000000&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;-14&lt;/td&gt;
&lt;td&gt;$1 + 0 \times 2^{-10}$&lt;/td&gt;
&lt;td&gt;$2^{-14}$&lt;/td&gt;
&lt;td&gt;$6.104\times 10^{-5}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;0000010000000001&lt;/td&gt;
&lt;td&gt;-14&lt;/td&gt;
&lt;td&gt;$1 + 1 \times 2^{-10}$&lt;/td&gt;
&lt;td&gt;$2^{-14}+2^{-24}$&lt;/td&gt;
&lt;td&gt;$6.11\times 10^5$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0011110000000000&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;$1+0\times 2^{-10}$&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;td&gt;$1$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;最大规格化数&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0111101111111111&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;$1+(2^{10}-1)\times 2^{-10}$&lt;/td&gt;
&lt;td&gt;$(2-2^{-10})\times 2^{15}$&lt;/td&gt;
&lt;td&gt;$65500$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;无穷大&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0111110000000000&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&amp;ndash;&lt;/td&gt;
&lt;td&gt;&amp;ndash;&lt;/td&gt;
&lt;td&gt;&amp;ndash;&lt;/td&gt;
&lt;td&gt;$+\infty$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;观察上面的表格，可以得到如下的一些结论：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;相对于数学上无穷多的实数，计算机可以精确表示的实数只有有限多个，半精度浮点数可以最多表示$2^{16}$个数，float最多表示$2^{32}$个数等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数字在数轴上的表示，&lt;strong&gt;越靠近0，可以表示浮点数的越稠密&lt;/strong&gt;，相应的精度也越高，最高精度是在靠近0的非规格化数里面。假设指数的位宽是$k$bit，位数的位宽是$n$比特，那么最高精度为$\epsilon = 2^{-n}\times 2^{2-2^{k-1}}= 2^{2-n-2^{k-1}}$，可以看出，k和n越长，精度越高，相对于n，k是精度的关键因素。下图是一个按照IEEE的标准的8bit位宽的浮点数表示图（1个bit符号位，3bit是指数位，4bit尾数位），明显可以看到在0的附近表示的数字越稠密。使用ctrl和鼠标中键放大之后，可以看到在0附近的浮点数是均匀分布的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.volkerschatz.com/science/pics/fltscale.svg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从数字0开始，有连续$2\times 2^{n} = 2^{n+1}$个数是等差数列，数列的公差是$\epsilon$，这些数就是$e = [0000\dots0]$和$e=[000\dots01]$的那些数，也就是$E = 1-Bias$的这些数。如果将它们标示在数轴上，它们是最靠近0的那部分区域，这些点均匀分布在这一块区域；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;0和1都可以精确表示，而且因为符号有+-两个符号，所以0有两种表示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最大非规格化数和最小化规格数相差一个$\epsilon$，这个差值与非规格数的之间的差值相同，二者平滑过渡。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以表示的最大规格化数是$(1-2^{-n-1})\times 2^{2^{k-1}}$;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果将二进制比特看成u16的数，那么这些数本身表示的u16的数据大小与它们表示的float的大小关系相同，都是递增的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面的代码可以将所有的半精度浮点数的所有非负数表示出来（严格得说，不包括-0.0），可以都打印出来体会下上面的结论&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;matplotlib.pyplot&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;plt&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;numpy&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;np&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;udata&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;uint16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;p1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# all of non-negative float16 number&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;p1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;udata&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;view&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;float16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;udata&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;udata&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;uint16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;udata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;参考资料&#34;&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99&#34; class=&#34;header-anchor&#34;&gt;&lt;/a&gt;参考资料
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;浮点数的二进制表示 - 阮一峰的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.wikiwand.com/en/IEEE_754&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;IEEE 754 - Wikiwand&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.h-schmidt.net/FloatConverter/IEEE754.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;IEEE-754 Floating Point Converter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.cnblogs.com/zuoxiaolong/p/computer11.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深入理解计算机系统（2.7）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://dwayneneed.github.io/.net/2010/05/06/fun-with-floating-point.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Fun with floating point - Presentation Source&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.volkerschatz.com/science/float.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;What you never wanted to know about floating point but will be forced to find out&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        
    </channel>
</rss>
