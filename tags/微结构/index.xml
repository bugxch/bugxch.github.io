<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>微结构 on 巴巴变的博客</title>
        <link>https://blog.bugxch.top/tags/%E5%BE%AE%E7%BB%93%E6%9E%84/</link>
        <description>Recent content in 微结构 on 巴巴变的博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>bugxch</copyright>
        <lastBuildDate>Sat, 01 Jun 2024 21:54:52 +0800</lastBuildDate><atom:link href="https://blog.bugxch.top/tags/%E5%BE%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>CSAPP之四——处理器体系结构</title>
        <link>https://blog.bugxch.top/p/csapp%E4%B9%8B%E5%9B%9B%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</link>
        <pubDate>Sat, 01 Jun 2024 21:54:52 +0800</pubDate>
        
        <guid>https://blog.bugxch.top/p/csapp%E4%B9%8B%E5%9B%9B%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</guid>
        <description>&lt;img src="https://image-1258996033.cos.ap-shanghai.myqcloud.com/staircase-7718335_1280.jpg?imageSlim" alt="Featured image of post CSAPP之四——处理器体系结构" /&gt;&lt;p&gt;这是CSAPP第四章，作者想通过自己定义的Y86-64的ISA指令集定义、设计、编码以及制造一个简单的单周期流水线化的处理器。作者的思路也非常清晰，包括了上述的所有步骤，在每一步描述了嵌入了处理器设计的基本原则以及需要注意的技术细节。下面是设计的ISA的指令集&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image-1258996033.cos.ap-shanghai.myqcloud.com/20240602062649.png?imageSlim&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;image.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;前置知识&#34;&gt;前置知识&lt;/h1&gt;
&lt;h3 id=&#34;堆栈操作&#34;&gt;堆栈操作&lt;/h3&gt;
&lt;p&gt;作者在4.1.6和4.3.3两次提到堆栈操作的特殊性，此处做一个基本的回顾。堆栈指令包括 &lt;code&gt;popq&lt;/code&gt; 和 &lt;code&gt;pushq&lt;/code&gt; 两条，作者设计假定栈顶的地址始终保存在寄存器 &lt;code&gt;%rsp&lt;/code&gt; 中，参考&lt;a class=&#34;link&#34; href=&#34;https://blog.bugxch.top/p/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;程序的机器级表示&lt;/a&gt;中的内容，有如下示意图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic.imgdb.cn/item/6278fd150947543129801e44.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
在理解上面过程之前，我们假设：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆栈中保存的是 &lt;strong&gt;8字节&lt;/strong&gt;的元素，而且按照小端法存储的，即低有效位对应低地址；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据在内存中的地址&lt;/strong&gt;，指的是整个数据的&lt;strong&gt;第一个字节在内存中的地址&lt;/strong&gt;，例如保存一个2字节的数据 &lt;code&gt;0x1234&lt;/code&gt; 在内存地址0x100处，那么0x100地址保存字节0x34，0x101处保存字节0x12。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结合上面的假设，很容易看出，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆栈是从高地址向低地址增长的，推入一个元素栈顶指针地址变小，弹出一个元素则变大；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%rsp&lt;/code&gt; 始终指向栈顶的最后一个元素的地址，也就是最后一个元素在内存中的&lt;strong&gt;起始地址&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于上面的两点，程序的操作就比较好理解了，初始状态 &lt;code&gt;%rsp&lt;/code&gt; 中地址是0x108，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 &lt;code&gt;%rax&lt;/code&gt; 寄存器中的数据push进去，所以堆栈元素要增加8字节，为了将新的元素放到堆栈里面，先执行 &lt;code&gt;%rsp = %rsp - 8&lt;/code&gt;，此时 &lt;code&gt;%rsp&lt;/code&gt; 指向要入栈的新元素的其实地址0x100，这时就可以根据 &lt;code&gt;%rsp&lt;/code&gt; 的其实地址连续存储8个字节的新元素了，这个操作类似于
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;subq&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rsp&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// rsp = rsp - 8
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;movq&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rbp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rsp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// %rbp的元素拷贝到%rsp存储的地址处
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;出栈就是相反的，当前的 &lt;code&gt;%rsp&lt;/code&gt; 保存的就是需要弹出元素的地址，那么可以直接将该地址开始的连续8个字节先拷贝到目的地址，然后 &lt;code&gt;%rsp = %rsp + 8&lt;/code&gt;，此时 &lt;code&gt;%rsp&lt;/code&gt; 指向堆栈的&lt;strong&gt;新的&lt;/strong&gt;最后一个元素的地址。等价于如下的操作
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;movq&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rsp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rax&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;subq&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rsp&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面的操作可以保证，&lt;strong&gt;&lt;code&gt;%rsp&lt;/code&gt; 始终指向栈顶元素的起始地址&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;条件传送-vs-条件分支&#34;&gt;条件传送 vs 条件分支&lt;/h3&gt;
&lt;h1 id=&#34;参考文献&#34;&gt;参考文献&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://book.douban.com/subject/35038473/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;汇编语言（第4版） (豆瓣)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;版权信息&#34;&gt;版权信息&lt;/h1&gt;
&lt;p&gt;本文原载于 &lt;a class=&#34;link&#34; href=&#34;http://blog.bugxch.top&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;巴巴变的博客&lt;/a&gt;，遵循 CC BY-NC-SA 4.0协议，复制请保留原文出处。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
