<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Wucais on 巴巴变的博客</title>
        <link>https://blog.bugxch.top/wucai/</link>
        <description>Recent content in Wucais on 巴巴变的博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>bugxch</copyright><atom:link href="https://blog.bugxch.top/wucai/index.xml" rel="self" type="application/rss+xml" /><item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/04/wucai-2023-04-07-h83ema7/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/04/wucai-2023-04-07-h83ema7/</guid>
        <description>&lt;h2 id=&#34;五彩插件安装和使用说明的意思解释含义_五彩用户反馈&#34;&gt;【五彩插件】安装和使用说明的意思、解释、含义_五彩用户反馈&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;refox插件默认不是自动更新的，建议设置成自动更新，以便拥有最新功能，设置地 &lt;a class=&#34;link&#34; href=&#34;https://feedback.dotalk.cn/note/dA0a1390eb.html#WCREFX-367357&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;非常不错的插件管理软件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-17-h8am7dh/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-17-h8am7dh/</guid>
        <description>&lt;h2 id=&#34;设计模式概念和七大原则-腾讯云开发者社区-腾讯云&#34;&gt;设计模式概念和七大原则-腾讯云开发者社区-腾讯云&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;尽量使用合成/聚合，而不是通过继承达到复用的目的 &lt;a class=&#34;link&#34; href=&#34;https://cloud.tencent.com/developer/article/1650116#WCREFX-879038&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-17-h8am7ef/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-17-h8am7ef/</guid>
        <description>&lt;h2 id=&#34;cmake-学习笔记生成头文件_liyuanbhu的博客-csdn博客&#34;&gt;CMake 学习笔记（生成头文件）_liyuanbhu的博客-CSDN博客&lt;/h2&gt;
&lt;p&gt;#编程&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;#编程 试试新的结果&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一般命名为 config.h。 CMake 有个 configure_file() 命令专门用来做这个事情。 &lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/liyuanbhu/article/details/131758291#WCREFX-878916&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-19-h8ahkbc/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-19-h8ahkbc/</guid>
        <description>&lt;h2 id=&#34;more-effective-c---walmartcom&#34;&gt;More Effective C++ - Walmart.com&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Proven methods for improving program efficiency, including incisive examinations of the time/space costs of C++ language features&lt;/li&gt;
&lt;li&gt;Comprehensive descriptions of advanced techniques used by C++ experts, including placement new, virtual constructors, smart pointers, reference counting, proxy classes, and double-dispatching&lt;/li&gt;
&lt;li&gt;Examples of the profound impact of exception handling on the structure and behavior of C++ classes and functions&lt;/li&gt;
&lt;li&gt;Practical treatments of new language features, including bool, mutable, explicit, namespaces, member templates, the Standard Template Library, and more. If your compilers don&amp;rsquo;t yet support these features, Meyers shows you how to get the job done without them. &lt;a class=&#34;link&#34; href=&#34;https://www.walmart.com/ip/More-Effective-C-9780201633719/501744#WCREFX-889522&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-23-h8a257a/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-23-h8a257a/</guid>
        <description>&lt;h2 id=&#34;c奇异递归模板模式---shuo-ouyang---博客园&#34;&gt;C++奇异递归模板模式 - shuo-ouyang - 博客园&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CRTP的全称是Curiously Recurring Template Pattern，中文可以翻译成奇异递归模板模式。 &lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/shuo-ouyang/p/15773193.html#WCREFX-915087&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;看起来比较靠谱的CRTP的介绍 #C++&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-23-h8a257h/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-23-h8a257h/</guid>
        <description>&lt;h2 id=&#34;c-单例模式总结与剖析---行者孙---博客园&#34;&gt;C++ 单例模式总结与剖析 - 行者孙 - 博客园&lt;/h2&gt;
&lt;p&gt;#设计模式&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;这篇文章是分析透彻比较全面的介绍C++单例模式的文章 #设计模式&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.&lt;/li&gt;
&lt;li&gt;如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。 &lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/sunchaothu/p/10389842.html#WCREFX-915086&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;非常不错的单例模式的写法 #设计模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-24-h8akh87/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-24-h8akh87/</guid>
        <description>&lt;h2 id=&#34;c右值引用移动语义完美转发上篇_右值引用主要用于移动语义和完美转发_yngz_miao的博客-csdn博客&#34;&gt;【C++】右值引用、移动语义、完美转发（上篇）_右值引用主要用于移动语义和完美转发_Yngz_Miao的博客-CSDN博客&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;对于getValue()产生的临时值，如果不是被右值引用k绑定，在表达式结束之后就销毁了。但，既然被右值引用k绑定后，getValue()产生的临时值会被续命，它的生命周期将会通过右值引用得以延续，和变量k的声明周期一样长。 &lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_38410730/article/details/105517378#WCREFX-922180&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;左值引用的变量会为自己绑定的变量续命，本来返回之后就没有了，现在和k的生命一样长&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-24-h8akhae/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-24-h8akhae/</guid>
        <description>&lt;h2 id=&#34;c11移动构造函数的功能和用法&#34;&gt;C++11移动构造函数的功能和用法&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;事实上，对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。 &lt;a class=&#34;link&#34; href=&#34;http://c.biancheng.net/view/vip_8694.html#WCREFX-922562&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;程序中间生成的临时变量，如果没有其他的使用，发生了赋值或者复制的动作时候就可以使用移动语义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-24-h8akhh5/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-24-h8akhh5/</guid>
        <description>&lt;h2 id=&#34;c移动语义及拷贝优化--阿振的博客&#34;&gt;C++移动语义及拷贝优化 | 阿振的博客&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;比较清晰的右值引用的说明&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;编译器只对右值引用才能调用转移构造函数和转移赋值函数，而所有命名对象都只能是左值引。如果已知一个命名对象不再被使用而想对它调用转移构造函数和转移赋值函数，也就是把一个左值引用当做右值引用来使用，怎么实现呢？标准库提供了函数 std::move，这个函数以非常简单的方式将左值引用转换为右值引用。 &lt;a class=&#34;link&#34; href=&#34;https://theonegis.github.io/cxx/C-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%8F%8A%E6%8B%B7%E8%B4%9D%E4%BC%98%E5%8C%96/index.html#WCREFX-922017&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;可以看到并没有拷贝构造或者移动构造的发生。虽然理论上说，f1()函数的返回值是局部变量，会有一次拷贝构造的发生，但是实际并没有。这是因为编译器帮我们做了优化，减少了不必要的拷贝。&lt;/li&gt;
&lt;li&gt;g++和clang++都提供了-fno-elide-constructors选项可以关闭拷贝优化，我们重新进行编译运行g++-8 foo.cpp -std=c++11 -fno-elide-constructors &amp;amp;&amp;amp; ./a.out &lt;a class=&#34;link&#34; href=&#34;https://theonegis.github.io/cxx/C-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%8F%8A%E6%8B%B7%E8%B4%9D%E4%BC%98%E5%8C%96/index.html#WCREFX-922055&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;通过编译选项可以优化C++中的拷贝优化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;顺便提一下，在C++11以前，我们的编程习惯是为了减少不必要的复制操作，我们可能会把需要返回的对象以对象引用（左值引用，当时还没有右值引用的说法）的形式传进函数，这样在函数之外我们也可以不用拷贝获得该对象。&lt;/li&gt;
&lt;li&gt;所以C++移动语义和拷贝优化确实是C++规范中很重要的特征，对我们写程序有很大的影响。&lt;/li&gt;
&lt;li&gt;顺便提一下STL中的容器都提供了对右值引用的重载，所以当我们自定义类中实现了移动构造函数，使用STL容器的时候就没有多大的拷贝开销了，效率会有很大的提升。 &lt;a class=&#34;link&#34; href=&#34;https://theonegis.github.io/cxx/C-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%8F%8A%E6%8B%B7%E8%B4%9D%E4%BC%98%E5%8C%96/index.html#WCREFX-922078&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;C++ 11的移动语义可以大幅提高对象的拷贝性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-24-h8akhkh/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-24-h8akhkh/</guid>
        <description>&lt;h2 id=&#34;c11右值引用一看即懂&#34;&gt;C++11右值引用（一看即懂）&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;和常量左值引用不同的是，右值引用还可以对右值进行修改。例如 &lt;a class=&#34;link&#34; href=&#34;http://c.biancheng.net/view/7829.html#WCREFX-922494&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;右值引用之后可以通过引用修改原来的数据，右值只能通过这样的方式进行修改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/10/wucai-2023-10-02-h827577/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/10/wucai-2023-10-02-h827577/</guid>
        <description>&lt;h2 id=&#34;深扒威联通nas八千字还原真实优缺点附赠新手入门优化指南-聚超值&#34;&gt;深扒威联通NAS！八千字还原真实优缺点！附赠新手入门优化指南！-聚超值&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;备利用率满足用户对文档、照片、影音等传统文件存储和应用的需求，同时大幅减少关键功能的手动部署时间，并支持用户围绕存储自行添加功能。 &lt;a class=&#34;link&#34; href=&#34;https://best.pconline.com.cn/yuanchuang/12110061.html#WCREFX-1427570&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;设备&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;满足用户对文档、照片、影音等传统文件存储 &lt;a class=&#34;link&#34; href=&#34;https://best.pconline.com.cn/yuanchuang/12110061.html#WCREFX-1427569&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-16-h88336d/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-16-h88336d/</guid>
        <description>&lt;h2 id=&#34;digital-camera-sensor-sizeshow-it-influences-your-photography&#34;&gt;Digital Camera Sensor Sizes:How it Influences Your Photography&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Sensor sizes currently have many possibilities, depending on their use, price point and desired portability. The relative size for many of these is shown below:&lt;/li&gt;
&lt;li&gt;Canon&amp;rsquo;s 1Ds/5D and Nikon D3 series are the most common full frame sensors. Canon cameras such as the Rebel/60D/7D all have a 1.6X crop factor, whereas mainstream Nikon SLR cameras have a 1.5X crop factor. The above chart excludes the 1.3X crop factor, which is used in Canon&amp;rsquo;s 1D series cameras. &lt;a class=&#34;link&#34; href=&#34;https://www.cambridgeincolour.com/tutorials/digital-camera-sensor-size.htm#WCREFX-2427557&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#博客&lt;/li&gt;
&lt;li&gt;不同画幅的大小比较&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-17-h883eb9/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-17-h883eb9/</guid>
        <description>&lt;h2 id=&#34;picgo安装插件compress---花好月圆&#34;&gt;PicGo安装插件compress - 花好月圆&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;compress用于 PicGo 的图片压缩插件,非常好用。极大的节约图床储存和服务器流量 &lt;a class=&#34;link&#34; href=&#34;https://bearcai.com/index.php/archives/44/#WCREFX-2433330&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#picgo 上传压缩图片的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-19-h87ek5k/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-19-h87ek5k/</guid>
        <description>&lt;h2 id=&#34;dataview翻译-by-寡人---obsidian中文教程---obsidian-publish&#34;&gt;Dataview翻译 by 寡人 - Obsidian中文教程 - Obsidian Publish&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可以看到，二者很像，可以清楚的看到其中的对应关系，tablename对应着source等等。 &lt;a class=&#34;link&#34; href=&#34;https://publish.obsidian.md/chinesehelp/01&amp;#43;2021%E6%96%B0%E6%95%99%E7%A8%8B/Dataview%E7%BF%BB%E8%AF%91&amp;#43;by&amp;#43;%E5%AF%A1%E4%BA%BA#WCREFX-2462524&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#ob dataview高级用法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-19-h87em96/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-19-h87em96/</guid>
        <description>&lt;h2 id=&#34;obsidian-插件篇之-dataview--verne-in-github&#34;&gt;Obsidian 插件篇之 Dataview | Verne in GitHub&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在过去的使用过程中，我并没有太多的需求要去使用这一款插件，大部分的场景我都会直接使用搜索(Ctrl+Shift+F)关键字或标签来做到。但随着现在笔记越来越多，我产生了一个需求，比如我想要查看我笔记中打了某个标签的笔记列表，我想查看某个时间段中我记录的关于某个人物的笔记，又或者我会在笔记中将我看过的影视作品记录下来，我想查看过去我看过的某个导演的作品列表，这一些都可以通过 Dataview 结合 Obsidian 来达到。 &lt;a class=&#34;link&#34; href=&#34;https://einverne.github.io/post/2021/12/obsidian-dataview-plugin.html#WCREFX-2460051&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#ob 非常不错的教程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-19-h87emfm/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-19-h87emfm/</guid>
        <description>&lt;h2 id=&#34;dataviewjs的奇技淫巧---经验分享---obsidian-中文论坛&#34;&gt;Dataviewjs的奇技淫巧 - 经验分享 - Obsidian 中文论坛&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Dataviewjs&lt;/li&gt;
&lt;li&gt;Dataviewjs 是 Dataview 插件的高级功能，与 templater 一样，它也使用 javascript 语言&lt;/li&gt;
&lt;li&gt;想要使用它也很简单，与 dataview 类似，只要在代码块前面加上 dataviewjs &lt;a class=&#34;link&#34; href=&#34;https://forum-zh.obsidian.md/t/topic/5954#WCREFX-2459959&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#ob 比较高级的用法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-19-h87emk3/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-19-h87emk3/</guid>
        <description>&lt;h2 id=&#34;解决beyond-compare相同文件出现差异问题-beyond-compare中文网站&#34;&gt;解决Beyond Compare相同文件出现差异问题-Beyond Compare中文网站&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Beyond Compare是一款高效精准的文件和文件夹比较工具，可以采用多种方式比较文件的内容差异，其主要比较方式包括：CRC比较、二进制比较、基于规则的比较等。有的用户在比较文件夹时，采用二进制比较的方式来对比文件夹内包含的子文件，但是出现这样的困惑：明明是相同的文件，比较结果却显示文件存在差异，这是为什么呢？以下内容以案例形式，给大家详细讲解Beyond Compare对比相同文件出现差异的原因和解决方案。 &lt;a class=&#34;link&#34; href=&#34;https://www.beyondcompare.cc/wenti/cha-yi-wenti.html#WCREFX-2459487&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-07-h87m77k/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-07-h87m77k/</guid>
        <description>&lt;h2 id=&#34;通信中正交的含义---知乎&#34;&gt;通信中正交的含义 - 知乎&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;p&gt;$$
m\times n
$$
&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/26193196#WCREFX-2618248&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-07-h87m7kf/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-07-h87m7kf/</guid>
        <description>&lt;h2 id=&#34;小众传感器却有看家般锐利精细画质-富士x-trans相机推荐_无反相机_什么值得买&#34;&gt;小众传感器却有看家般锐利精细画质 富士X-Trans相机推荐_无反相机_什么值得买&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://a.zdmimg.com/201808/31/5b88f67ff34544083.jpg_e1080.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt; &lt;a class=&#34;link&#34; href=&#34;https://post.smzdm.com/p/apz20n87/#WCREFX-2617816&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#博客 不同传感器的阵列&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-17-h87k3ka/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-17-h87k3ka/</guid>
        <description>&lt;h2 id=&#34;gemini---google-deepmind&#34;&gt;Gemini - Google DeepMind&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;reas &lt;a class=&#34;link&#34; href=&#34;https://deepmind.google/technologies/gemini/#WCREFX-2656975&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-17-h87km22/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-17-h87km22/</guid>
        <description>&lt;h2 id=&#34;新年新开始从为什么到写什么带你重新认识日记---少数派&#34;&gt;新年新开始：从为什么到写什么，带你重新认识日记 - 少数派&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;大脑偏好消极的想法，而且会寻找各种线索来佐证它。&lt;/li&gt;
&lt;li&gt;如果你是个低能量的人，总是在想「我是个糟糕的家伙」，大脑就会迅速寻找相关的证据来佐证你的猜测，当恐惧和回避的情绪进入潜意识，会导致你在负面的情绪中越陷越深，甚至无法自拔。&lt;/li&gt;
&lt;li&gt;将自己的想法写在纸上，你就会很轻易地看到大脑是如何蛊惑你的。事实上，当你集中地把自己的想法诉诸纸上，大脑的恐吓就会瞬间失效。&lt;/li&gt;
&lt;li&gt;因为书写需要调用理性思维，当书写动作的优先级高于情绪，大脑皮层的语言区和书写区开始接管主体，负面情绪便会得到缓冲。 &lt;a class=&#34;link&#34; href=&#34;https://sspai.com/post/86356#WCREFX-2655306&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#心理健康 难怪比较低潮时候写博客和日记非常有用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-17-h87km3h/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-17-h87km3h/</guid>
        <description>&lt;h2 id=&#34;谈谈老年抑郁症_成都市第四人民医院&#34;&gt;谈谈老年抑郁症_成都市第四人民医院&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;老年抑郁症在症状上有其特殊性，具体来说有以下九个方面：&lt;/li&gt;
&lt;li&gt;1、兴趣丧失，无愉快感；&lt;/li&gt;
&lt;li&gt;2、精力减退、精神不振、疲乏无力；&lt;/li&gt;
&lt;li&gt;3、言行减少，好独处，不愿与人交往；&lt;/li&gt;
&lt;li&gt;4、自我评价下降，自责自罪，有内疚感；&lt;/li&gt;
&lt;li&gt;5、反复出现想死的念头或有自杀倾向，据研究，患抑郁症的老人有10%以上会采取自杀行为；&lt;/li&gt;
&lt;li&gt;6、对前途悲观失望，有厌世心理；&lt;/li&gt;
&lt;li&gt;7、自觉病情严重，有疑病倾向，据调查，60%的老年抑郁症患者会出现疑病症状；&lt;/li&gt;
&lt;li&gt;8、睡眠欠佳，失眠早醒；&lt;/li&gt;
&lt;li&gt;9、食欲不振或体重明显减轻。此外，也会有记忆力明显下降、反应迟钝的症状，80%左右的老年患者会出现记忆力衰退。&lt;/li&gt;
&lt;li&gt;老年抑郁症如不进行治疗，会越来越严重。有多种类型的抗抑郁药物可治疗老年忧郁症。抗抑郁药物服药两周后才会有效果，康复后，还需要继续服用6个月至1年，以防复发。不要在医生不知情的情况下改变抗抑郁药物的用量。但所有的抗抑郁药物都会有副作用，但这些副作用也会随时间消失。&lt;/li&gt;
&lt;li&gt;患者情绪最不佳的时段通常会在早上，所以要避免在这一时段外出活动。亲友可轮流陪伴患者外出走走，如逛街、运动或参与其它休闲活动。抑郁症患者有时会被误解为懒惰、散漫，其实这只是生病时的症状。&lt;/li&gt;
&lt;li&gt;由于老年人的身体状况不如年轻时稳定，所以治疗老年抑郁症比较困难。最令医生感到头痛的是许多老年患者经常会不依照提示服药，所以家人必须督促患者依时依分量服药，否则难以完全康复。&lt;/li&gt;
&lt;li&gt;恢复老年抑郁症患者的正常活动非常重要。抑郁症患者不能只靠服药来治疗，最重要的是让他们恢复正常的活动。在这方面，家人的鼓励与督促非常重要，通常医生会和家人一起为患者安排每目的活动表，如上午打太极拳、下午打麻将、傍晚和朋友喝茶聊天等，总之一定要让他们感到很忙。&lt;/li&gt;
&lt;li&gt;老年重性抑郁症的发病率因不同的人群而相差十倍左右。在共患躯体疾病的人群中，其发病率较高。在所有人群中，抑郁症状发生率比重性抑郁症的发病率高2~4倍。虽然有如此高的发病率，但老年抑郁症常常没有被识别，也没有得到有效治疗。&lt;/li&gt;
&lt;li&gt;老年抑郁症病因学很复杂，除老年人本身易感素质外，还涉及众多年龄相关的生物-社会-心理因素。研究发现高度神经质和／或长期困境的老年人是早期干预的对象。现有研究提示纹状体额叶功能障碍可能是促发老年抑郁发作的机制。 &lt;a class=&#34;link&#34; href=&#34;https://www.cd-psychologist.com/4120/tszk/manxingjingshenkangfuke/2013/0107/17858.html#WCREFX-2655486&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-26-h8d6e78/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-26-h8d6e78/</guid>
        <description>&lt;h2 id=&#34;stephen-wolfram自述---阮一峰的网络日志&#34;&gt;Stephen Wolfram自述 - 阮一峰的网络日志&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;1991年，公司盈利良好，已经可以上市了。但是，我决定不上市。我希望它始终是我自己的公司，这样我就能做自己想做的事情&amp;mdash;-那些长期的项目，比如我的科学研究。 &lt;a class=&#34;link&#34; href=&#34;https://www.ruanyifeng.com/blog/2011/07/stephen_wolfram.html#WCREFX-2747809&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;我总是想做我自己的东西，使得我不可避免要成立自己的公司。这里面有一种交换关系，如果你愿意做更多乏味的事情，你可能赚到更多的钱；如果你不太关心钱，你可能就会得到更多的智力乐趣。 &lt;a class=&#34;link&#34; href=&#34;https://www.ruanyifeng.com/blog/2011/07/stephen_wolfram.html#WCREFX-2747813&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-27-h8dc222/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-27-h8dc222/</guid>
        <description>&lt;h2 id=&#34;处理器简史powerpc-01牢不可破的-aim-联盟---少数派&#34;&gt;处理器简史｜PowerPC 01：牢不可破的 AIM 联盟 - 少数派&lt;/h2&gt;
&lt;p&gt;#处理器架构 #星标 #架构&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;#架构 介绍RISC处理器的发展历程&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;John Cocke 打造的 IBM 801 最后在 1986 年被分离出来，作为 IBM RISC 技术个人计算机、即 RT PC 的芯片 IBM ROMP 投入市场，但并没有获得多大成功。前文说到的 David Patterson 和 Carlo H. Sequin 也没闲着，最终造出了 RISC-I 芯片，其仅含有 44420 个晶体管，相比之下，那个时代 CISC 设计的平均数量约 100000 个，虽然被精简到只有 32 条指令，但其性能却完全超过了其他任何单芯片，1983 年，他们又完成了晶体管数量更少、性能却是前者 3 倍的 RISC-II。 &lt;a class=&#34;link&#34; href=&#34;https://sspai.com/post/77570#WCREFX-2754297&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构&lt;/li&gt;
&lt;li&gt;CISC架构的优势在于使用更少的晶体管（4万个）获得更高的计算性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;见此情景，IBM 再接再厉，继续在 801 的基础上挖掘其潜能，进一步加强其超标量的属性，并为此添加了更多执行单元，包括独立的浮点与定点单元，并加入了分支预测，最后开发出了具有实验性质的猎豹芯片，并又在其基础上研发出黑豹芯片。 &lt;a class=&#34;link&#34; href=&#34;https://sspai.com/post/77570#WCREFX-2754378&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#架构&lt;/li&gt;
&lt;li&gt;什么是超标量？浮点和定点单元分开，提升了处理的并行度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-28-h8dc9b9/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-28-h8dc9b9/</guid>
        <description>&lt;h2 id=&#34;through-the-agesapple-cpu-architecture&#34;&gt;Through the Ages:Apple CPU Architecture&lt;/h2&gt;
&lt;p&gt;#处理器架构&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;了解苹果A芯片架构演进过程，有助于从另一个角度理解cpu的架构&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;When your CPU uses a simpler RISC instruction set, these steps each take a single cycle, and you can line up these operations concurrently. In each clock cycle, you can get 3 instruction running, 1 at each of the 3 stages, in parallel. This results in (on average) one machine code operation executed per clock cycle. &lt;a class=&#34;link&#34; href=&#34;https://jacobbartlett.substack.com/p/through-the-ages-apple-cpu-architecture#WCREFX-2768912&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 使用精简指令集可以将硬件流水起来，提高处理器的吞吐量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-01-h8df67c/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-01-h8df67c/</guid>
        <description>&lt;h2 id=&#34;细说cache-l1l2l3tlb---知乎&#34;&gt;细说Cache-L1/L2/L3/TLB - 知乎&lt;/h2&gt;
&lt;p&gt;#处理器架构 #星标&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;详细说明了计算机中的cache的结构&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;现在的CPU中有好几个等级的缓存。通常L1和L2缓存都是每个CPU一个的, L1缓存有分为L1i和L1d，分别用来存储指令和数据。L2缓存是不区分指令和数据的。L3缓存多个核心共用一个，通常也不区分指令和数据。 还有一种缓存叫TLB，它主要用来缓存MMU使用的页表，通常我们讲缓存（cache)的时候是不算它的。 &lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/31875174#WCREFX-2799599&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 cache的分层，下面是一些问题&lt;/li&gt;
&lt;li&gt;指令的retire具体是如何定义的？outstanding的指令retire是什么意思？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-02-h8d938d/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-02-h8d938d/</guid>
        <description>&lt;h2 id=&#34;科技爱好者周刊第-291-期ai-没有护城河---阮一峰的网络日志&#34;&gt;科技爱好者周刊（第 291 期）：AI 没有护城河 - 阮一峰的网络日志&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;电动车的重量普遍比同级别燃油车重20%，原因是电池很重。举例来说，特斯拉 Model Y 单单是电池，就重770公斤，相比之下，一辆大众甲壳虫燃油车的整体重量也只有820公斤，而后者的续航还要大于前者。&lt;/li&gt;
&lt;li&gt;电动车多出来的重量，会造成轮胎更快的磨损，导致更大的污染。 &lt;a class=&#34;link&#34; href=&#34;https://www.ruanyifeng.com/blog/2024/03/weekly-issue-291.html#WCREFX-2808698&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;正如我的同事 Chris Ford 对我说的：&amp;ldquo;软件耦合是由人类交流促成的。&amp;rdquo; 如果我可以轻松与代码作者交谈，那么我就更容易对代码有更深入的了解，因此我的代码更容易耦合到该代码。&lt;/li&gt;
&lt;li&gt;应对康威定律的第一步是不要与之抗争。我仍然记得一位技术主管，他刚刚被任命为​​一个大型新项目的架构师，该项目由分布在世界各地不同城市的六个团队组成。&amp;ldquo;我做出了第一个架构决定&amp;rdquo;，他告诉我：&amp;ldquo;就是这个系统将有六个主要的子系统。我不知道它们会是什么子系统，但肯定会有六个。&amp;rdquo;&lt;/li&gt;
&lt;li&gt;为了适应康威定律，现在有一种策略，就是一旦定下软件架构，就相应改变组织结构，让紧密耦合模块的开发者更容易沟通。 &lt;a class=&#34;link&#34; href=&#34;https://www.ruanyifeng.com/blog/2024/03/weekly-issue-291.html#WCREFX-2808752&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-02-h8d93me/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-02-h8d93me/</guid>
        <description>&lt;h2 id=&#34;發佈京華老宋体7月29日更新v1007---知乎&#34;&gt;【發佈】京華老宋体(7月29日更新v1.007) - 知乎&lt;/h2&gt;
&lt;p&gt;#搜罗 #星标&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;#搜罗 比较好的字体&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-06-h8d8b82/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-06-h8d8b82/</guid>
        <description>&lt;h2 id=&#34;what-does-outstanding-mean-in-the-context-of-architecture---computer-science-stack-exchange&#34;&gt;What does &amp;ldquo;Outstanding&amp;rdquo; mean in the context of architecture? - Computer Science Stack Exchange&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Outstanding means, it hasn&amp;rsquo;t been resolved. In the case of cache misses, that means the data request has not been serviced yet. When a cache miss happens, it has to fetch the data from the next level cache/memory, until this data arrives, you need to hold this request somewhere. You&amp;rsquo;ve got two options in this situation. Either block the entire cache, until data from the next level arrives. This is the easiest to implement, but quite bad in terms of performance. On the other hand, you could save the information about this data request somewhere, and carry on servicing others. This is is much better in terms of performance. Now, coming to this &amp;ldquo;place&amp;rdquo; where you are going to store information about the pending cache miss, this is a hardware structure. So you can only have finite number of &amp;ldquo;outstanding&amp;rdquo; misses. Number of entries in this buffer, is what is being provided as the number of outstanding cache misses. &lt;a class=&#34;link&#34; href=&#34;https://cs.stackexchange.com/questions/71954/what-does-outstanding-mean-in-the-context-of-architecture#WCREFX-2863153&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 outstanding的意义。在作者的这个问题下面，如果发生cache miss，需要到下一级的存储体系中读取数据，对于后面的读数请求就有2种处理方式：最简单粗暴所有的读请求被暂停，直到当前请求拿到数据，但是很明显性能极差。另外一种方式，可以将这个请求保存在某个硬件里面，继续处理后面的请求，存放这些cache miss的读请求的硬件就是outstanding&lt;/li&gt;
&lt;li&gt;#博客 理解cache miss的原理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-06-h8d8b8m/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-06-h8d8b8m/</guid>
        <description>&lt;h2 id=&#34;daily-note-2024-03-06&#34;&gt;Daily Note 2024-03-06&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;12&lt;/li&gt;
&lt;li&gt;Outstanding means, it hasn&amp;rsquo;t been resolved. In the case of cache misses, that means the data request has not been serviced yet. When a cache miss happens, it has to fetch the data from the next level cache/memory, until this data arrives, you need to hold this request somewhere. You&amp;rsquo;ve got two options in this situation. Either block the entire cache, until data from the next level arrives. This is the easiest to implement, but quite bad in terms of performance. On the other hand, you could save the information about this data request somewhere, and carry on servicing others. This is is much better in terms of performance. Now, coming to this &amp;ldquo;place&amp;rdquo; where you are going to store information about the pending cache miss, this is a hardware structure. So you can only have finite number of &amp;ldquo;outstanding&amp;rdquo; misses. Number of entries in this buffer, is what is being provided as the number of outstanding cache misses. &lt;a class=&#34;link&#34; href=&#34;https://marker.dotalk.cn/#/?noteidx=H8D8B8M&amp;amp;wucairefx=WCREFX-2863143&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-11-h8d2fbc/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-11-h8d2fbc/</guid>
        <description>&lt;h2 id=&#34;daily-note-2024-03-11&#34;&gt;Daily Note 2024-03-11&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;W, Q, Z)， 423 个车站， 线路 &lt;a class=&#34;link&#34; href=&#34;https://marker.dotalk.cn/#/?noteidx=H8D2FBC&amp;amp;wucairefx=WCREFX-2926880&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-12-h8da8a9/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-12-h8da8a9/</guid>
        <description>&lt;h2 id=&#34;daily-note-2024-03-12&#34;&gt;Daily Note 2024-03-12&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;， &lt;a class=&#34;link&#34; href=&#34;https://marker.dotalk.cn/#/?noteidx=H8DA8A9&amp;amp;wucairefx=WCREFX-2949356&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-19-h89c532/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-19-h89c532/</guid>
        <description>&lt;h2 id=&#34;给散点图加文本标签的两种方法-今日头条&#34;&gt;给散点图加文本标签的两种方法-今日头条&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;给散点图加文本标签的两种方法 &lt;a class=&#34;link&#34; href=&#34;https://www.toutiao.com/article/7158309473277575721/#WCREFX-3046656&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#excel技巧 使用excel画出二维散点图和标签&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-19-h89ca65/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-19-h89ca65/</guid>
        <description>&lt;h2 id=&#34;daily-note-2024-03-19&#34;&gt;Daily Note 2024-03-19&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Scaling the transformer architecture is heavily bottlenecked by the self-attention mechanism, which has quadratic time and memory complexity. Recent developments in accelerator hardware mainly focus on enhancing compute capacities and not memory and transferring data between hardware. This results in attention operation having a memory bottleneck. Flash Attention is an attention algorithm used to reduce this problem and scale transformer-based models more efficiently, enabling faster training and inference. &lt;a class=&#34;link&#34; href=&#34;https://marker.dotalk.cn/#/?noteidx=H89CA65&amp;amp;wucairefx=WCREFX-3044728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GPU 的调度单元以 warp 为单位进行调度，而不是单个线程。这意味着整个 warp 会被分配到一个流多处理器（SM）上并一起执行。在 CUDA 中，占用率是一个重要的性能指标，表示每个 SM 上激活的 warps 与 SM 可以支持的最大 warp 数量的比例。更高的占用率通常意味着更好的硬件利用率。 &lt;a class=&#34;link&#34; href=&#34;https://marker.dotalk.cn/#/?noteidx=H89CA65&amp;amp;wucairefx=WCREFX-3047819&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-19-h89ca6c/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-19-h89ca6c/</guid>
        <description>&lt;h2 id=&#34;flash-attention&#34;&gt;Flash Attention&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Scaling the transformer architecture is heavily bottlenecked by the self-attention mechanism, which has quadratic time and memory complexity. Recent developments in accelerator hardware mainly focus on enhancing compute capacities and not memory and transferring data between hardware. This results in attention operation having a memory bottleneck. Flash Attention is an attention algorithm used to reduce this problem and scale transformer-based models more efficiently, enabling faster training and inference. &lt;a class=&#34;link&#34; href=&#34;https://huggingface.co/docs/text-generation-inference/conceptual/flash_attention#WCREFX-3044735&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#transformer flash attention的概述&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-19-h89ceb7/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-19-h89ceb7/</guid>
        <description>&lt;h2 id=&#34;gpu入门--李乾坤的博客&#34;&gt;GPU入门 | 李乾坤的博客&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://qiankunli.github.io/public/upload/machine/gpu_arch.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt; &lt;a class=&#34;link&#34; href=&#34;https://qiankunli.github.io/2021/08/18/gpu.html#WCREFX-3108196&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 nv的硬件架构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CPU和GPU的主要区别在于它们的设计目标。CPU的设计初衷是执行顺序指令，一直以来，为提高顺序执行性能，CPU设计中引入了许多功能。其重点在于减少指令执行时延，使CPU能够尽可能快地执行一系列指令。这些功能包括指令流水线、乱序执行、预测执行和多级缓存等（此处仅列举部分）。而GPU则专为大规模并行和高吞吐量而设计，但这种设计导致了中等至高程度的指令时延。这一设计方向受其在视频游戏、图形处理、数值计算以及现如今的深度学习中的广泛应用所影响，所有这些应用都需要以极高的速度执行大量线性代数和数值计算，因此人们倾注了大量精力以提升这些设备的吞吐量 &lt;a class=&#34;link&#34; href=&#34;https://qiankunli.github.io/2021/08/18/gpu.html#WCREFX-3080641&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 cpu更重视缩短指令的延迟，gpu允许指令有比较长的时延，但是一定要大的吞吐量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GPU的编程方式是SIMD(Single Instruction Multiple Data)意味着所有Core的计算操作完全是在相同的时间内进行的，但是输入的数据有所不同。如果这个工作给到CPU来做，需要N的时间才可以做完，但是给到GPU只需要一个时钟周期就可以完成。 &lt;a class=&#34;link&#34; href=&#34;https://qiankunli.github.io/2021/08/18/gpu.html#WCREFX-3108187&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jeson #处理器架构 gpu的编程方式也是SIMD&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GPU 的线程切换不同于 CPU，在 CPU 上切换线程需要保存现场，将所有寄存器都存到主存中，GPU 的线程切换只是切换了寄存器组（一个 SM 中有高达 64k 个寄存器），延迟超级低，几乎没有成本。 &lt;a class=&#34;link&#34; href=&#34;https://qiankunli.github.io/2021/08/18/gpu.html#WCREFX-3108312&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 寄存器组的好处是延迟很低，可以快速存储和切换数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;张量核心与普通的 CUDA 核心其实有很大的区别，CUDA 核心在每个时钟周期都可以准确的执行一次整数或者浮点数的运算，时钟的速度和核心的数量都会影响整体性能。张量核心通过牺牲一定的精度可以在每个时钟计算执行一次 4 x 4 的矩阵运算。PS：就像ALU 只需要加法器就行了（乘法指令转换为多个加法指令），但为了提高性能，直接做了一个乘法器和加法器并存。 &lt;a class=&#34;link&#34; href=&#34;https://qiankunli.github.io/2021/08/18/gpu.html#WCREFX-3108325&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 这里的张量core类似于AIC的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一个 SM 里面有多个 subcore，每个 subcore 有一个 32 thread 的 warp scheduler 和 dispatcher, 在一个 warp 中的所有线程都会同时执行相同的指令，但是输入的数据不同，这种机制也被称为 SIMD（单指令多数据）或 SIMT（单指令多线程）模型。 &lt;a class=&#34;link&#34; href=&#34;https://qiankunli.github.io/2021/08/18/gpu.html#WCREFX-3047818&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 什么是simt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;但是因为 SRAM 比较小, 所以基本原则就是: 每次往 SRAM 移动数据的, 都可能多的用这个数据. 避免来来回回的移动数据. 这种 idea 直接促成了最近大火的 FlashAttention. FlashAttention 发现很多操作计算量不大, 但是 latency 很高, 那肯定是不符合上述的 “每次往 SRAM 移动数据的”. 怎么解决呢?Attention 基本上是由 matrix multiplication 和 softmax 构成的. 我们已经知道了 matrix multiplication 是可以分块做的, 所以就剩下 softmax 能不能分块做? softmax 其实也是可以很简单的被分块做的. 所以就有了 FlashAttention. &lt;a class=&#34;link&#34; href=&#34;https://qiankunli.github.io/2021/08/18/gpu.html#WCREFX-3109399&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#性能优化 flash attention的想法源头&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fa6c/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fa6c/</guid>
        <description>&lt;h2 id=&#34;cpu-和-gpu---异构计算的演进与发展---面向信仰编程&#34;&gt;CPU 和 GPU - 异构计算的演进与发展 - 面向信仰编程&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;计算机图形领域的圣杯是实时的全局光照，实现更好的光线追踪可以帮助我们在屏幕上渲染更加真实的图像，然而全局光照需要 GPU 进行大量的计算，而实时的全局光照更是对性能有着非常高的要求。传统的 GPU 架构并不擅长光线追踪等任务，所以 Nvidia 在 Turing 架构中首次引入了光线追踪核心（Ray-Tracing Core、RT Core）。 &lt;a class=&#34;link&#34; href=&#34;https://draveness.me/heterogeneous-computing/#fn:18https:/draveness.me/heterogeneous-computing&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson 新增光追模块，图形领域的圣杯&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89faa8/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89faa8/</guid>
        <description>&lt;h2 id=&#34;cpu-和-gpu---异构计算的演进与发展---面向信仰编程&#34;&gt;CPU 和 GPU - 异构计算的演进与发展 - 面向信仰编程&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CPU 和 GPU - 异构计算的演进与发展 &lt;a class=&#34;link&#34; href=&#34;https://draveness.me/heterogeneous-computing/https:/draveness.me/heterogeneous-computing#WCREFX-3080234&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 非常不错的介绍材料&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;越小的晶体管在开关时消耗的能量越少，既然晶体管需要一些时间充电和放电，那么消耗的能量也就越少，速度也越快，而这也解释了为什么增加 CPU 的电压可以提高它的运行速度。除此之外，更小的晶体管间隔使得信号的传输变得更快，这也能够加快 CPU 的处理速度5。 &lt;a class=&#34;link&#34; href=&#34;https://draveness.me/heterogeneous-computing/https:/draveness.me/heterogeneous-computing#WCREFX-3080248&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;L1 缓存中区分数据缓存和指令缓存以提高缓存的命中率。 &lt;a class=&#34;link&#34; href=&#34;https://draveness.me/heterogeneous-computing/https:/draveness.me/heterogeneous-computing#WCREFX-3080257&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 区分dcache和icahce的目的是为了提升缓存的命中率？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;除了上述这些组件之外，SM 中还包含特殊函数的计算单元（Special Functions Unit、SPU）以及用于存储和缓存数据的寄存器文件（Register File）、共享内存（Shared Memory）、一级缓存和通用缓存。 &lt;a class=&#34;link&#34; href=&#34;https://draveness.me/heterogeneous-computing/https:/draveness.me/heterogeneous-computing#WCREFX-3108115&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson 这些单元npu也有&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最初的 GPU 仅仅是为了更快地创建和渲染图片，它们广泛存在于个人主机上承担着图像渲染的任务，但是随着机器学习等技术的发展，GPU 中出现了更多种类的专用核心来支撑特定的场景，我们在这里介绍两种 GPU 中存在的专用核心：张量核心（Tensor Core）和光线追踪核心（Ray-Tracing Core）： &lt;a class=&#34;link&#34; href=&#34;https://draveness.me/heterogeneous-computing/https:/draveness.me/heterogeneous-computing#WCREFX-3080505&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson 为了执行新任务，增加新的计算单元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fac2/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fac2/</guid>
        <description>&lt;h2 id=&#34;cpu-architecture---what-does-a-split-cache-means-and-how-is-it-usefulif-it-is---stack-overflow&#34;&gt;cpu architecture - What does a &amp;lsquo;Split&amp;rsquo; cache means. And how is it useful(if it is)? - Stack Overflow&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;What does a &amp;lsquo;Split&amp;rsquo; cache means. And how is it useful(if it is)? &lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/55752699/what-does-a-split-cache-means-and-how-is-it-usefulif-it-is#WCREFX-3080287&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 为什么cache分为dcache和icache，而且在L2就不再区分了？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fahc/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fahc/</guid>
        <description>&lt;h2 id=&#34;nvdla-primer--nvdla-documentation&#34;&gt;NVDLA Primer — NVDLA Documentation&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Independent. When operating independently, each functional block is configured for when and what it executes, with each block working on its assigned task (akin to independent layers in a Deep Learning framework). Independent operation begins and ends with the assigned block performing memory-to-memory operations, in and out of main system memory or dedicated SRAM memory.&lt;/li&gt;
&lt;li&gt;Fused. Fused operation is similar to independent operation, however, some blocks can be assembled as a pipeline.&lt;/li&gt;
&lt;li&gt;This improves performance by bypassing the round trip through memory, instead having blocks communicate with each other through small FIFOs (i.e., the convolution core can pass data to the Single Data Point Processor, which can pass data to the Planar Data Processor, and in turn to the Cross-channel Data Processor). &lt;a class=&#34;link&#34; href=&#34;http://nvdla.org/primer.html#WCREFX-3079952&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson 从架构图来看，&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;DLA主要用于深度学习的推理，包括卷积、激活、pooling、norm以及reashape的操作&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;支持独立执行，每个单元自己访问SRAM，也支持类似UB融合的操作，数据在不同的单元流动，只在最后计算完毕之后运输到DDR&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Support for sparse weight compression saves memory bandwidth. Built-in Winograd convolution support improves compute efficiency for certain sizes of filters. Batch convolution, can save additional memory bandwidth by reusing weights when running multiple inferences in parallel. &lt;a class=&#34;link&#34; href=&#34;http://nvdla.org/primer.html#WCREFX-3079974&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson 卷积支持稀疏卷积、wino卷积以及权值共享多batch卷积&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fbaf/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fbaf/</guid>
        <description>&lt;h2 id=&#34;适用于新一代机器人开发的-jetson-orin--nvidia&#34;&gt;适用于新一代机器人开发的 Jetson Orin | NVIDIA&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;on Orin™ 模组算力 &lt;a class=&#34;link&#34; href=&#34;https://www.nvidia.cn/autonomous-machines/embedded-systems/jetson-orin/#WCREFX-3077940&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fbd7/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fbd7/</guid>
        <description>&lt;h2 id=&#34;自主机器ai-的未来--nvidia&#34;&gt;自主机器：AI 的未来 | NVIDIA&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;AI 正在变革各行各业并应对全球挑战NVIDIA Jetson™ 平台提供用于开发和部署 AI 赋能机器人、无人机、IVA 应用和自主机器的工具，助力这场变革。 &lt;a class=&#34;link&#34; href=&#34;https://www.nvidia.cn/autonomous-machines/#WCREFX-3078240&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson 应用前景&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全新 Jetson Orin™ 平台还能实现每秒高达 275 万亿次浮点运算的算力，其性能是上一代产品的 8 倍。从入门级的 Jetson Orin Nano™，到具备最高性能的 Jetson AGX Orin，Jetson Orin™ 基于同一架构提供 7 种不同的模组，无疑是机器人新时代的理想平台。 &lt;a class=&#34;link&#34; href=&#34;https://www.nvidia.cn/autonomous-machines/#WCREFX-3078258&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson 相同硬件架构，覆盖中高端&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fk9h/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fk9h/</guid>
        <description>&lt;h2 id=&#34;vpi---vision-programming-interfacearchitecture&#34;&gt;VPI - Vision Programming Interface:Architecture&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;PVA&lt;/li&gt;
&lt;li&gt;The Programmable Vision Accelerator (PVA) is a processor in NVIDIA® Jetson AGX Orin™ and NVIDIA® Jetson Orin™ NX devices that is specialized for image processing and computer vision algorithms.&lt;/li&gt;
&lt;li&gt;Use the PVA backend when you need to leave the GPU free to run other tasks that only it can perform, such as deep learning inference stages and algorithms only implemented on CUDA backend.&lt;/li&gt;
&lt;li&gt;PVA hardware is much more power-efficient than CPU and CUDA hardware. Therefore, use the PVA backend where possible if power is at a premium.&lt;/li&gt;
&lt;li&gt;Each Jetson AGX Orin or Jetson XOrin NX device comprises one PVA processor, each one contains two vector processors. Therefore, the device can execute at most two independent PVA tasks concurrently.&lt;/li&gt;
&lt;li&gt;When multiple VPI streams have the PVA backend enabled, they each choose one available PVA vector processor in round-robin succession. &lt;a class=&#34;link&#34; href=&#34;https://docs.nvidia.com/vpi/architecture.html#WCREFX-3079752&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson NV没有公开PVA的硬件资料，PVA的概述，Programmable Vision Accelerator（可编程视觉加速器）。从文档来看，&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;PVA具有更高的能效（超过cpu和cuda硬件），如果是功耗敏感性的任务，则应该尽量使用PVA完成；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;协处理器，主要用于深度学习的推理以及CUDA的算法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;每个AVG Orin和Xorin NX设备有一个PVA处理器，每个处理器中有2个vector处理器，因此一个设备可以最多独立处理2个PVA任务&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-24-h89d8hm/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-24-h89d8hm/</guid>
        <description>&lt;h2 id=&#34;理解cuda中的threadblockgrid和warp---知乎&#34;&gt;理解CUDA中的thread,block,grid和warp - 知乎&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;当一个kernel被执行时，grid中的线程块被分配到SM上，一个线程块的thread只能在一个SM上调度，SM一般可以调度多个线程块，大量的thread可能被分到不同的SM上。每个thread拥有它自己的程序计数器和状态寄存器，并且用该线程自己的数据执行指令，这就是所谓的Single Instruction Multiple Thread(SIMT)。 &lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/123170285#WCREFX-3109444&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson SIMT的基础概念&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        
    </channel>
</rss>
