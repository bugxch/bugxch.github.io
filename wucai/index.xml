<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Wucais on 巴巴变的博客</title>
        <link>https://blog.bugxch.top/wucai/</link>
        <description>Recent content in Wucais on 巴巴变的博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>bugxch</copyright><atom:link href="https://blog.bugxch.top/wucai/index.xml" rel="self" type="application/rss+xml" /><item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/04/wucai-2023-04-07-h83ema7/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/04/wucai-2023-04-07-h83ema7/</guid>
        <description>&lt;h2 id=&#34;五彩插件安装和使用说明的意思解释含义_五彩用户反馈&#34;&gt;【五彩插件】安装和使用说明的意思、解释、含义_五彩用户反馈&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;refox插件默认不是自动更新的，建议设置成自动更新，以便拥有最新功能，设置地 &lt;a class=&#34;link&#34; href=&#34;https://feedback.dotalk.cn/note/dA0a1390eb.html#WCREFX-367357&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;非常不错的插件管理软件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-17-h8am7dh/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-17-h8am7dh/</guid>
        <description>&lt;h2 id=&#34;设计模式概念和七大原则-腾讯云开发者社区-腾讯云&#34;&gt;设计模式概念和七大原则-腾讯云开发者社区-腾讯云&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;尽量使用合成/聚合，而不是通过继承达到复用的目的 &lt;a class=&#34;link&#34; href=&#34;https://cloud.tencent.com/developer/article/1650116#WCREFX-879038&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-17-h8am7ef/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-17-h8am7ef/</guid>
        <description>&lt;h2 id=&#34;cmake-学习笔记生成头文件_liyuanbhu的博客-csdn博客&#34;&gt;CMake 学习笔记（生成头文件）_liyuanbhu的博客-CSDN博客&lt;/h2&gt;
&lt;p&gt;#编程&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;#编程 试试新的结果&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一般命名为 config.h。 CMake 有个 configure_file() 命令专门用来做这个事情。 &lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/liyuanbhu/article/details/131758291#WCREFX-878916&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-19-h8ahkbc/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-19-h8ahkbc/</guid>
        <description>&lt;h2 id=&#34;more-effective-c---walmartcom&#34;&gt;More Effective C++ - Walmart.com&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Proven methods for improving program efficiency, including incisive examinations of the time/space costs of C++ language features&lt;/li&gt;
&lt;li&gt;Comprehensive descriptions of advanced techniques used by C++ experts, including placement new, virtual constructors, smart pointers, reference counting, proxy classes, and double-dispatching&lt;/li&gt;
&lt;li&gt;Examples of the profound impact of exception handling on the structure and behavior of C++ classes and functions&lt;/li&gt;
&lt;li&gt;Practical treatments of new language features, including bool, mutable, explicit, namespaces, member templates, the Standard Template Library, and more. If your compilers don&amp;rsquo;t yet support these features, Meyers shows you how to get the job done without them. &lt;a class=&#34;link&#34; href=&#34;https://www.walmart.com/ip/More-Effective-C-9780201633719/501744#WCREFX-889522&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-23-h8a257a/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-23-h8a257a/</guid>
        <description>&lt;h2 id=&#34;c奇异递归模板模式---shuo-ouyang---博客园&#34;&gt;C++奇异递归模板模式 - shuo-ouyang - 博客园&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CRTP的全称是Curiously Recurring Template Pattern，中文可以翻译成奇异递归模板模式。 &lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/shuo-ouyang/p/15773193.html#WCREFX-915087&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;看起来比较靠谱的CRTP的介绍 #C++&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-23-h8a257h/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-23-h8a257h/</guid>
        <description>&lt;h2 id=&#34;c-单例模式总结与剖析---行者孙---博客园&#34;&gt;C++ 单例模式总结与剖析 - 行者孙 - 博客园&lt;/h2&gt;
&lt;p&gt;#设计模式&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;这篇文章是分析透彻比较全面的介绍C++单例模式的文章 #设计模式&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.&lt;/li&gt;
&lt;li&gt;如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。 &lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/sunchaothu/p/10389842.html#WCREFX-915086&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;非常不错的单例模式的写法 #设计模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-24-h8akh87/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-24-h8akh87/</guid>
        <description>&lt;h2 id=&#34;c右值引用移动语义完美转发上篇_右值引用主要用于移动语义和完美转发_yngz_miao的博客-csdn博客&#34;&gt;【C++】右值引用、移动语义、完美转发（上篇）_右值引用主要用于移动语义和完美转发_Yngz_Miao的博客-CSDN博客&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;对于getValue()产生的临时值，如果不是被右值引用k绑定，在表达式结束之后就销毁了。但，既然被右值引用k绑定后，getValue()产生的临时值会被续命，它的生命周期将会通过右值引用得以延续，和变量k的声明周期一样长。 &lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_38410730/article/details/105517378#WCREFX-922180&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;左值引用的变量会为自己绑定的变量续命，本来返回之后就没有了，现在和k的生命一样长&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-24-h8akhae/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-24-h8akhae/</guid>
        <description>&lt;h2 id=&#34;c11移动构造函数的功能和用法&#34;&gt;C++11移动构造函数的功能和用法&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;事实上，对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。 &lt;a class=&#34;link&#34; href=&#34;http://c.biancheng.net/view/vip_8694.html#WCREFX-922562&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;程序中间生成的临时变量，如果没有其他的使用，发生了赋值或者复制的动作时候就可以使用移动语义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-24-h8akhh5/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-24-h8akhh5/</guid>
        <description>&lt;h2 id=&#34;c移动语义及拷贝优化--阿振的博客&#34;&gt;C++移动语义及拷贝优化 | 阿振的博客&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;比较清晰的右值引用的说明&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;编译器只对右值引用才能调用转移构造函数和转移赋值函数，而所有命名对象都只能是左值引。如果已知一个命名对象不再被使用而想对它调用转移构造函数和转移赋值函数，也就是把一个左值引用当做右值引用来使用，怎么实现呢？标准库提供了函数 std::move，这个函数以非常简单的方式将左值引用转换为右值引用。 &lt;a class=&#34;link&#34; href=&#34;https://theonegis.github.io/cxx/C-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%8F%8A%E6%8B%B7%E8%B4%9D%E4%BC%98%E5%8C%96/index.html#WCREFX-922017&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;可以看到并没有拷贝构造或者移动构造的发生。虽然理论上说，f1()函数的返回值是局部变量，会有一次拷贝构造的发生，但是实际并没有。这是因为编译器帮我们做了优化，减少了不必要的拷贝。&lt;/li&gt;
&lt;li&gt;g++和clang++都提供了-fno-elide-constructors选项可以关闭拷贝优化，我们重新进行编译运行g++-8 foo.cpp -std=c++11 -fno-elide-constructors &amp;amp;&amp;amp; ./a.out &lt;a class=&#34;link&#34; href=&#34;https://theonegis.github.io/cxx/C-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%8F%8A%E6%8B%B7%E8%B4%9D%E4%BC%98%E5%8C%96/index.html#WCREFX-922055&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;通过编译选项可以优化C++中的拷贝优化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;顺便提一下，在C++11以前，我们的编程习惯是为了减少不必要的复制操作，我们可能会把需要返回的对象以对象引用（左值引用，当时还没有右值引用的说法）的形式传进函数，这样在函数之外我们也可以不用拷贝获得该对象。&lt;/li&gt;
&lt;li&gt;所以C++移动语义和拷贝优化确实是C++规范中很重要的特征，对我们写程序有很大的影响。&lt;/li&gt;
&lt;li&gt;顺便提一下STL中的容器都提供了对右值引用的重载，所以当我们自定义类中实现了移动构造函数，使用STL容器的时候就没有多大的拷贝开销了，效率会有很大的提升。 &lt;a class=&#34;link&#34; href=&#34;https://theonegis.github.io/cxx/C-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%8F%8A%E6%8B%B7%E8%B4%9D%E4%BC%98%E5%8C%96/index.html#WCREFX-922078&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;C++ 11的移动语义可以大幅提高对象的拷贝性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-24-h8akhkh/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/07/wucai-2023-07-24-h8akhkh/</guid>
        <description>&lt;h2 id=&#34;c11右值引用一看即懂&#34;&gt;C++11右值引用（一看即懂）&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;和常量左值引用不同的是，右值引用还可以对右值进行修改。例如 &lt;a class=&#34;link&#34; href=&#34;http://c.biancheng.net/view/7829.html#WCREFX-922494&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;右值引用之后可以通过引用修改原来的数据，右值只能通过这样的方式进行修改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2023/10/wucai-2023-10-02-h827577/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2023/10/wucai-2023-10-02-h827577/</guid>
        <description>&lt;h2 id=&#34;深扒威联通nas八千字还原真实优缺点附赠新手入门优化指南-聚超值&#34;&gt;深扒威联通NAS！八千字还原真实优缺点！附赠新手入门优化指南！-聚超值&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;备利用率满足用户对文档、照片、影音等传统文件存储和应用的需求，同时大幅减少关键功能的手动部署时间，并支持用户围绕存储自行添加功能。 &lt;a class=&#34;link&#34; href=&#34;https://best.pconline.com.cn/yuanchuang/12110061.html#WCREFX-1427570&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;设备&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;满足用户对文档、照片、影音等传统文件存储 &lt;a class=&#34;link&#34; href=&#34;https://best.pconline.com.cn/yuanchuang/12110061.html#WCREFX-1427569&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-16-h88336d/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-16-h88336d/</guid>
        <description>&lt;h2 id=&#34;digital-camera-sensor-sizeshow-it-influences-your-photography&#34;&gt;Digital Camera Sensor Sizes:How it Influences Your Photography&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Sensor sizes currently have many possibilities, depending on their use, price point and desired portability. The relative size for many of these is shown below:&lt;/li&gt;
&lt;li&gt;Canon&amp;rsquo;s 1Ds/5D and Nikon D3 series are the most common full frame sensors. Canon cameras such as the Rebel/60D/7D all have a 1.6X crop factor, whereas mainstream Nikon SLR cameras have a 1.5X crop factor. The above chart excludes the 1.3X crop factor, which is used in Canon&amp;rsquo;s 1D series cameras. &lt;a class=&#34;link&#34; href=&#34;https://www.cambridgeincolour.com/tutorials/digital-camera-sensor-size.htm#WCREFX-2427557&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#博客&lt;/li&gt;
&lt;li&gt;不同画幅的大小比较&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-17-h883eb9/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-17-h883eb9/</guid>
        <description>&lt;h2 id=&#34;picgo安装插件compress---花好月圆&#34;&gt;PicGo安装插件compress - 花好月圆&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;compress用于 PicGo 的图片压缩插件,非常好用。极大的节约图床储存和服务器流量 &lt;a class=&#34;link&#34; href=&#34;https://bearcai.com/index.php/archives/44/#WCREFX-2433330&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#picgo 上传压缩图片的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-19-h87ek5k/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-19-h87ek5k/</guid>
        <description>&lt;h2 id=&#34;dataview翻译-by-寡人---obsidian中文教程---obsidian-publish&#34;&gt;Dataview翻译 by 寡人 - Obsidian中文教程 - Obsidian Publish&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可以看到，二者很像，可以清楚的看到其中的对应关系，tablename对应着source等等。 &lt;a class=&#34;link&#34; href=&#34;https://publish.obsidian.md/chinesehelp/01&amp;#43;2021%E6%96%B0%E6%95%99%E7%A8%8B/Dataview%E7%BF%BB%E8%AF%91&amp;#43;by&amp;#43;%E5%AF%A1%E4%BA%BA#WCREFX-2462524&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#ob dataview高级用法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-19-h87em96/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-19-h87em96/</guid>
        <description>&lt;h2 id=&#34;obsidian-插件篇之-dataview--verne-in-github&#34;&gt;Obsidian 插件篇之 Dataview | Verne in GitHub&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在过去的使用过程中，我并没有太多的需求要去使用这一款插件，大部分的场景我都会直接使用搜索(Ctrl+Shift+F)关键字或标签来做到。但随着现在笔记越来越多，我产生了一个需求，比如我想要查看我笔记中打了某个标签的笔记列表，我想查看某个时间段中我记录的关于某个人物的笔记，又或者我会在笔记中将我看过的影视作品记录下来，我想查看过去我看过的某个导演的作品列表，这一些都可以通过 Dataview 结合 Obsidian 来达到。 &lt;a class=&#34;link&#34; href=&#34;https://einverne.github.io/post/2021/12/obsidian-dataview-plugin.html#WCREFX-2460051&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#ob 非常不错的教程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-19-h87emfm/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-19-h87emfm/</guid>
        <description>&lt;h2 id=&#34;dataviewjs的奇技淫巧---经验分享---obsidian-中文论坛&#34;&gt;Dataviewjs的奇技淫巧 - 经验分享 - Obsidian 中文论坛&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Dataviewjs&lt;/li&gt;
&lt;li&gt;Dataviewjs 是 Dataview 插件的高级功能，与 templater 一样，它也使用 javascript 语言&lt;/li&gt;
&lt;li&gt;想要使用它也很简单，与 dataview 类似，只要在代码块前面加上 dataviewjs &lt;a class=&#34;link&#34; href=&#34;https://forum-zh.obsidian.md/t/topic/5954#WCREFX-2459959&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#ob 比较高级的用法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-19-h87emk3/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/01/wucai-2024-01-19-h87emk3/</guid>
        <description>&lt;h2 id=&#34;解决beyond-compare相同文件出现差异问题-beyond-compare中文网站&#34;&gt;解决Beyond Compare相同文件出现差异问题-Beyond Compare中文网站&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Beyond Compare是一款高效精准的文件和文件夹比较工具，可以采用多种方式比较文件的内容差异，其主要比较方式包括：CRC比较、二进制比较、基于规则的比较等。有的用户在比较文件夹时，采用二进制比较的方式来对比文件夹内包含的子文件，但是出现这样的困惑：明明是相同的文件，比较结果却显示文件存在差异，这是为什么呢？以下内容以案例形式，给大家详细讲解Beyond Compare对比相同文件出现差异的原因和解决方案。 &lt;a class=&#34;link&#34; href=&#34;https://www.beyondcompare.cc/wenti/cha-yi-wenti.html#WCREFX-2459487&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-07-h87m77k/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-07-h87m77k/</guid>
        <description>&lt;h2 id=&#34;通信中正交的含义---知乎&#34;&gt;通信中正交的含义 - 知乎&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;p&gt;$$
m\times n
$$
&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/26193196#WCREFX-2618248&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-07-h87m7kf/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-07-h87m7kf/</guid>
        <description>&lt;h2 id=&#34;小众传感器却有看家般锐利精细画质-富士x-trans相机推荐_无反相机_什么值得买&#34;&gt;小众传感器却有看家般锐利精细画质 富士X-Trans相机推荐_无反相机_什么值得买&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://a.zdmimg.com/201808/31/5b88f67ff34544083.jpg_e1080.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt; &lt;a class=&#34;link&#34; href=&#34;https://post.smzdm.com/p/apz20n87/#WCREFX-2617816&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#博客 不同传感器的阵列&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-17-h87k3ka/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-17-h87k3ka/</guid>
        <description>&lt;h2 id=&#34;gemini---google-deepmind&#34;&gt;Gemini - Google DeepMind&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;reas &lt;a class=&#34;link&#34; href=&#34;https://deepmind.google/technologies/gemini/#WCREFX-2656975&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-17-h87km22/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-17-h87km22/</guid>
        <description>&lt;h2 id=&#34;新年新开始从为什么到写什么带你重新认识日记---少数派&#34;&gt;新年新开始：从为什么到写什么，带你重新认识日记 - 少数派&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;大脑偏好消极的想法，而且会寻找各种线索来佐证它。&lt;/li&gt;
&lt;li&gt;如果你是个低能量的人，总是在想「我是个糟糕的家伙」，大脑就会迅速寻找相关的证据来佐证你的猜测，当恐惧和回避的情绪进入潜意识，会导致你在负面的情绪中越陷越深，甚至无法自拔。&lt;/li&gt;
&lt;li&gt;将自己的想法写在纸上，你就会很轻易地看到大脑是如何蛊惑你的。事实上，当你集中地把自己的想法诉诸纸上，大脑的恐吓就会瞬间失效。&lt;/li&gt;
&lt;li&gt;因为书写需要调用理性思维，当书写动作的优先级高于情绪，大脑皮层的语言区和书写区开始接管主体，负面情绪便会得到缓冲。 &lt;a class=&#34;link&#34; href=&#34;https://sspai.com/post/86356#WCREFX-2655306&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#心理健康 难怪比较低潮时候写博客和日记非常有用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-17-h87km3h/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-17-h87km3h/</guid>
        <description>&lt;h2 id=&#34;谈谈老年抑郁症_成都市第四人民医院&#34;&gt;谈谈老年抑郁症_成都市第四人民医院&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;老年抑郁症在症状上有其特殊性，具体来说有以下九个方面：&lt;/li&gt;
&lt;li&gt;1、兴趣丧失，无愉快感；&lt;/li&gt;
&lt;li&gt;2、精力减退、精神不振、疲乏无力；&lt;/li&gt;
&lt;li&gt;3、言行减少，好独处，不愿与人交往；&lt;/li&gt;
&lt;li&gt;4、自我评价下降，自责自罪，有内疚感；&lt;/li&gt;
&lt;li&gt;5、反复出现想死的念头或有自杀倾向，据研究，患抑郁症的老人有10%以上会采取自杀行为；&lt;/li&gt;
&lt;li&gt;6、对前途悲观失望，有厌世心理；&lt;/li&gt;
&lt;li&gt;7、自觉病情严重，有疑病倾向，据调查，60%的老年抑郁症患者会出现疑病症状；&lt;/li&gt;
&lt;li&gt;8、睡眠欠佳，失眠早醒；&lt;/li&gt;
&lt;li&gt;9、食欲不振或体重明显减轻。此外，也会有记忆力明显下降、反应迟钝的症状，80%左右的老年患者会出现记忆力衰退。&lt;/li&gt;
&lt;li&gt;老年抑郁症如不进行治疗，会越来越严重。有多种类型的抗抑郁药物可治疗老年忧郁症。抗抑郁药物服药两周后才会有效果，康复后，还需要继续服用6个月至1年，以防复发。不要在医生不知情的情况下改变抗抑郁药物的用量。但所有的抗抑郁药物都会有副作用，但这些副作用也会随时间消失。&lt;/li&gt;
&lt;li&gt;患者情绪最不佳的时段通常会在早上，所以要避免在这一时段外出活动。亲友可轮流陪伴患者外出走走，如逛街、运动或参与其它休闲活动。抑郁症患者有时会被误解为懒惰、散漫，其实这只是生病时的症状。&lt;/li&gt;
&lt;li&gt;由于老年人的身体状况不如年轻时稳定，所以治疗老年抑郁症比较困难。最令医生感到头痛的是许多老年患者经常会不依照提示服药，所以家人必须督促患者依时依分量服药，否则难以完全康复。&lt;/li&gt;
&lt;li&gt;恢复老年抑郁症患者的正常活动非常重要。抑郁症患者不能只靠服药来治疗，最重要的是让他们恢复正常的活动。在这方面，家人的鼓励与督促非常重要，通常医生会和家人一起为患者安排每目的活动表，如上午打太极拳、下午打麻将、傍晚和朋友喝茶聊天等，总之一定要让他们感到很忙。&lt;/li&gt;
&lt;li&gt;老年重性抑郁症的发病率因不同的人群而相差十倍左右。在共患躯体疾病的人群中，其发病率较高。在所有人群中，抑郁症状发生率比重性抑郁症的发病率高2~4倍。虽然有如此高的发病率，但老年抑郁症常常没有被识别，也没有得到有效治疗。&lt;/li&gt;
&lt;li&gt;老年抑郁症病因学很复杂，除老年人本身易感素质外，还涉及众多年龄相关的生物-社会-心理因素。研究发现高度神经质和／或长期困境的老年人是早期干预的对象。现有研究提示纹状体额叶功能障碍可能是促发老年抑郁发作的机制。 &lt;a class=&#34;link&#34; href=&#34;https://www.cd-psychologist.com/4120/tszk/manxingjingshenkangfuke/2013/0107/17858.html#WCREFX-2655486&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-26-h8d6e78/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-26-h8d6e78/</guid>
        <description>&lt;h2 id=&#34;stephen-wolfram自述---阮一峰的网络日志&#34;&gt;Stephen Wolfram自述 - 阮一峰的网络日志&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;1991年，公司盈利良好，已经可以上市了。但是，我决定不上市。我希望它始终是我自己的公司，这样我就能做自己想做的事情&amp;mdash;-那些长期的项目，比如我的科学研究。 &lt;a class=&#34;link&#34; href=&#34;https://www.ruanyifeng.com/blog/2011/07/stephen_wolfram.html#WCREFX-2747809&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;我总是想做我自己的东西，使得我不可避免要成立自己的公司。这里面有一种交换关系，如果你愿意做更多乏味的事情，你可能赚到更多的钱；如果你不太关心钱，你可能就会得到更多的智力乐趣。 &lt;a class=&#34;link&#34; href=&#34;https://www.ruanyifeng.com/blog/2011/07/stephen_wolfram.html#WCREFX-2747813&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-27-h8dc222/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-27-h8dc222/</guid>
        <description>&lt;h2 id=&#34;处理器简史powerpc-01牢不可破的-aim-联盟---少数派&#34;&gt;处理器简史｜PowerPC 01：牢不可破的 AIM 联盟 - 少数派&lt;/h2&gt;
&lt;p&gt;#处理器架构 #星标 #架构&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;#架构 介绍RISC处理器的发展历程&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;John Cocke 打造的 IBM 801 最后在 1986 年被分离出来，作为 IBM RISC 技术个人计算机、即 RT PC 的芯片 IBM ROMP 投入市场，但并没有获得多大成功。前文说到的 David Patterson 和 Carlo H. Sequin 也没闲着，最终造出了 RISC-I 芯片，其仅含有 44420 个晶体管，相比之下，那个时代 CISC 设计的平均数量约 100000 个，虽然被精简到只有 32 条指令，但其性能却完全超过了其他任何单芯片，1983 年，他们又完成了晶体管数量更少、性能却是前者 3 倍的 RISC-II。 &lt;a class=&#34;link&#34; href=&#34;https://sspai.com/post/77570#WCREFX-2754297&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构&lt;/li&gt;
&lt;li&gt;CISC架构的优势在于使用更少的晶体管（4万个）获得更高的计算性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;见此情景，IBM 再接再厉，继续在 801 的基础上挖掘其潜能，进一步加强其超标量的属性，并为此添加了更多执行单元，包括独立的浮点与定点单元，并加入了分支预测，最后开发出了具有实验性质的猎豹芯片，并又在其基础上研发出黑豹芯片。 &lt;a class=&#34;link&#34; href=&#34;https://sspai.com/post/77570#WCREFX-2754378&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#架构&lt;/li&gt;
&lt;li&gt;什么是超标量？浮点和定点单元分开，提升了处理的并行度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-28-h8dc9b9/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/02/wucai-2024-02-28-h8dc9b9/</guid>
        <description>&lt;h2 id=&#34;through-the-agesapple-cpu-architecture&#34;&gt;Through the Ages:Apple CPU Architecture&lt;/h2&gt;
&lt;p&gt;#处理器架构&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;了解苹果A芯片架构演进过程，有助于从另一个角度理解cpu的架构&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;When your CPU uses a simpler RISC instruction set, these steps each take a single cycle, and you can line up these operations concurrently. In each clock cycle, you can get 3 instruction running, 1 at each of the 3 stages, in parallel. This results in (on average) one machine code operation executed per clock cycle. &lt;a class=&#34;link&#34; href=&#34;https://jacobbartlett.substack.com/p/through-the-ages-apple-cpu-architecture#WCREFX-2768912&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 使用精简指令集可以将硬件流水起来，提高处理器的吞吐量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-01-h8df67c/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-01-h8df67c/</guid>
        <description>&lt;h2 id=&#34;细说cache-l1l2l3tlb---知乎&#34;&gt;细说Cache-L1/L2/L3/TLB - 知乎&lt;/h2&gt;
&lt;p&gt;#处理器架构 #星标&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;详细说明了计算机中的cache的结构&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;现在的CPU中有好几个等级的缓存。通常L1和L2缓存都是每个CPU一个的, L1缓存有分为L1i和L1d，分别用来存储指令和数据。L2缓存是不区分指令和数据的。L3缓存多个核心共用一个，通常也不区分指令和数据。 还有一种缓存叫TLB，它主要用来缓存MMU使用的页表，通常我们讲缓存（cache)的时候是不算它的。 &lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/31875174#WCREFX-2799599&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 cache的分层，下面是一些问题&lt;/li&gt;
&lt;li&gt;指令的retire具体是如何定义的？outstanding的指令retire是什么意思？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-02-h8d938d/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-02-h8d938d/</guid>
        <description>&lt;h2 id=&#34;科技爱好者周刊第-291-期ai-没有护城河---阮一峰的网络日志&#34;&gt;科技爱好者周刊（第 291 期）：AI 没有护城河 - 阮一峰的网络日志&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;电动车的重量普遍比同级别燃油车重20%，原因是电池很重。举例来说，特斯拉 Model Y 单单是电池，就重770公斤，相比之下，一辆大众甲壳虫燃油车的整体重量也只有820公斤，而后者的续航还要大于前者。&lt;/li&gt;
&lt;li&gt;电动车多出来的重量，会造成轮胎更快的磨损，导致更大的污染。 &lt;a class=&#34;link&#34; href=&#34;https://www.ruanyifeng.com/blog/2024/03/weekly-issue-291.html#WCREFX-2808698&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;正如我的同事 Chris Ford 对我说的：&amp;ldquo;软件耦合是由人类交流促成的。&amp;rdquo; 如果我可以轻松与代码作者交谈，那么我就更容易对代码有更深入的了解，因此我的代码更容易耦合到该代码。&lt;/li&gt;
&lt;li&gt;应对康威定律的第一步是不要与之抗争。我仍然记得一位技术主管，他刚刚被任命为​​一个大型新项目的架构师，该项目由分布在世界各地不同城市的六个团队组成。&amp;ldquo;我做出了第一个架构决定&amp;rdquo;，他告诉我：&amp;ldquo;就是这个系统将有六个主要的子系统。我不知道它们会是什么子系统，但肯定会有六个。&amp;rdquo;&lt;/li&gt;
&lt;li&gt;为了适应康威定律，现在有一种策略，就是一旦定下软件架构，就相应改变组织结构，让紧密耦合模块的开发者更容易沟通。 &lt;a class=&#34;link&#34; href=&#34;https://www.ruanyifeng.com/blog/2024/03/weekly-issue-291.html#WCREFX-2808752&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-02-h8d93me/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-02-h8d93me/</guid>
        <description>&lt;h2 id=&#34;發佈京華老宋体7月29日更新v1007---知乎&#34;&gt;【發佈】京華老宋体(7月29日更新v1.007) - 知乎&lt;/h2&gt;
&lt;p&gt;#搜罗 #星标&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;#搜罗 比较好的字体&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-06-h8d8b82/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-06-h8d8b82/</guid>
        <description>&lt;h2 id=&#34;what-does-outstanding-mean-in-the-context-of-architecture---computer-science-stack-exchange&#34;&gt;What does &amp;ldquo;Outstanding&amp;rdquo; mean in the context of architecture? - Computer Science Stack Exchange&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Outstanding means, it hasn&amp;rsquo;t been resolved. In the case of cache misses, that means the data request has not been serviced yet. When a cache miss happens, it has to fetch the data from the next level cache/memory, until this data arrives, you need to hold this request somewhere. You&amp;rsquo;ve got two options in this situation. Either block the entire cache, until data from the next level arrives. This is the easiest to implement, but quite bad in terms of performance. On the other hand, you could save the information about this data request somewhere, and carry on servicing others. This is is much better in terms of performance. Now, coming to this &amp;ldquo;place&amp;rdquo; where you are going to store information about the pending cache miss, this is a hardware structure. So you can only have finite number of &amp;ldquo;outstanding&amp;rdquo; misses. Number of entries in this buffer, is what is being provided as the number of outstanding cache misses. &lt;a class=&#34;link&#34; href=&#34;https://cs.stackexchange.com/questions/71954/what-does-outstanding-mean-in-the-context-of-architecture#WCREFX-2863153&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 outstanding的意义。在作者的这个问题下面，如果发生cache miss，需要到下一级的存储体系中读取数据，对于后面的读数请求就有2种处理方式：最简单粗暴所有的读请求被暂停，直到当前请求拿到数据，但是很明显性能极差。另外一种方式，可以将这个请求保存在某个硬件里面，继续处理后面的请求，存放这些cache miss的读请求的硬件就是outstanding&lt;/li&gt;
&lt;li&gt;#博客 理解cache miss的原理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-06-h8d8b8m/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-06-h8d8b8m/</guid>
        <description>&lt;h2 id=&#34;daily-note-2024-03-06&#34;&gt;Daily Note 2024-03-06&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;12&lt;/li&gt;
&lt;li&gt;Outstanding means, it hasn&amp;rsquo;t been resolved. In the case of cache misses, that means the data request has not been serviced yet. When a cache miss happens, it has to fetch the data from the next level cache/memory, until this data arrives, you need to hold this request somewhere. You&amp;rsquo;ve got two options in this situation. Either block the entire cache, until data from the next level arrives. This is the easiest to implement, but quite bad in terms of performance. On the other hand, you could save the information about this data request somewhere, and carry on servicing others. This is is much better in terms of performance. Now, coming to this &amp;ldquo;place&amp;rdquo; where you are going to store information about the pending cache miss, this is a hardware structure. So you can only have finite number of &amp;ldquo;outstanding&amp;rdquo; misses. Number of entries in this buffer, is what is being provided as the number of outstanding cache misses. &lt;a class=&#34;link&#34; href=&#34;https://marker.dotalk.cn/#/?noteidx=H8D8B8M&amp;amp;wucairefx=WCREFX-2863143&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-11-h8d2fbc/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-11-h8d2fbc/</guid>
        <description>&lt;h2 id=&#34;daily-note-2024-03-11&#34;&gt;Daily Note 2024-03-11&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;W, Q, Z)， 423 个车站， 线路 &lt;a class=&#34;link&#34; href=&#34;https://marker.dotalk.cn/#/?noteidx=H8D2FBC&amp;amp;wucairefx=WCREFX-2926880&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-12-h8da8a9/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-12-h8da8a9/</guid>
        <description>&lt;h2 id=&#34;daily-note-2024-03-12&#34;&gt;Daily Note 2024-03-12&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;， &lt;a class=&#34;link&#34; href=&#34;https://marker.dotalk.cn/#/?noteidx=H8DA8A9&amp;amp;wucairefx=WCREFX-2949356&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-19-h89c532/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-19-h89c532/</guid>
        <description>&lt;h2 id=&#34;给散点图加文本标签的两种方法-今日头条&#34;&gt;给散点图加文本标签的两种方法-今日头条&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;给散点图加文本标签的两种方法 &lt;a class=&#34;link&#34; href=&#34;https://www.toutiao.com/article/7158309473277575721/#WCREFX-3046656&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#excel技巧 使用excel画出二维散点图和标签&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-19-h89ca65/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-19-h89ca65/</guid>
        <description>&lt;h2 id=&#34;daily-note-2024-03-19&#34;&gt;Daily Note 2024-03-19&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Scaling the transformer architecture is heavily bottlenecked by the self-attention mechanism, which has quadratic time and memory complexity. Recent developments in accelerator hardware mainly focus on enhancing compute capacities and not memory and transferring data between hardware. This results in attention operation having a memory bottleneck. Flash Attention is an attention algorithm used to reduce this problem and scale transformer-based models more efficiently, enabling faster training and inference. &lt;a class=&#34;link&#34; href=&#34;https://marker.dotalk.cn/#/?noteidx=H89CA65&amp;amp;wucairefx=WCREFX-3044728&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GPU 的调度单元以 warp 为单位进行调度，而不是单个线程。这意味着整个 warp 会被分配到一个流多处理器（SM）上并一起执行。在 CUDA 中，占用率是一个重要的性能指标，表示每个 SM 上激活的 warps 与 SM 可以支持的最大 warp 数量的比例。更高的占用率通常意味着更好的硬件利用率。 &lt;a class=&#34;link&#34; href=&#34;https://marker.dotalk.cn/#/?noteidx=H89CA65&amp;amp;wucairefx=WCREFX-3047819&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-19-h89ca6c/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-19-h89ca6c/</guid>
        <description>&lt;h2 id=&#34;flash-attention&#34;&gt;Flash Attention&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Scaling the transformer architecture is heavily bottlenecked by the self-attention mechanism, which has quadratic time and memory complexity. Recent developments in accelerator hardware mainly focus on enhancing compute capacities and not memory and transferring data between hardware. This results in attention operation having a memory bottleneck. Flash Attention is an attention algorithm used to reduce this problem and scale transformer-based models more efficiently, enabling faster training and inference. &lt;a class=&#34;link&#34; href=&#34;https://huggingface.co/docs/text-generation-inference/conceptual/flash_attention#WCREFX-3044735&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#transformer flash attention的概述&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-19-h89ceb7/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-19-h89ceb7/</guid>
        <description>&lt;h2 id=&#34;gpu入门--李乾坤的博客&#34;&gt;GPU入门 | 李乾坤的博客&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://qiankunli.github.io/public/upload/machine/gpu_arch.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt; &lt;a class=&#34;link&#34; href=&#34;https://qiankunli.github.io/2021/08/18/gpu.html#WCREFX-3108196&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 nv的硬件架构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CPU和GPU的主要区别在于它们的设计目标。CPU的设计初衷是执行顺序指令，一直以来，为提高顺序执行性能，CPU设计中引入了许多功能。其重点在于减少指令执行时延，使CPU能够尽可能快地执行一系列指令。这些功能包括指令流水线、乱序执行、预测执行和多级缓存等（此处仅列举部分）。而GPU则专为大规模并行和高吞吐量而设计，但这种设计导致了中等至高程度的指令时延。这一设计方向受其在视频游戏、图形处理、数值计算以及现如今的深度学习中的广泛应用所影响，所有这些应用都需要以极高的速度执行大量线性代数和数值计算，因此人们倾注了大量精力以提升这些设备的吞吐量 &lt;a class=&#34;link&#34; href=&#34;https://qiankunli.github.io/2021/08/18/gpu.html#WCREFX-3080641&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 cpu更重视缩短指令的延迟，gpu允许指令有比较长的时延，但是一定要大的吞吐量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GPU的编程方式是SIMD(Single Instruction Multiple Data)意味着所有Core的计算操作完全是在相同的时间内进行的，但是输入的数据有所不同。如果这个工作给到CPU来做，需要N的时间才可以做完，但是给到GPU只需要一个时钟周期就可以完成。 &lt;a class=&#34;link&#34; href=&#34;https://qiankunli.github.io/2021/08/18/gpu.html#WCREFX-3108187&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jeson #处理器架构 gpu的编程方式也是SIMD&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GPU 的线程切换不同于 CPU，在 CPU 上切换线程需要保存现场，将所有寄存器都存到主存中，GPU 的线程切换只是切换了寄存器组（一个 SM 中有高达 64k 个寄存器），延迟超级低，几乎没有成本。 &lt;a class=&#34;link&#34; href=&#34;https://qiankunli.github.io/2021/08/18/gpu.html#WCREFX-3108312&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 寄存器组的好处是延迟很低，可以快速存储和切换数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;张量核心与普通的 CUDA 核心其实有很大的区别，CUDA 核心在每个时钟周期都可以准确的执行一次整数或者浮点数的运算，时钟的速度和核心的数量都会影响整体性能。张量核心通过牺牲一定的精度可以在每个时钟计算执行一次 4 x 4 的矩阵运算。PS：就像ALU 只需要加法器就行了（乘法指令转换为多个加法指令），但为了提高性能，直接做了一个乘法器和加法器并存。 &lt;a class=&#34;link&#34; href=&#34;https://qiankunli.github.io/2021/08/18/gpu.html#WCREFX-3108325&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 这里的张量core类似于AIC的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一个 SM 里面有多个 subcore，每个 subcore 有一个 32 thread 的 warp scheduler 和 dispatcher, 在一个 warp 中的所有线程都会同时执行相同的指令，但是输入的数据不同，这种机制也被称为 SIMD（单指令多数据）或 SIMT（单指令多线程）模型。 &lt;a class=&#34;link&#34; href=&#34;https://qiankunli.github.io/2021/08/18/gpu.html#WCREFX-3047818&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 什么是simt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;但是因为 SRAM 比较小, 所以基本原则就是: 每次往 SRAM 移动数据的, 都可能多的用这个数据. 避免来来回回的移动数据. 这种 idea 直接促成了最近大火的 FlashAttention. FlashAttention 发现很多操作计算量不大, 但是 latency 很高, 那肯定是不符合上述的 “每次往 SRAM 移动数据的”. 怎么解决呢?Attention 基本上是由 matrix multiplication 和 softmax 构成的. 我们已经知道了 matrix multiplication 是可以分块做的, 所以就剩下 softmax 能不能分块做? softmax 其实也是可以很简单的被分块做的. 所以就有了 FlashAttention. &lt;a class=&#34;link&#34; href=&#34;https://qiankunli.github.io/2021/08/18/gpu.html#WCREFX-3109399&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#性能优化 flash attention的想法源头&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fa6c/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fa6c/</guid>
        <description>&lt;h2 id=&#34;cpu-和-gpu---异构计算的演进与发展---面向信仰编程&#34;&gt;CPU 和 GPU - 异构计算的演进与发展 - 面向信仰编程&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;计算机图形领域的圣杯是实时的全局光照，实现更好的光线追踪可以帮助我们在屏幕上渲染更加真实的图像，然而全局光照需要 GPU 进行大量的计算，而实时的全局光照更是对性能有着非常高的要求。传统的 GPU 架构并不擅长光线追踪等任务，所以 Nvidia 在 Turing 架构中首次引入了光线追踪核心（Ray-Tracing Core、RT Core）。 &lt;a class=&#34;link&#34; href=&#34;https://draveness.me/heterogeneous-computing/#fn:18https:/draveness.me/heterogeneous-computing&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson 新增光追模块，图形领域的圣杯&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89faa8/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89faa8/</guid>
        <description>&lt;h2 id=&#34;cpu-和-gpu---异构计算的演进与发展---面向信仰编程&#34;&gt;CPU 和 GPU - 异构计算的演进与发展 - 面向信仰编程&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CPU 和 GPU - 异构计算的演进与发展 &lt;a class=&#34;link&#34; href=&#34;https://draveness.me/heterogeneous-computing/https:/draveness.me/heterogeneous-computing#WCREFX-3080234&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 非常不错的介绍材料&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;越小的晶体管在开关时消耗的能量越少，既然晶体管需要一些时间充电和放电，那么消耗的能量也就越少，速度也越快，而这也解释了为什么增加 CPU 的电压可以提高它的运行速度。除此之外，更小的晶体管间隔使得信号的传输变得更快，这也能够加快 CPU 的处理速度5。 &lt;a class=&#34;link&#34; href=&#34;https://draveness.me/heterogeneous-computing/https:/draveness.me/heterogeneous-computing#WCREFX-3080248&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;L1 缓存中区分数据缓存和指令缓存以提高缓存的命中率。 &lt;a class=&#34;link&#34; href=&#34;https://draveness.me/heterogeneous-computing/https:/draveness.me/heterogeneous-computing#WCREFX-3080257&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 区分dcache和icahce的目的是为了提升缓存的命中率？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;除了上述这些组件之外，SM 中还包含特殊函数的计算单元（Special Functions Unit、SPU）以及用于存储和缓存数据的寄存器文件（Register File）、共享内存（Shared Memory）、一级缓存和通用缓存。 &lt;a class=&#34;link&#34; href=&#34;https://draveness.me/heterogeneous-computing/https:/draveness.me/heterogeneous-computing#WCREFX-3108115&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson 这些单元npu也有&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最初的 GPU 仅仅是为了更快地创建和渲染图片，它们广泛存在于个人主机上承担着图像渲染的任务，但是随着机器学习等技术的发展，GPU 中出现了更多种类的专用核心来支撑特定的场景，我们在这里介绍两种 GPU 中存在的专用核心：张量核心（Tensor Core）和光线追踪核心（Ray-Tracing Core）： &lt;a class=&#34;link&#34; href=&#34;https://draveness.me/heterogeneous-computing/https:/draveness.me/heterogeneous-computing#WCREFX-3080505&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson 为了执行新任务，增加新的计算单元&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fac2/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fac2/</guid>
        <description>&lt;h2 id=&#34;cpu-architecture---what-does-a-split-cache-means-and-how-is-it-usefulif-it-is---stack-overflow&#34;&gt;cpu architecture - What does a &amp;lsquo;Split&amp;rsquo; cache means. And how is it useful(if it is)? - Stack Overflow&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;What does a &amp;lsquo;Split&amp;rsquo; cache means. And how is it useful(if it is)? &lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/55752699/what-does-a-split-cache-means-and-how-is-it-usefulif-it-is#WCREFX-3080287&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 为什么cache分为dcache和icache，而且在L2就不再区分了？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fahc/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fahc/</guid>
        <description>&lt;h2 id=&#34;nvdla-primer--nvdla-documentation&#34;&gt;NVDLA Primer — NVDLA Documentation&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Independent. When operating independently, each functional block is configured for when and what it executes, with each block working on its assigned task (akin to independent layers in a Deep Learning framework). Independent operation begins and ends with the assigned block performing memory-to-memory operations, in and out of main system memory or dedicated SRAM memory.&lt;/li&gt;
&lt;li&gt;Fused. Fused operation is similar to independent operation, however, some blocks can be assembled as a pipeline.&lt;/li&gt;
&lt;li&gt;This improves performance by bypassing the round trip through memory, instead having blocks communicate with each other through small FIFOs (i.e., the convolution core can pass data to the Single Data Point Processor, which can pass data to the Planar Data Processor, and in turn to the Cross-channel Data Processor). &lt;a class=&#34;link&#34; href=&#34;http://nvdla.org/primer.html#WCREFX-3079952&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson 从架构图来看，&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;DLA主要用于深度学习的推理，包括卷积、激活、pooling、norm以及reashape的操作&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;支持独立执行，每个单元自己访问SRAM，也支持类似UB融合的操作，数据在不同的单元流动，只在最后计算完毕之后运输到DDR&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Support for sparse weight compression saves memory bandwidth. Built-in Winograd convolution support improves compute efficiency for certain sizes of filters. Batch convolution, can save additional memory bandwidth by reusing weights when running multiple inferences in parallel. &lt;a class=&#34;link&#34; href=&#34;http://nvdla.org/primer.html#WCREFX-3079974&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson 卷积支持稀疏卷积、wino卷积以及权值共享多batch卷积&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fbaf/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fbaf/</guid>
        <description>&lt;h2 id=&#34;适用于新一代机器人开发的-jetson-orin--nvidia&#34;&gt;适用于新一代机器人开发的 Jetson Orin | NVIDIA&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;on Orin™ 模组算力 &lt;a class=&#34;link&#34; href=&#34;https://www.nvidia.cn/autonomous-machines/embedded-systems/jetson-orin/#WCREFX-3077940&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fbd7/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fbd7/</guid>
        <description>&lt;h2 id=&#34;自主机器ai-的未来--nvidia&#34;&gt;自主机器：AI 的未来 | NVIDIA&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;AI 正在变革各行各业并应对全球挑战NVIDIA Jetson™ 平台提供用于开发和部署 AI 赋能机器人、无人机、IVA 应用和自主机器的工具，助力这场变革。 &lt;a class=&#34;link&#34; href=&#34;https://www.nvidia.cn/autonomous-machines/#WCREFX-3078240&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson 应用前景&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全新 Jetson Orin™ 平台还能实现每秒高达 275 万亿次浮点运算的算力，其性能是上一代产品的 8 倍。从入门级的 Jetson Orin Nano™，到具备最高性能的 Jetson AGX Orin，Jetson Orin™ 基于同一架构提供 7 种不同的模组，无疑是机器人新时代的理想平台。 &lt;a class=&#34;link&#34; href=&#34;https://www.nvidia.cn/autonomous-machines/#WCREFX-3078258&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson 相同硬件架构，覆盖中高端&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fk9h/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-21-h89fk9h/</guid>
        <description>&lt;h2 id=&#34;vpi---vision-programming-interfacearchitecture&#34;&gt;VPI - Vision Programming Interface:Architecture&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;PVA&lt;/li&gt;
&lt;li&gt;The Programmable Vision Accelerator (PVA) is a processor in NVIDIA® Jetson AGX Orin™ and NVIDIA® Jetson Orin™ NX devices that is specialized for image processing and computer vision algorithms.&lt;/li&gt;
&lt;li&gt;Use the PVA backend when you need to leave the GPU free to run other tasks that only it can perform, such as deep learning inference stages and algorithms only implemented on CUDA backend.&lt;/li&gt;
&lt;li&gt;PVA hardware is much more power-efficient than CPU and CUDA hardware. Therefore, use the PVA backend where possible if power is at a premium.&lt;/li&gt;
&lt;li&gt;Each Jetson AGX Orin or Jetson XOrin NX device comprises one PVA processor, each one contains two vector processors. Therefore, the device can execute at most two independent PVA tasks concurrently.&lt;/li&gt;
&lt;li&gt;When multiple VPI streams have the PVA backend enabled, they each choose one available PVA vector processor in round-robin succession. &lt;a class=&#34;link&#34; href=&#34;https://docs.nvidia.com/vpi/architecture.html#WCREFX-3079752&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson NV没有公开PVA的硬件资料，PVA的概述，Programmable Vision Accelerator（可编程视觉加速器）。从文档来看，&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;PVA具有更高的能效（超过cpu和cuda硬件），如果是功耗敏感性的任务，则应该尽量使用PVA完成；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;协处理器，主要用于深度学习的推理以及CUDA的算法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;每个AVG Orin和Xorin NX设备有一个PVA处理器，每个处理器中有2个vector处理器，因此一个设备可以最多独立处理2个PVA任务&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-24-h89d8hm/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-24-h89d8hm/</guid>
        <description>&lt;h2 id=&#34;理解cuda中的threadblockgrid和warp---知乎&#34;&gt;理解CUDA中的thread,block,grid和warp - 知乎&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;当一个kernel被执行时，grid中的线程块被分配到SM上，一个线程块的thread只能在一个SM上调度，SM一般可以调度多个线程块，大量的thread可能被分到不同的SM上。每个thread拥有它自己的程序计数器和状态寄存器，并且用该线程自己的数据执行指令，这就是所谓的Single Instruction Multiple Thread(SIMT)。 &lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/123170285#WCREFX-3109444&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson SIMT的基础概念&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-25-h89735h/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-25-h89735h/</guid>
        <description>&lt;h2 id=&#34;nvidiadeep-learning-accelerator-swnvidia-dla-sw-the-recipes-and-tools-for-running-deep-learning-workloads-on-nvidia&#34;&gt;NVIDIA/Deep-Learning-Accelerator-SW:NVIDIA DLA-SW, the recipes and tools for running deep learning workloads on NVIDIA&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Deep Learning Accelerator &lt;a class=&#34;link&#34; href=&#34;https://github.com/NVIDIA/Deep-Learning-Accelerator-SW#WCREFX-3130686&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson DLA的架构和能效&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-25-h8973c7/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-25-h8973c7/</guid>
        <description>&lt;h2 id=&#34;daily-note-2024-03-25&#34;&gt;Daily Note 2024-03-25&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;亮点一是Winograd卷积法，针对于尺寸较小卷积核，可以节省一半的乘法器数量与功耗；二是采用压缩传输算法，将传输数据带宽降低一半。 &lt;a class=&#34;link&#34; href=&#34;https://marker.dotalk.cn/#/?noteidx=H8973C7&amp;amp;wucairefx=WCREFX-3130665&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-25-h8973ee/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-25-h8973ee/</guid>
        <description>&lt;h2 id=&#34;英伟达全面分析五明星芯片xavier史上最复杂最庞大的soc---知乎&#34;&gt;英伟达全面分析（五），明星芯片Xavier，史上最复杂最庞大的SoC - 知乎&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;jetson比较全面的介绍&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;DLA与PVA是两个专用ASIC，DLA用于推理 ，PVA用于加速传统视觉算法。 &lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/485798446#WCREFX-3130781&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson 处理器架构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可编程视觉加速器PVA &lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/485798446#WCREFX-3130817&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;PVA的材料很少&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-25-h8973em/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-25-h8973em/</guid>
        <description>&lt;h2 id=&#34;一篇文章回答你关于nvidia-dla的所有疑问-腾讯云开发者社区-腾讯云&#34;&gt;一篇文章回答你关于NVIDIA DLA的所有疑问-腾讯云开发者社区-腾讯云&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一篇文章回答你关于NVIDIA DLA的所有疑问 &lt;a class=&#34;link&#34; href=&#34;https://cloud.tencent.com/developer/article/2205567#WCREFX-3130746&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson DLA的全文介绍&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-25-h897863/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-25-h897863/</guid>
        <description>&lt;h2 id=&#34;nvidia-jetson-explained--ai-jobsnet&#34;&gt;Nvidia Jetson explained | ai-jobs.net&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Jetson Nano: This entry-level module is designed for low-power, low-cost AI applications. It features a quad-core ARM Cortex-A57 CPU coupled with a 128-core Nvidia Maxwell GPU.&lt;/li&gt;
&lt;li&gt;Jetson Xavier NX: This module strikes a balance between performance and power efficiency. It is equipped with a six-core Nvidia Carmel ARM CPU and a 384-core Nvidia Volta GPU.&lt;/li&gt;
&lt;li&gt;Jetson AGX Xavier: This high-end module is designed for demanding AI workloads. It boasts an eight-core Nvidia Carmel ARM CPU and a 512-core Nvidia Volta GPU. &lt;a class=&#34;link&#34; href=&#34;https://ai-jobs.net/insights/nvidia-jetson-explained/#WCREFX-3128468&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson 不同级别的产品&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Use Cases and Examples &lt;a class=&#34;link&#34; href=&#34;https://ai-jobs.net/insights/nvidia-jetson-explained/#WCREFX-3128482&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson 应用场景包括自动驾驶、工业机器人、人形机器人、智慧城市（交通管理）、医疗等行业&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-25-h8978ck/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-25-h8978ck/</guid>
        <description>&lt;h2 id=&#34;请问英伟达gpu的tensor-core和cuda-core是什么区别&#34;&gt;请问英伟达GPU的tensor core和cuda core是什么区别？&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Tesla1.0 （2006年, 代表GeForce8800) -&amp;gt; Tesla2.0 (GT200) -&amp;gt; Fermi(算力可以支撑深度学习啦) -&amp;gt; Kepler(core增长) -&amp;gt; Maxwell（core继续增长） -&amp;gt; Pascal（算力提升）-&amp;gt; Volta(第一代tensor core) -&amp;gt; Turning(第二代 tensor core) -&amp;gt; Ampere(第三代tensor core)。 &lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/451127498#WCREFX-3128261&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#jetson gpu架构演进的趋势&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如下右图GPU典型架构，每一行一个control和cache对应有多个Core，代表着同样指令在同一时刻可由多个Core执行，这样并行的设计使GPU可以并行执行几千个线程，而其内存访问的延时被计算掩盖。 &lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/451127498#WCREFX-3128370&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 gpu和cpu的架构演进历史&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-25-h89d72b/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-25-h89d72b/</guid>
        <description>&lt;h2 id=&#34;yuv格式简介yuv444yuv422yuv420_yuv422-yuv420-csdn博客&#34;&gt;YUV格式简介、YUV444、YUV422、YUV420_yuv422 yuv420-CSDN博客&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;YUV格式简介、YUV444、YUV422、YUV420 &lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/yu540135101/article/details/107121769#WCREFX-3122263&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;aipp的个格式信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-25-h89d78c/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/03/wucai-2024-03-25-h89d78c/</guid>
        <description>&lt;h2 id=&#34;为什么视频编码器要输入yuv420格式---知乎&#34;&gt;为什么视频编码器要输入YUV420格式？ - 知乎&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;为什么视频编码器要输入YUV420格式 &lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/452676366#WCREFX-3122317&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;aipp的这个看起来更详细&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-01-h89ahdh/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-01-h89ahdh/</guid>
        <description>&lt;h2 id=&#34;resize---harmonyhus-blog&#34;&gt;Resize - HarmonyHu’s Blog&lt;/h2&gt;
&lt;p&gt;#星标 #算子&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;#算子 双线性插值中align corners和half pixel清晰的解释&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-06-h8fe37e/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-06-h8fe37e/</guid>
        <description>&lt;h2 id=&#34;cache的基本原理---知乎&#34;&gt;Cache的基本原理 - 知乎&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;对于没有接触过底层技术的朋友来说，或许从未听说过cache。毕竟cache的存在对程序员来说是透明的。在接触cache之前，先为你准备段code分析。 &lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/102293437#WCREFX-3280684&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#内存 缓存处理的基本原理，非常不错的文章&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;这种多级cache的工作方式称之为inclusive cache。某一地址的数据可能存在多级缓存中。与inclusive cache对应的是exclusive cache，这种cache保证某一地址的数据缓存只会存在于多级cache其中一级。也就是说，任意地址的数据不可能同时在L1和L2 cache中缓存。 &lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/102293437#WCREFX-3280911&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;因此，当cache size一定的情况下，组相连缓存对性能的提升最差情况下也和直接映射缓存一样，在大部分情况下组相连缓存效果比直接映射缓存好。同时，其降低了cache颠簸的频率。从某种程度上来说，直接映射缓存是组相连缓存的一种特殊情况，每个组只有一个cache line而已。因此，直接映射缓存也可以称作单路组相连缓存。 &lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/102293437#WCREFX-3281227&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 硬件仅仅一部分代价&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-06-h8fed58/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-06-h8fed58/</guid>
        <description>&lt;h2 id=&#34;computer-science-from-the-bottom-up&#34;&gt;Computer Science from the Bottom Up&lt;/h2&gt;
&lt;p&gt;#处理器架构 #星标&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;#处理器架构 计算机体系结构的好书&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-06-h8fed68/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-06-h8fed68/</guid>
        <description>&lt;h2 id=&#34;第04章处理器体系结构---csapp重点解读&#34;&gt;第04章：处理器体系结构 - CSAPP重点解读&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://fengmuzi2003.gitbook.io/~gitbook/image?url=https:%2F%2F1380295634-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MV9vJFv4kmvRLgEog6g%252F-MWhiF4oJC77aj6A5dhb%252F-MWhqBhhTLobh3VDfmCx%252F%25E6%258D%2595%25E8%258E%25B7.PNG%3Falt=media%26token=5a7f4733-303f-4dc1-a6db-272e4ad7a135&amp;amp;width=768&amp;amp;dpr=4&amp;amp;quality=100&amp;amp;sign=3575f3d3704bd9b5f8f059258ad0687051b0cfc04aee95858110d8a59d497264&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt; &lt;a class=&#34;link&#34; href=&#34;https://fengmuzi2003.gitbook.io/csapp3e/di-4-zhang-chu-li-qi-ti-xi-jie-gou#WCREFX-3287437&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 非常重要的一幅图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://fengmuzi2003.gitbook.io/~gitbook/image?url=https:%2F%2F1380295634-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MV9vJFv4kmvRLgEog6g%252F-MWhriHuL9YWtyuF2fat%252F-MWhuwtwvwT-X-jMo98w%252F%25E6%258D%2595%25E8%258E%25B74444444444444444444444.PNG%3Falt=media%26token=1405fa53-6148-4810-bc2b-68e8a2c78791&amp;amp;width=768&amp;amp;dpr=4&amp;amp;quality=100&amp;amp;sign=7cfdf2ef78eda5b9c348c24d072a86054f6e62e0c7d5e87d859ceddc19be6bd4&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt; &lt;a class=&#34;link&#34; href=&#34;https://fengmuzi2003.gitbook.io/csapp3e/di-4-zhang-chu-li-qi-ti-xi-jie-gou#WCREFX-3287519&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-06-h8fed7m/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-06-h8fed7m/</guid>
        <description>&lt;h2 id=&#34;modern-microprocessors---a-90-minute-guide&#34;&gt;Modern Microprocessors - A 90-Minute Guide!&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Modern Microprocessors&lt;/li&gt;
&lt;li&gt;A 90-Minute Guide! &lt;a class=&#34;link&#34; href=&#34;https://www.lighterra.com/papers/modernmicroprocessors/#WCREFX-3287563&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 非常不错的教程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-06-h8fedc8/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-06-h8fedc8/</guid>
        <description>&lt;h2 id=&#34;第01章计算机系统漫游--csapp重点解读&#34;&gt;第01章：计算机系统漫游 | CSAPP重点解读&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;第01章：计算机系统漫游 &lt;a class=&#34;link&#34; href=&#34;https://fengmuzi2003.gitbook.io/csapp3e#WCREFX-3287304&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 非常不错的CSAPP讲解的页面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-07-h8f62dk/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-07-h8f62dk/</guid>
        <description>&lt;h2 id=&#34;jasonren0403scoreboardcomputer-structure---scoreboarding-algorithm-visualizationpure-htmlcssjs&#34;&gt;jasonren0403/scoreboard:Computer structure - scoreboarding algorithm visualization(pure html+css+js)&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;记分牌算法可视化演示 &lt;a class=&#34;link&#34; href=&#34;https://github.com/jasonren0403/scoreboard#WCREFX-3292926&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 记分牌算法的动态演示&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-07-h8f6cd2/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-07-h8f6cd2/</guid>
        <description>&lt;h2 id=&#34;与程序员相关的cpu缓存知识--酷-壳---coolshell&#34;&gt;与程序员相关的CPU缓存知识 | 酷 壳 - CoolShell&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;好久没有写一些微观方面的文章了，今天写一篇关于CPU Cache相关的文章，这篇文章比较长，主要分成这么几个部分： &lt;a class=&#34;link&#34; href=&#34;https://coolshell.cn/articles/20793.html#WCREFX-3300734&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 非常不错的cache的介绍文章&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-07-h8f6m36/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-07-h8f6m36/</guid>
        <description>&lt;h2 id=&#34;图解yu12i420yv12nv12nv21yuv420pyuv420spyuv422pyuv444p的区别-csdn博客&#34;&gt;图解YU12、I420、YV12、NV12、NV21、YUV420P、YUV420SP、YUV422P、YUV444P的区别-CSDN博客&lt;/h2&gt;
&lt;p&gt;#AIPP #星标&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;图解YU12、I420、YV12、NV12、NV21、YUV420P、YUV420SP、YUV422P、YUV444P的区别 &lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/byhook/article/details/84037338#WCREFX-3294461&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#aipp 音视频的数据格式图解&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
&lt;h3 id=&#34;音视频实践学习&#34;&gt;音视频实践学习&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/byhook/article/details/83449831&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;android全平台编译ffmpeg以及x264与fdk-aac实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/byhook/article/details/83572828&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ubuntu下使用nginx和nginx-rtmp-module配置直播推流服务器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/byhook/article/details/83576698&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;android全平台编译ffmpeg合并为单个库实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/byhook/article/details/83580714&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;android-studio使用cmake编译ffmpeg实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/byhook/article/details/83582269&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;android全平台编译ffmpeg视频解码器实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/byhook/article/details/83582640&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;android全平台编译ffmpeg支持命令行实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/byhook/article/details/83592093&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;android全平台编译ffmpeg视频推流实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/byhook/article/details/83926620&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;android平台下音频编码之编译LAME库转码PCM为MP3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/byhook/article/details/84037338&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;图解YU12、I420、YV12、NV12、NV21、YUV420P、YUV420SP、YUV422P、YUV444P的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/byhook/article/details/84256849&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ubuntu平台下编译vlc-android视频播放器实践&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;概述&#34;&gt;概述&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;YUV模型&lt;/code&gt;是根据一个亮度&lt;code&gt;(Y分量)&lt;/code&gt;和两个色度&lt;code&gt;(UV分量)&lt;/code&gt;来定义颜色空间，常见的YUV格式有&lt;code&gt;YUY2、YUYV、YVYU、UYVY、AYUV、Y41P、Y411、Y211、IF09、IYUV、YV12、YVU9、YUV411、YUV420&lt;/code&gt;等，其中比较常见的&lt;code&gt;YUV420&lt;/code&gt;分为两种：&lt;code&gt;YUV420P和YUV420SP&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们在android平台下使用相机默认图像格式是&lt;code&gt;NV21&lt;/code&gt;属于&lt;code&gt;YUV420SP&lt;/code&gt;格式&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://g1proxy.wimg.site/sMkzQ0UDvUXYti_c0qJPaDdaWJ9lWmIcqzo2mFoAvwJY/https://img-blog.csdnimg.cn/20181120103325455.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;yuv采样&#34;&gt;YUV采样&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;YUV 4:4:4采样，每一个Y对应一组UV分量,一个YUV占8+8+8 = 24bits 3个字节。 YUV 4:2:2采样，每两个Y共用一组UV分量,一个YUV占8+4+4 = 16bits 2个字节。 YUV 4:2:0采样，每四个Y共用一组UV分量,一个YUV占8+2+2 = 12bits 1.5个字节。 &lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1&lt;/li&gt;
&lt;li&gt;2&lt;/li&gt;
&lt;li&gt;3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们最常见的&lt;code&gt;YUV420P和YUV420SP&lt;/code&gt;都是基于&lt;code&gt;4:2:0&lt;/code&gt;采样的，所以如果图片的宽为&lt;code&gt;width&lt;/code&gt;，高为&lt;code&gt;heigth&lt;/code&gt;，在内存中占的空间为&lt;code&gt;width * height * 3 / 2&lt;/code&gt;，其中前&lt;code&gt;width * height&lt;/code&gt;的空间存放&lt;code&gt;Y分量&lt;/code&gt;，接着&lt;code&gt;width * height / 4&lt;/code&gt;存放&lt;code&gt;U分量&lt;/code&gt;，最后&lt;code&gt;width * height / 4&lt;/code&gt;存放&lt;code&gt;V分量&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;yuv420pyu12和yv12格式&#34;&gt;YUV420P(YU12和YV12)格式&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;YUV420P&lt;/code&gt;又叫&lt;code&gt;plane平面模式&lt;/code&gt;，&lt;code&gt;Y , U , V&lt;/code&gt;分别在不同平面，也就是有三个平面，它是&lt;code&gt;YUV标准格式4：2：0&lt;/code&gt;，主要分为：&lt;code&gt;YU12和YV12&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://g1proxy.wimg.site/sazpJMYEGfrb0knKhXGyryHl1VpkgsMGRGu3Dcctv690/https://img-blog.csdnimg.cn/20181119225805899.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://g1proxy.wimg.site/sTYJ8PqIMaRvcYk41hyYRD81LX4X0P2PeH-2n5OVlNtM/https://img-blog.csdnimg.cn/2018111923013322.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;YU12格式&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在&lt;code&gt;android平台下&lt;/code&gt;也叫作&lt;code&gt;I420格式&lt;/code&gt;，首先是所有&lt;code&gt;Y值&lt;/code&gt;，然后是所有&lt;code&gt;U值&lt;/code&gt;，最后是所有&lt;code&gt;V值&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://g1proxy.wimg.site/s0nzKrPwwnvR_d4Bixl2alse7WGL90-oEW3th0tGJ9BI/https://img-blog.csdnimg.cn/2018112012345555.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;YU12：亮度(行×列) + U(行×列/4) + V(行×列/4)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;YV12格式&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;YV12格式&lt;/code&gt;与&lt;code&gt;YU12&lt;/code&gt;基本相同，首先是所有&lt;code&gt;Y值&lt;/code&gt;，然后是所有&lt;code&gt;V值&lt;/code&gt;，最后是所有&lt;code&gt;U值&lt;/code&gt;。只要注意从适当的位置提取&lt;code&gt;U和V值&lt;/code&gt;，&lt;code&gt;YU12和YV12&lt;/code&gt;都可以使用相同的算法进行处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://g1proxy.wimg.site/sYPhvbrWUkU4cfhNfLBvBNTNNaYzb8Zz4cEF-R-tuhN8/https://img-blog.csdnimg.cn/20181120123516554.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;YV12：亮度Y(行×列) + V(行×列/4) + U(行×列/4)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;YU12: YYYYYYYY UUVV    =&amp;gt;    YUV420P YV12: YYYYYYYY VVUU    =&amp;gt;    YUV420P &lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1&lt;/li&gt;
&lt;li&gt;2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;YUV模型是根据一个亮度(Y分量)和两个色度(UV分量)来定义颜色空间，常见的YUV格式有YUY2、YUYV、YVYU、UYVY、AYUV、Y41P、Y411、Y211、IF09、IYUV、YV12、YVU9、YUV411、YUV420等，其中比较常见的YUV420分为两种：YUV420P和YUV420SP。&lt;/p&gt;
&lt;p&gt;我们在android平台下使用相机默认图像格式是NV21属于YUV420SP格式## YUV420SP(NV21和NV12)格式&lt;/p&gt;
&lt;p&gt;&lt;code&gt;YUV420SP&lt;/code&gt;格式的图像阵列，首先是所有&lt;code&gt;Y值&lt;/code&gt;，然后是&lt;code&gt;UV&lt;/code&gt;或者&lt;code&gt;VU&lt;/code&gt;交替存储，&lt;code&gt;NV12和NV21属于YUV420SP&lt;/code&gt;格式，是一种&lt;code&gt;two-plane模式&lt;/code&gt;，即&lt;code&gt;Y和UV分为两个plane&lt;/code&gt;，但是&lt;code&gt;UV(CbCr)&lt;/code&gt;为交错存储，而不是分为三个平面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://g1proxy.wimg.site/sBpnmM5exUU_uP0fZVKM4lFbb3ELfMmcnyZRAO5T4YLk/https://img-blog.csdnimg.cn/201811192258324.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NV21格式&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;android手机从摄像头采集的预览数据一般都是NV21，存储顺序是先存Y，再VU交替存储，&lt;code&gt;NV21&lt;/code&gt;存储顺序是先存&lt;code&gt;Y值&lt;/code&gt;，再&lt;code&gt;VU&lt;/code&gt;交替存储：&lt;code&gt;YYYYVUVUVU&lt;/code&gt;，以 &lt;code&gt;4 X 4&lt;/code&gt; 图片为例子，占用内存为 &lt;code&gt;4 X 4 X 3 / 2 = 24&lt;/code&gt; 个字节&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://g1proxy.wimg.site/sfpl4v4Ab1lBAeL-8ILFK8Z7yzTjLaVOSit0clgRgqUs/https://img-blog.csdnimg.cn/20181119235116552.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NV12格式&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;NV12与NV21类似，也属于&lt;code&gt;YUV420SP&lt;/code&gt;格式，&lt;code&gt;NV12&lt;/code&gt;存储顺序是先存&lt;code&gt;Y值&lt;/code&gt;，再&lt;code&gt;UV&lt;/code&gt;交替存储：&lt;code&gt;YYYYUVUVUV&lt;/code&gt;，以 &lt;code&gt;4 X 4&lt;/code&gt; 图片为例子，占用内存为 &lt;code&gt;4 X 4 X 3 / 2 = 24&lt;/code&gt; 个字节&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://g1proxy.wimg.site/sma_yqSng2U3gGWgBJL0-M5HqW5pIn9sqLzZL1XneBHQ/https://img-blog.csdnimg.cn/20181119235210475.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注意：在DVD中，色度信号被存储成Cb和Cr(C代表颜色，b代表蓝色，r代表红色)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NV12: YYYYYYYY UVUV    =&amp;gt;YUV420SP NV21: YYYYYYYY VUVU    =&amp;gt;YUV420SP &lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1&lt;/li&gt;
&lt;li&gt;2&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;yuv和rgb转换&#34;&gt;YUV和RGB转换&lt;/h3&gt;
&lt;p&gt;`Y      =  (0.257 * R) + (0.504 * G) + (0.098 * B) + 16
Cr = V =  (0.439 * R) - (0.368 * G) - (0.071 * B) + 128
Cb = U = -(0.148 * R) - (0.291 * G) + (0.439 * B) + 128&lt;/p&gt;
&lt;p&gt;B = 1.164(Y - 16) + 2.018(U - 128)
G = 1.164(Y - 16) - 0.813(V - 128) - 0.391(U - 128)
R = 1.164(Y - 16) + 1.596(V - 128)
`&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1&lt;/li&gt;
&lt;li&gt;2&lt;/li&gt;
&lt;li&gt;3&lt;/li&gt;
&lt;li&gt;4&lt;/li&gt;
&lt;li&gt;5&lt;/li&gt;
&lt;li&gt;6&lt;/li&gt;
&lt;li&gt;7&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分离yuv420p&#34;&gt;分离YUV420P&lt;/h3&gt;
&lt;p&gt;下面基于实例来理解&lt;code&gt;Y，U，V分量的作用&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://g1proxy.wimg.site/s0xbrRr7beeo68hdzhB9Fb1N77qci7EkbIaJKvMhCOsY/https://img-blog.csdnimg.cn/20181120132051472.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;先使用&lt;code&gt;ffmpeg&lt;/code&gt;将指定的图片转为&lt;code&gt;yuv420p&lt;/code&gt;格式&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ffmpeg -i input.jpg -s 510x510 -pix_fmt yuv420p input.yuv &lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;分离YUV分量&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;笔者使用的&lt;code&gt;Clion&lt;/code&gt;直接运行下面这段代码，分离出所需的文件&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;void split_yuv420(char *inputPath, int width, int height) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    FILE *fp_yuv = fopen(inputPath, &amp;#34;rb+&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    FILE *fp_y = fopen(&amp;#34;output_420_y.y&amp;#34;, &amp;#34;wb+&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    FILE *fp_u = fopen(&amp;#34;output_420_u.y&amp;#34;, &amp;#34;wb+&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    FILE *fp_v = fopen(&amp;#34;output_420_v.y&amp;#34;, &amp;#34;wb+&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    unsigned char *data = (unsigned char *) malloc(width * height * 3 / 2);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fread(data, 1, width * height * 3 / 2, fp_yuv);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    //Y
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fwrite(data, 1, width * height, fp_y);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    //U
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fwrite(data + width * height, 1, width * height / 4, fp_u);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    //V
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fwrite(data + width * height * 5 / 4, 1, width * height / 4, fp_v);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    //释放资源
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    free(data);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fclose(fp_yuv);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fclose(fp_y);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fclose(fp_u);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fclose(fp_v);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;笔者使用的是&lt;code&gt;ubuntu系统&lt;/code&gt;，因此运行&lt;code&gt;yuvplayer.exe&lt;/code&gt;文件，需要提前安装好&lt;code&gt;wine&lt;/code&gt;：&lt;code&gt;sudo apt install wine&lt;/code&gt;，运行&lt;code&gt;yuvplayer&lt;/code&gt;之后，需要先设置&lt;code&gt;像素格式为Y&lt;/code&gt;，否则你看到的图像可能会有问题&lt;/p&gt;
&lt;p&gt;先看&lt;code&gt;output_420_y.y&lt;/code&gt;文件：(分辨率设置为510x510)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://g1proxy.wimg.site/seroHqPK4TN6WbfVU7Xnc_oIsZgjJJikEfjz9GqMmI40/https://img-blog.csdnimg.cn/20181120145851501.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;output_420_u.y&lt;/code&gt;显示如下：(分辨率设置为255x255)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://g1proxy.wimg.site/sTE6oRbTQiZ_UjeLZgquoer7VAodkJ7qIhqiGwlOI5Kc/https://img-blog.csdnimg.cn/20181120150020705.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;output_420_v.y&lt;/code&gt;显示如下：(分辨率设置为255x255)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://g1proxy.wimg.site/sHj4-4BrcQciG9WjfUrsMAtptfkhQXR4hHNNpDBwEkpI/https://img-blog.csdnimg.cn/20181120150043110.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成灰度图&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;上面的例子实际上已经生成了一个&lt;code&gt;灰度图&lt;/code&gt;了，但是只保留了&lt;code&gt;Y分量&lt;/code&gt;，你如果直接用&lt;code&gt;ffplay工具&lt;/code&gt;查看会有问题，下面的函数将会生成一个标准的&lt;code&gt;YUV文件&lt;/code&gt;并且保留&lt;code&gt;Y分量&lt;/code&gt;，你可能会有疑问，为什么&lt;code&gt;U分量和V分量&lt;/code&gt;要写入&lt;code&gt;0x80&lt;/code&gt;，其实你可以参考上面的&lt;code&gt;YUV转RGB的公式&lt;/code&gt;，YUV数据是无法直接显示的，最终需要转成RGB显示，因此我这里是只需要保留&lt;code&gt;Y分量&lt;/code&gt;，忽略&lt;code&gt;UV&lt;/code&gt;分量的影响，因此根据上面的公式，我在&lt;code&gt;U和V分量中都写入128&lt;/code&gt;就是十六进制的&lt;code&gt;0x80&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;保留Y分量(生成灰度图)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;void yuv420p_y(char *inputPath, char *outputPath, int width, int height) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    FILE *inFile = fopen(inputPath, &amp;#34;rb+&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    FILE *outFile = fopen(outputPath, &amp;#34;wb+&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    unsigned char *data = (unsigned char *) malloc(width * height * 3 / 2);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fread(data, 1, width * height * 3 / 2, inFile);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    //Y分量
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fwrite(data, 1, width * height, outFile);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    unsigned char *buffer = (unsigned char *) malloc(width * height / 4);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    memset(buffer, 0x80, width * height / 4);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    //U分量
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fwrite(buffer, 1, width * height / 4, outFile);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    //V分量
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fwrite(buffer, 1, width * height / 4, outFile);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    free(buffer);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    free(data);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fclose(inFile);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fclose(outFile);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;`int main() {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yuv420p_y(&amp;quot;/home/byhook/media/input.yuv&amp;quot;, &amp;quot;/home/byhook/media/output.yuv&amp;quot;, 510, 510);

return 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
`&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1&lt;/li&gt;
&lt;li&gt;2&lt;/li&gt;
&lt;li&gt;3&lt;/li&gt;
&lt;li&gt;4&lt;/li&gt;
&lt;li&gt;5&lt;/li&gt;
&lt;li&gt;6&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用&lt;code&gt;ffplay&lt;/code&gt;来播放&lt;code&gt;yuv格式&lt;/code&gt;的文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ffplay -f rawvideo -video_size 510x510 output.yuv &lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要注意这里的分辨率不能错&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://g1proxy.wimg.site/siSsBJdi6DSkO0KUP5ux3m2UZfkdjwSFpyIU3xjCD-4c/https://img-blog.csdnimg.cn/20181120131959565.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;分离yuv422p&#34;&gt;分离YUV422P&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;YUV422P&lt;/code&gt;基于&lt;code&gt;YUV 4:2:2&lt;/code&gt;采样，每两个Y共用一组UV分量,一个YUV占8+4+4 = 16bits 2个字节。分离代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;void split_yuv422(char *inputPath, int width, int height) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    FILE *fp_yuv = fopen(inputPath, &amp;#34;rb+&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    FILE *fp_y = fopen(&amp;#34;output_422_y.y&amp;#34;, &amp;#34;wb+&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    FILE *fp_u = fopen(&amp;#34;output_422_u.y&amp;#34;, &amp;#34;wb+&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    FILE *fp_v = fopen(&amp;#34;output_422_v.y&amp;#34;, &amp;#34;wb+&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    unsigned char *data = (unsigned char *) malloc(width * height * 2);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fread(data, 1, width * height * 2, fp_yuv);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    //Y
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fwrite(data, 1, width * height, fp_y);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    //U
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fwrite(data + width * height, 1, width * height / 2, fp_u);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    //V
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fwrite(data + width * height * 3 / 2, 1, width * height / 2, fp_v);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    //释放资源
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    free(data);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fclose(fp_yuv);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fclose(fp_y);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fclose(fp_u);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fclose(fp_v);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;分离yuv444p&#34;&gt;分离YUV444P&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;YUV444P&lt;/code&gt;基于&lt;code&gt;YUV 4:4:4&lt;/code&gt;采样，每一个Y对应一组UV分量,一个YUV占8+8+8 = 24bits 3个字节。分离代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;void split_yuv444(char *inputPath, int width, int height) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    FILE *fp_yuv = fopen(inputPath, &amp;#34;rb+&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    FILE *fp_y = fopen(&amp;#34;output_444_y.y&amp;#34;, &amp;#34;wb+&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    FILE *fp_u = fopen(&amp;#34;output_444_u.y&amp;#34;, &amp;#34;wb+&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    FILE *fp_v = fopen(&amp;#34;output_444_v.y&amp;#34;, &amp;#34;wb+&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    unsigned char *data = (unsigned char *) malloc(width * height * 3);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fread(data, 1, width * height * 3, fp_yuv);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    //Y
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fwrite(data, 1, width * height, fp_y);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    //U
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fwrite(data + width * height, 1, width * height, fp_u);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    //V
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fwrite(data + width * height * 2, 1, width * height, fp_v);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    //释放资源
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    free(data);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fclose(fp_yuv);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fclose(fp_y);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fclose(fp_u);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    fclose(fp_v);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;参考：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/leixiaohua1020/article/details/50534150&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/leixiaohua1020/article/details/50534150&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/YUV&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.wikipedia.org/wiki/YUV&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-08-h8fc5f8/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-08-h8fc5f8/</guid>
        <description>&lt;h2 id=&#34;dts2023101608945-dts&#34;&gt;DTS2023101608945-DTS&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;平台开发部&lt;/li&gt;
&lt;li&gt;海思ICT处理 &lt;a class=&#34;link&#34; href=&#34;https://dts-szv.clouddragon.huawei.com/DTSPortal/ticket/DTS2023101608945#WCREFX-3317547&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-09-h8f58fc/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-09-h8f58fc/</guid>
        <description>&lt;h2 id=&#34;实验室-5---jupyterlab-----实验室-5---jupyterlab&#34;&gt;实验室 （5） - JupyterLab &amp;mdash; 实验室 （5） - JupyterLab&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;5248 &lt;a class=&#34;link&#34; href=&#34;http://localhost:8888/lab#WCREFX-3327212&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;655360 &lt;a class=&#34;link&#34; href=&#34;http://localhost:8888/lab#WCREFX-3328195&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-10-h8f59d8/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-10-h8f59d8/</guid>
        <description>&lt;h2 id=&#34;swin-transformer&#34;&gt;Swin Transformer&lt;/h2&gt;
&lt;p&gt;#网络结构&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;#网络结构 非常不错的介绍swin transformer的文章&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://amaarora.github.io/images/swin-transformer-block.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt; &lt;a class=&#34;link&#34; href=&#34;https://amaarora.github.io/posts/2022-07-04-swintransformerv1.html#WCREFX-3340100&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#网络结构 swin transformer结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://amaarora.github.io/images/window-partition.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt; &lt;a class=&#34;link&#34; href=&#34;https://amaarora.github.io/posts/2022-07-04-swintransformerv1.html#WCREFX-3444486&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#网络结构 swin transformer的结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;While the Transformer architecture before this paper had proved to be performing better than CNNs on the ImageNet dataset, it was yet to be utilised as a general purpose backbone for other tasks such as object detection &amp;amp; semantic segmentation. This paper solves that problem and Swin Transformers can capably serve as general purpose backbones for computer vision. &lt;a class=&#34;link&#34; href=&#34;https://amaarora.github.io/posts/2022-07-04-swintransformerv1.html#WCREFX-3476556&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;transformer证明了在更通用的物体检测以及分割上也很不错&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://amaarora.github.io/images/swin-transformer.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt; &lt;a class=&#34;link&#34; href=&#34;https://amaarora.github.io/posts/2022-07-04-swintransformerv1.html#WCREFX-3476579&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The global computation leads to quadratic complexity with respect to the number of tokens, making it unsuitable for many vision problems requiring an immense set of tokens for dense prediction or to represent a high-resolution image &lt;a class=&#34;link&#34; href=&#34;https://amaarora.github.io/posts/2022-07-04-swintransformerv1.html#WCREFX-3477153&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;global attention计算复杂度是token的平方，复杂度很高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-18-h8fhfk5/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-18-h8fhfk5/</guid>
        <description>&lt;h2 id=&#34;wiki端到端体验ascend-c算子开发&#34;&gt;Wiki:端到端体验Ascend C算子开发&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;中 &lt;a class=&#34;link&#34; href=&#34;https://wiki.huawei.com/domains/40579/wiki/57221/WIKI202308281901551#WCREFX-3460832&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-19-h8f2768/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-19-h8f2768/</guid>
        <description>&lt;h2 id=&#34;the-annotated-transformer&#34;&gt;The Annotated Transformer&lt;/h2&gt;
&lt;p&gt;#星标 #网络结构&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;#网络结构 有注解的transformer的论文解读&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-19-h8f276b/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-19-h8f276b/</guid>
        <description>&lt;h2 id=&#34;the-annotated-transformer&#34;&gt;The Annotated Transformer&lt;/h2&gt;
&lt;p&gt;#星标 #网络结构&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;#网络结构 transformer的比较注解&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-19-h8f27e9/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-19-h8f27e9/</guid>
        <description>&lt;h2 id=&#34;u-net-a-pytorch-implementation-in-60-lines-of-code&#34;&gt;U-Net A PyTorch Implementation in 60 lines of Code&lt;/h2&gt;
&lt;p&gt;#星标 #网络结构&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;#网络结构 使用pytorch的60行完成一个Unet&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-19-h8f2dac/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-19-h8f2dac/</guid>
        <description>&lt;h2 id=&#34;onnx-toolreadme_cnmd-at-main--thanatosshinjionnx-tool&#34;&gt;onnx-tool/README_CN.md at main · ThanatosShinji/onnx-tool&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;你可以用onnx_tool.Model类去加载任意ONNX模型，变成易于编辑的python类实例，你可以:&lt;/li&gt;
&lt;li&gt;用onnx_tool.Graph类去改变图结构;&lt;/li&gt;
&lt;li&gt;用onnx_tool.Node类去改变每个Op的属性和输入输出Tensor;&lt;/li&gt;
&lt;li&gt;用onnx_tool.Tensor改变任意Tensor的数据类型和数据内容.&lt;/li&gt;
&lt;li&gt;修改完成后，只需要调用Graph或者Model类的save_model接口可以保存所有的修改内容到新的ONNX模型. &lt;a class=&#34;link&#34; href=&#34;https://github.com/ThanatosShinji/onnx-tool/blob/main/README_CN.md#WCREFX-3475073&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#模型转换 修改onnx模型的工具，建立自己的工作流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-19-h8f2dc9/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-19-h8f2dc9/</guid>
        <description>&lt;h2 id=&#34;onnx-toolbenchmarkexamplespy-at-main--thanatosshinjionnx-to&#34;&gt;onnx-tool/benchmark/examples.py at main · ThanatosShinji/onnx-to&lt;/h2&gt;
&lt;p&gt;#模型转换&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;#模型转换 这个是onnx tool的集大成的用例，需要好好研究&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;update examples.py &lt;a class=&#34;link&#34; href=&#34;https://github.com/ThanatosShinji/onnx-tool/blob/main/benchmark/examples.py#WCREFX-3475119&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-19-h8f2e5k/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-19-h8f2e5k/</guid>
        <description>&lt;h2 id=&#34;daquexianonnx-simplifiersimplify-your-onnx-model&#34;&gt;daquexian/onnx-simplifier:Simplify your onnx model&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;https://github.com/daquexian/onnx-simplifier/raw/master/imgs/comparison.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt; &lt;a class=&#34;link&#34; href=&#34;https://github.com/daquexian/onnx-simplifier#WCREFX-3473097&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#模型转换 使用工具转换模型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-19-h8f2fba/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-19-h8f2fba/</guid>
        <description>&lt;h2 id=&#34;深入浅出pytorch--深入浅出pytorch&#34;&gt;深入浅出PyTorch — 深入浅出PyTorch&lt;/h2&gt;
&lt;p&gt;#星标 #网络工具&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;#网络工具 利用pytorch构建网络模型并进行推理和部署&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-20-h8fka3f/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-20-h8fka3f/</guid>
        <description>&lt;h2 id=&#34;torchnnfunctionalgrid_sample--pytorch-22-documentation&#34;&gt;torch.nn.functional.grid_sample — PyTorch 2.2 documentation&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Currently, only spatial (4-D) and volumetric (5-D) input are supported. &lt;a class=&#34;link&#34; href=&#34;https://pytorch.org/docs/stable/generated/torch.nn.functional.grid_sample.html#WCREFX-3486044&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;当前的torch仅仅支持4d和5d的grid sample&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;grid specifies the sampling pixel locations normalized by the input spatial dimensions. &lt;a class=&#34;link&#34; href=&#34;https://pytorch.org/docs/stable/generated/torch.nn.functional.grid_sample.html#WCREFX-3486061&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#算子 grid是按照x的输入坐标归一化处理的维度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-22-h8f32f5/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-22-h8f32f5/</guid>
        <description>&lt;h2 id=&#34;2020-年-8月-随笔档案---shine-lee---博客园&#34;&gt;2020 年 8月 随笔档案 - shine-lee - 博客园&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;乍一看到某个问题，你会觉得很简单，其实你并没有理解其复杂性。当你把问题搞清楚之后，又会发现真的很复杂，于是你就拿出一套复杂的方案来。实际上，你的工作只做了一半，大多数人也都会到此为止……。但是，真正伟大的人还会继续向前，直至找到问题的关键和深层次原因，然后再拿出一个优雅的、堪称完美的有效方案。&lt;/li&gt;
&lt;li&gt;—— from 乔布斯 &lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/shine-lee/p/archive/2020/08#WCREFX-3515100&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#格言&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-22-h8f3h6b/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-22-h8f3h6b/</guid>
        <description>&lt;h2 id=&#34;cuda-编程入门---hpc-wiki&#34;&gt;CUDA 编程入门 - HPC Wiki&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;而 GPU 的设计哲学是吞吐量（throughput）比延迟更加重要。也就是说，GPU 的设计目标是让大量的数据可以同时被处理。GPU 使用大量的晶体管来堆砌大量的运算单元，通过同时让许多运算单元共享同一个控制单元，以节约晶体管。对于分支预测、乱序执行等控制单元，GPU 采用了 “不预测、不乱序” 的策略。这样的设计使得 GPU 在执行逻辑简单、并行度高的任务时能够发挥出其最大的性能。虽然 GPU 上单条数据处理的时间可能比用 CPU 更长，但 GPU 单位时间内处理完成的数据要要多得多。 &lt;a class=&#34;link&#34; href=&#34;https://hpcwiki.io/gpu/cuda/#WCREFX-3513611&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;我们打个比方：如果我们现在想证明一个复杂的数学命题，那么是一位陈景润解得快，还是 100 名大一学生解得快？大概率是前者，因为陈景润先生有着深厚的功底与丰富的经验，并且 “证明命题” 这一过程很难并行。&lt;/li&gt;
&lt;li&gt;但如果我们现在想要计算 10000 道 100 以内的乘除法呢？那么大概率是 100 名大一学生算得快。因为，虽然一名大一学生计算一道 100 以内的乘除法的速度比不上陈景润先生计算一道 100 以内的乘除法的速度，但 100 名大一学生一起工作，速度一定会比一位陈景润先生要快。 &lt;a class=&#34;link&#34; href=&#34;https://hpcwiki.io/gpu/cuda/#WCREFX-3513618&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 比喻非常贴切&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在 2006 年，NVIDIA 推翻了传统而设计，发布了一个革命性的 GPU 架构 - Tesla。在 Tesla 架构中，没有了专门负责处理某一个步骤的硬件单元，取而代之的则是 Stream Multiprocessor (SM) 。每个 SM 都像一个小型 CPU 一样，可以执行其支持的指令集中的任何程序。这也就代表着，每一个 SM 都有能力执行渲染管线中的每个部分。这种设计避免了某一个步骤成为瓶颈而其他步骤的运算单元闲置的情况：我只需要根据不同的游戏负载，为每个步骤分配一定数量的 SM 即可。 &lt;a class=&#34;link&#34; href=&#34;https://hpcwiki.io/gpu/cuda/#WCREFX-3513653&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 2006年才推翻之前的做法，做了创新性的架构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从此，GPU 成为了 General-Purpose Graphics Processing Unit (GPGPU)。 &lt;a class=&#34;link&#34; href=&#34;https://hpcwiki.io/gpu/cuda/#WCREFX-3513749&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;GPU + CUDA = GPGPU&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;异步执行：CUDA Kernel 是异步执行的，也就是说，所谓的 “调用” Kernel 只不过是 CPU 向 GPU 的任务队列里提交了一个任务，随后 CPU 就会继续执行接下来的指令，并不会等待 GPU 将这个 Kernel 执行完。这样设计的目的是：可以同时让 CPU 与 GPU 有活干，同时发掘出二者的潜力。如果想让 CPU 等待 GPU 上的所有 Kernel 均执行完（即，让两个设备同步），请调用 cudaDeviceSynchronize()。 &lt;a class=&#34;link&#34; href=&#34;https://hpcwiki.io/gpu/cuda/#WCREFX-3528696&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;启动 CUDA Kernel 的时候会创建一个 Grid。这个 Grid 里包含若干 Block，每个 Block 里包含若干 Thread。 &lt;a class=&#34;link&#34; href=&#34;https://hpcwiki.io/gpu/cuda/#WCREFX-3533669&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;存算比 &lt;a class=&#34;link&#34; href=&#34;https://hpcwiki.io/gpu/cuda/#WCREFX-3533707&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;这里应该是算存比&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-22-h8f3h78/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-22-h8f3h78/</guid>
        <description>&lt;h2 id=&#34;a-history-of-nvidia-stream-multiprocessor&#34;&gt;A history of NVidia Stream Multiprocessor&lt;/h2&gt;
&lt;p&gt;#处理器架构 #星标&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;#处理器架构 非常不错的处理器架构的介绍文章&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-22-h8fa576/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-22-h8fa576/</guid>
        <description>&lt;h2 id=&#34;nvidia-jetson-agx-orin-64gb-益登科技&#34;&gt;NVIDIA Jetson AGX Orin 64GB-益登科技&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TECHNICAL SPECIFICATION &lt;a class=&#34;link&#34; href=&#34;https://www.edomtech.com/zh-tw/product-detail/nvidia-jetson-agx-orin-64gb/#WCREFX-3505953&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#处理器架构 更详细的jetson架构的介绍知识&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-23-h8fb383/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/04/wucai-2024-04-23-h8fb383/</guid>
        <description>&lt;h2 id=&#34;cuda-c-best-practices-guide&#34;&gt;CUDA C++ Best Practices Guide&lt;/h2&gt;
&lt;p&gt;#处理器架构 #星标&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;#处理器架构 cuda处理器的最佳编程实践&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/05/wucai-2024-05-04-h85d5hm/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/05/wucai-2024-05-04-h85d5hm/</guid>
        <description>&lt;h2 id=&#34;cmake应用集成gtest进行单元测试---知乎&#34;&gt;cmake应用：集成gtest进行单元测试 - 知乎&lt;/h2&gt;
&lt;p&gt;#软件工程&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;#软件工程 cmake + gtest教程&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/05/wucai-2024-05-04-h85dc55/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/05/wucai-2024-05-04-h85dc55/</guid>
        <description>&lt;h2 id=&#34;cmake-保姆级教程下--爱编程的大丙&#34;&gt;CMake 保姆级教程（下） | 爱编程的大丙&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在生成可执行程序的时候，动态库不会被打包到可执行程序内部。当可执行程序启动之后动态库也不会被加载到内存，只有可执行程序调用了动态库中的函数的时候，动态库才会被加载到内存中，且多个进程可以共用内存中的同一个动态库，所以动态库又叫共享库。 &lt;a class=&#34;link&#34; href=&#34;https://subingwen.cn/cmake/CMake-advanced/index.html#WCREFX-3655779&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/05/wucai-2024-05-05-h857ab7/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/05/wucai-2024-05-05-h857ab7/</guid>
        <description>&lt;h2 id=&#34;道阻且长_再探矩阵乘法优化&#34;&gt;道阻且长_再探矩阵乘法优化&lt;/h2&gt;
&lt;p&gt;#性能优化 #星标&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;#性能优化 非常不错的基于cpu的gemm的优化分析方法&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/05/wucai-2024-05-06-h8582fb/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/05/wucai-2024-05-06-h8582fb/</guid>
        <description>&lt;h2 id=&#34;grid_sample-api文档-paddlepaddle深度学习平台&#34;&gt;grid_sample-API文档-PaddlePaddle深度学习平台&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;grid_sample &lt;a class=&#34;link&#34; href=&#34;https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/nn/functional/grid_sample_cn.html#WCREFX-3683441&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;#算子 paddlepaddle的示例非常清晰&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/05/wucai-2024-05-06-h858a53/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/05/wucai-2024-05-06-h858a53/</guid>
        <description>&lt;h2 id=&#34;黑夜如白昼可能是手机夜景模式对摄影的一个误解_秋影随行&#34;&gt;黑夜如白昼，可能是手机夜景模式对摄影的一个误解_秋影随行&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果你一直采用相机拍摄夜景，那么对这样的结果应该是习以为常；但是，手机摄影者不容易理解这一感光元件成像的天然特点。实际上，感光元件——无论相机还是手机的CMOS——所捕捉的图像反差与人眼睛所感受到的存在差别。对于夜景而言，困扰成像和渲染的最大问题还不是低照度，而是高反差。灯光的亮度与未被灯光照到的阴影部分，呈现出超乎想象的巨大亮度差异 &lt;a class=&#34;link&#34; href=&#34;https://qiuliang.com/digital_photography_tutorial/mobile_photography/night_photography_mode.htm#WCREFX-3690174&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/05/wucai-2024-05-10-h852692/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/05/wucai-2024-05-10-h852692/</guid>
        <description>&lt;h2 id=&#34;share-memory--bank-conflict---赶紧学习---博客园&#34;&gt;Share Memory &amp;amp; Bank Conflict - 赶紧学习 - 博客园&lt;/h2&gt;
&lt;p&gt;#处理器架构 #星标&lt;/p&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;p&gt;bank冲突定义根据cuda而来&lt;/p&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>https://blog.bugxch.top/wucai/2024/05/wucai-2024-05-10-h85299d/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://blog.bugxch.top/wucai/2024/05/wucai-2024-05-10-h85299d/</guid>
        <description>&lt;h2 id=&#34;科技爱好者周刊第-299-期ai-的关键是语料---阮一峰的网络日志&#34;&gt;科技爱好者周刊（第 299 期）：AI 的关键是语料 - 阮一峰的网络日志&lt;/h2&gt;
&lt;h2 id=&#34;页面笔记&#34;&gt;页面笔记&lt;/h2&gt;
&lt;h2 id=&#34;划线列表&#34;&gt;划线列表&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;他说，自己的日常工作就是开发 AI 模型，但是不管怎么增加参数、调整方程，模型效果都不如语料集的大小来得显著。&lt;/li&gt;
&lt;li&gt;更多的训练材料，会显著提升模型效果，影响远大于其他因素。更神奇的是，不同的模型拿同样的语料训练，最后的表现居然很接近。 &lt;a class=&#34;link&#34; href=&#34;https://www.ruanyifeng.com/blog/2024/05/weekly-issue-299.html#WCREFX-3748421&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;很多玩家喜欢超频 CPU，越快越好。但是，到达物理极限后，就很难突破。用了整整15年，世界纪录才从 8G Hz 提高到 9G Hz。 &lt;a class=&#34;link&#34; href=&#34;https://www.ruanyifeng.com/blog/2024/05/weekly-issue-299.html#WCREFX-3748471&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;全文剪藏&#34;&gt;全文剪藏&lt;/h2&gt;
</description>
        </item>
        
    </channel>
</rss>
