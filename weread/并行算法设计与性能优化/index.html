<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="元数据 [!abstract] 并行算法设计与性能优化\n书名： 并行算法设计与性能优化 作者： 刘文志 著 简介： 并行计算领域著名专家撰写，百度深度学习研究院“杰出科学家”吴韧鼎力推荐。结合大量示例和伪代码，全面讲解通过并行算法设计实现单核/多核代码、GPU和处理器的性能优化与并行化秘技，并首次提出实现复杂度的全新度量标准。 出版时间 2015-05-01 00:00:00 ISBN： 9787111501022 分类： 计算机-编程设计 出版社： 机械工业出版社 PC地址：https://weread.qq.com/web/reader/b4d329c0597df9b4d745d2a 高亮划线 封面 版权信息 前言 📌 第5章简单介绍了指令级依赖和循环级依赖，并给出许多如何去除依赖的示例，最后以简单介绍处理器硬件支持的寄存器重命名结束。 ^622073-3-5140-5206\n">
<title></title>

<link rel='canonical' href='https://blog.bugxch.top/weread/%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/'>

<link rel="stylesheet" href="/scss/style.min.abbd69b2908fdfcd5179898beaafd374514a86538d81639ddd2c58c06ae54e40.css"><meta property='og:title' content="">
<meta property='og:description' content="元数据 [!abstract] 并行算法设计与性能优化\n书名： 并行算法设计与性能优化 作者： 刘文志 著 简介： 并行计算领域著名专家撰写，百度深度学习研究院“杰出科学家”吴韧鼎力推荐。结合大量示例和伪代码，全面讲解通过并行算法设计实现单核/多核代码、GPU和处理器的性能优化与并行化秘技，并首次提出实现复杂度的全新度量标准。 出版时间 2015-05-01 00:00:00 ISBN： 9787111501022 分类： 计算机-编程设计 出版社： 机械工业出版社 PC地址：https://weread.qq.com/web/reader/b4d329c0597df9b4d745d2a 高亮划线 封面 版权信息 前言 📌 第5章简单介绍了指令级依赖和循环级依赖，并给出许多如何去除依赖的示例，最后以简单介绍处理器硬件支持的寄存器重命名结束。 ^622073-3-5140-5206\n">
<meta property='og:url' content='https://blog.bugxch.top/weread/%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/'>
<meta property='og:site_name' content='巴巴变的博客'>
<meta property='og:type' content='article'><meta property='article:section' content='Weread' />
<meta name="twitter:title" content="">
<meta name="twitter:description" content="元数据 [!abstract] 并行算法设计与性能优化\n书名： 并行算法设计与性能优化 作者： 刘文志 著 简介： 并行计算领域著名专家撰写，百度深度学习研究院“杰出科学家”吴韧鼎力推荐。结合大量示例和伪代码，全面讲解通过并行算法设计实现单核/多核代码、GPU和处理器的性能优化与并行化秘技，并首次提出实现复杂度的全新度量标准。 出版时间 2015-05-01 00:00:00 ISBN： 9787111501022 分类： 计算机-编程设计 出版社： 机械工业出版社 PC地址：https://weread.qq.com/web/reader/b4d329c0597df9b4d745d2a 高亮划线 封面 版权信息 前言 📌 第5章简单介绍了指令级依赖和循环级依赖，并给出许多如何去除依赖的示例，最后以简单介绍处理器硬件支持的寄存器重命名结束。 ^622073-3-5140-5206\n">
    <link rel="shortcut icon" href="/favicon.ico" />
<style>
    :root {
      --sys-font-family: "Noto Serif SC";
      --zh-font-family: "Noto Serif SC";
      --base-font-family: "Noto Serif SC";
      --code-font-family: "Noto Serif SC";
      --article-font-family: "Noto Serif SC";
    }
  </style>
  
  <script>
    (function () {
      const customFont = document.createElement("link");
      customFont.href =
        "https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap";
  
      customFont.type = "text/css";
      customFont.rel = "stylesheet";
  
      document.head.appendChild(customFont);
    })();
  </script>
  
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu14538652356626499973.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">巴巴变的博客</a></h1>
            <h2 class="site-description">平凡的生活也值得记录</h2>
        </div>
    </header><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E6%94%B6%E9%9B%86/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>收集</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#封面">封面</a></li>
    <li><a href="#版权信息">版权信息</a></li>
    <li><a href="#前言">前言</a></li>
    <li><a href="#第1章-绪论">第1章 绪论</a>
      <ol>
        <li><a href="#11-并行和向量化的作用">1.1 并行和向量化的作用</a></li>
        <li><a href="#12-为什么要并行或向量化">1.2 为什么要并行或向量化</a></li>
        <li><a href="#13-为什么向量化或并行难">1.3 为什么向量化或并行难</a></li>
        <li><a href="#14-并行的替代方法">1.4 并行的替代方法</a></li>
        <li><a href="#15-进程线程与处理器">1.5 进程、线程与处理器</a></li>
        <li><a href="#16-并行硬件平台">1.6 并行硬件平台</a></li>
        <li><a href="#17-向量化和多核技术不是万能的">1.7 向量化和多核技术不是万能的</a></li>
        <li><a href="#18-本章小结">1.8 本章小结</a></li>
      </ol>
    </li>
    <li><a href="#第2章-现代处理器特性">第2章 现代处理器特性</a>
      <ol>
        <li><a href="#21-指令级并行">2.1 指令级并行</a></li>
        <li><a href="#22-向量化并行">2.2 向量化并行</a></li>
        <li><a href="#23-线程级并行">2.3 线程级并行</a></li>
        <li><a href="#24-缓存">2.4 缓存</a></li>
        <li><a href="#25-虚拟存储器和tlb">2.5 虚拟存储器和TLB</a></li>
        <li><a href="#26-numa技术">2.6 NUMA技术</a></li>
        <li><a href="#27-本章小结">2.7 本章小结</a></li>
      </ol>
    </li>
    <li><a href="#第3章-算法性能和程序性能的度量与分析">第3章 算法性能和程序性能的度量与分析</a>
      <ol>
        <li><a href="#31-算法分析的性能度量标准">3.1 算法分析的性能度量标准</a></li>
        <li><a href="#32-程序和指令的性能度量标准">3.2 程序和指令的性能度量标准</a></li>
        <li><a href="#33-程序性能优化的度量标准">3.3 程序性能优化的度量标准</a></li>
        <li><a href="#34-程序性能分析实用工具">3.4 程序性能分析实用工具</a></li>
        <li><a href="#35-本章小结">3.5 本章小结</a></li>
      </ol>
    </li>
    <li><a href="#第4章-串行代码性能优化">第4章 串行代码性能优化</a>
      <ol>
        <li><a href="#41-系统级别">4.1 系统级别</a></li>
        <li><a href="#42-应用级别">4.2 应用级别</a></li>
        <li><a href="#43-算法级别">4.3 算法级别</a></li>
        <li><a href="#44-函数级别">4.4 函数级别</a></li>
        <li><a href="#45-循环级别">4.5 循环级别</a></li>
        <li><a href="#46-语句级别">4.6 语句级别</a></li>
        <li><a href="#47-指令级别">4.7 指令级别</a></li>
        <li><a href="#48-本章小结">4.8 本章小结</a></li>
      </ol>
    </li>
    <li><a href="#第5章-依赖分析">第5章 依赖分析</a>
      <ol>
        <li><a href="#51-指令级依赖">5.1 指令级依赖</a></li>
        <li><a href="#52-循环级依赖">5.2 循环级依赖</a></li>
        <li><a href="#53-寄存器重命名">5.3 寄存器重命名</a></li>
        <li><a href="#54-本章小结">5.4 本章小结</a></li>
      </ol>
    </li>
    <li><a href="#第6章-并行编程模型及环境">第6章 并行编程模型及环境</a>
      <ol>
        <li><a href="#61-并行编程模型">6.1 并行编程模型</a></li>
        <li><a href="#62-常见并行编程环境">6.2 常见并行编程环境</a></li>
        <li><a href="#63-本章小结">6.3 本章小结</a></li>
      </ol>
    </li>
    <li><a href="#第7章-并行算法设计方法">第7章 并行算法设计方法</a>
      <ol>
        <li><a href="#71-划分">7.1 划分</a></li>
        <li><a href="#72-通信">7.2 通信</a></li>
        <li><a href="#73-结果归并">7.3 结果归并</a></li>
        <li><a href="#74-负载均衡">7.4 负载均衡</a></li>
        <li><a href="#75-本章小结">7.5 本章小结</a></li>
      </ol>
    </li>
    <li><a href="#第8章-并行算法缺陷">第8章 并行算法缺陷</a>
      <ol>
        <li><a href="#81-启动结束时间">8.1 启动结束时间</a></li>
        <li><a href="#82-负载均衡">8.2 负载均衡</a></li>
        <li><a href="#83-竞写">8.3 竞写</a></li>
        <li><a href="#84-锁">8.4 锁</a></li>
        <li><a href="#85-饿死">8.5 饿死</a></li>
        <li><a href="#86-伪共享">8.6 伪共享</a></li>
        <li><a href="#87-原子操作">8.7 原子操作</a></li>
        <li><a href="#88-存储器栅栏">8.8 存储器栅栏</a></li>
        <li><a href="#89-缓存一致性">8.9 缓存一致性</a></li>
        <li><a href="#810-顺序一致性">8.10 顺序一致性</a></li>
        <li><a href="#811-volatile同步错误">8.11 volatile同步错误</a></li>
        <li><a href="#812-本章小结">8.12 本章小结</a></li>
      </ol>
    </li>
    <li><a href="#第9章-并行编程模式实践">第9章 并行编程模式实践</a>
      <ol>
        <li><a href="#91-map模式">9.1 map模式</a></li>
        <li><a href="#92-reduce模式">9.2 reduce模式</a></li>
        <li><a href="#93-结合map和reduce模式">9.3 结合map和reduce模式</a></li>
        <li><a href="#94-scan模式">9.4 scan模式</a></li>
        <li><a href="#95-zipunzip模式">9.5 zip/unzip模式</a></li>
        <li><a href="#96-流水线模式">9.6 流水线模式</a></li>
        <li><a href="#97-本章小结">9.7 本章小结</a></li>
      </ol>
    </li>
    <li><a href="#第10章-如何并行遗留代码">第10章 如何并行遗留代码</a>
      <ol>
        <li><a href="#101-找出软件的计算热点">10.1 找出软件的计算热点</a></li>
        <li><a href="#102-判断是否并行化热点">10.2 判断是否并行化热点</a></li>
        <li><a href="#103-设计算法并实现">10.3 设计算法并实现</a></li>
        <li><a href="#104-将实现后的代码嵌入原软件">10.4 将实现后的代码嵌入原软件</a></li>
        <li><a href="#105-示例如何并行化word2vec">10.5 示例：如何并行化word2vec</a></li>
        <li><a href="#106-本章小结">10.6 本章小结</a></li>
      </ol>
    </li>
    <li><a href="#第11章-超级并行">第11章 超级并行</a>
      <ol>
        <li><a href="#111-超级并行方式编程">11.1 超级并行方式编程</a></li>
        <li><a href="#112-矩阵乘法">11.2 矩阵乘法</a></li>
        <li><a href="#113-本章小结">11.3 本章小结</a></li>
      </ol>
    </li>
    <li><a href="#第12章-并行算法设计的一般准则">第12章 并行算法设计的一般准则</a>
      <ol>
        <li><a href="#121-并行算法设计14准则">12.1 并行算法设计14准则</a></li>
        <li><a href="#122-本章小结">12.2 本章小结</a></li>
      </ol>
    </li>
    <li><a href="#附录a-整型数据与浮点数据">附录A 整型数据与浮点数据</a></li>
  </ol>

  <ol>
    <li><a href="#前言-1">前言</a>
      <ol>
        <li><a href="#划线评论">划线评论</a></li>
        <li><a href="#划线评论-1">划线评论</a></li>
      </ol>
    </li>
    <li><a href="#12-为什么要并行或向量化-1">1.2 为什么要并行或向量化</a>
      <ol>
        <li><a href="#划线评论-2">划线评论</a></li>
        <li><a href="#划线评论-3">划线评论</a></li>
      </ol>
    </li>
    <li><a href="#16-并行硬件平台-1">1.6 并行硬件平台</a>
      <ol>
        <li><a href="#划线评论-4">划线评论</a></li>
      </ol>
    </li>
    <li><a href="#17-向量化和多核技术不是万能的-1">1.7 向量化和多核技术不是万能的</a>
      <ol>
        <li><a href="#划线评论-5">划线评论</a></li>
      </ol>
    </li>
    <li><a href="#21-指令级并行-1">2.1 指令级并行</a>
      <ol>
        <li><a href="#划线评论-6">划线评论</a></li>
        <li><a href="#划线评论-7">划线评论</a></li>
      </ol>
    </li>
    <li><a href="#22-向量化并行-1">2.2 向量化并行</a>
      <ol>
        <li><a href="#划线评论-8">划线评论</a></li>
        <li><a href="#划线评论-9">划线评论</a></li>
      </ol>
    </li>
    <li><a href="#24-缓存-1">2.4 缓存</a>
      <ol>
        <li><a href="#划线评论-10">划线评论</a></li>
        <li><a href="#划线评论-11">划线评论</a></li>
        <li><a href="#划线评论-12">划线评论</a></li>
        <li><a href="#划线评论-13">划线评论</a></li>
      </ol>
    </li>
    <li><a href="#25-虚拟存储器和tlb-1">2.5 虚拟存储器和TLB</a>
      <ol>
        <li><a href="#划线评论-14">划线评论</a></li>
        <li><a href="#划线评论-15">划线评论</a></li>
      </ol>
    </li>
    <li><a href="#31-算法分析的性能度量标准-1">3.1 算法分析的性能度量标准</a>
      <ol>
        <li><a href="#划线评论-16">划线评论</a></li>
        <li><a href="#划线评论-17">划线评论</a></li>
        <li><a href="#划线评论-18">划线评论</a></li>
        <li><a href="#划线评论-19">划线评论</a></li>
        <li><a href="#划线评论-20">划线评论</a></li>
        <li><a href="#划线评论-21">划线评论</a></li>
        <li><a href="#划线评论-22">划线评论</a></li>
      </ol>
    </li>
    <li><a href="#32-程序和指令的性能度量标准-1">3.2 程序和指令的性能度量标准</a>
      <ol>
        <li><a href="#划线评论-23">划线评论</a></li>
        <li><a href="#划线评论-24">划线评论</a></li>
        <li><a href="#划线评论-25">划线评论</a></li>
        <li><a href="#划线评论-26">划线评论</a></li>
        <li><a href="#划线评论-27">划线评论</a></li>
        <li><a href="#划线评论-28">划线评论</a></li>
        <li><a href="#划线评论-29">划线评论</a></li>
        <li><a href="#划线评论-30">划线评论</a></li>
      </ol>
    </li>
    <li><a href="#42-应用级别-1">4.2 应用级别</a>
      <ol>
        <li><a href="#划线评论-31">划线评论</a></li>
        <li><a href="#划线评论-32">划线评论</a></li>
      </ol>
    </li>
    <li><a href="#43-算法级别-1">4.3 算法级别</a>
      <ol>
        <li><a href="#划线评论-33">划线评论</a></li>
        <li><a href="#划线评论-34">划线评论</a></li>
      </ol>
    </li>
    <li><a href="#44-函数级别-1">4.4 函数级别</a>
      <ol>
        <li><a href="#划线评论-35">划线评论</a></li>
      </ol>
    </li>
    <li><a href="#45-循环级别-1">4.5 循环级别</a>
      <ol>
        <li><a href="#划线评论-36">划线评论</a></li>
        <li><a href="#划线评论-37">划线评论</a></li>
        <li><a href="#划线评论-38">划线评论</a></li>
      </ol>
    </li>
    <li><a href="#46-语句级别-1">4.6 语句级别</a>
      <ol>
        <li><a href="#划线评论-39">划线评论</a></li>
      </ol>
    </li>
    <li><a href="#47-指令级别-1">4.7 指令级别</a>
      <ol>
        <li><a href="#划线评论-40">划线评论</a></li>
      </ol>
    </li>
    <li><a href="#51-指令级依赖-1">5.1 指令级依赖</a>
      <ol>
        <li><a href="#划线评论-41">划线评论</a></li>
        <li><a href="#划线评论-42">划线评论</a></li>
        <li><a href="#划线评论-43">划线评论</a></li>
      </ol>
    </li>
    <li><a href="#53-寄存器重命名-1">5.3 寄存器重命名</a>
      <ol>
        <li><a href="#划线评论-44">划线评论</a></li>
        <li><a href="#划线评论-45">划线评论</a></li>
        <li><a href="#划线评论-46">划线评论</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/weread/%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"></a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 18 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="元数据"><a href="#%e5%85%83%e6%95%b0%e6%8d%ae" class="header-anchor"></a>元数据
</h1><blockquote>
<p>[!abstract] 并行算法设计与性能优化</p>
<ul>
<li><img src="https://wfqqreader-1252317822.image.myqcloud.com/cover/73/622073/t7_622073.jpg"
	
	
	
	loading="lazy"
	
		alt=" 并行算法设计与性能优化|200"
	
	
></li>
<li>书名： 并行算法设计与性能优化</li>
<li>作者： 刘文志 著</li>
<li>简介： 并行计算领域著名专家撰写，百度深度学习研究院“杰出科学家”吴韧鼎力推荐。结合大量示例和伪代码，全面讲解通过并行算法设计实现单核/多核代码、GPU和处理器的性能优化与并行化秘技，并首次提出实现复杂度的全新度量标准。</li>
<li>出版时间 2015-05-01 00:00:00</li>
<li>ISBN： 9787111501022</li>
<li>分类： 计算机-编程设计</li>
<li>出版社： 机械工业出版社</li>
<li>PC地址：https://weread.qq.com/web/reader/b4d329c0597df9b4d745d2a</li>
</ul>
</blockquote>
<h1 id="高亮划线"><a href="#%e9%ab%98%e4%ba%ae%e5%88%92%e7%ba%bf" class="header-anchor"></a>高亮划线
</h1><h2 id="封面"><a href="#%e5%b0%81%e9%9d%a2" class="header-anchor"></a>封面
</h2><h2 id="版权信息"><a href="#%e7%89%88%e6%9d%83%e4%bf%a1%e6%81%af" class="header-anchor"></a>版权信息
</h2><h2 id="前言"><a href="#%e5%89%8d%e8%a8%80" class="header-anchor"></a>前言
</h2><blockquote>
<p>📌  第5章简单介绍了指令级依赖和循环级依赖，并给出许多如何去除依赖的示例，最后以简单介绍处理器硬件支持的寄存器重命名结束。 ^622073-3-5140-5206</p>
</blockquote>
<ul>
<li>💭 比较重要 - ⏱ 2024-03-24 13:33:10</li>
</ul>
<h2 id="第1章-绪论"><a href="#%e7%ac%ac1%e7%ab%a0-%e7%bb%aa%e8%ae%ba" class="header-anchor"></a>第1章 绪论
</h2><h3 id="11-并行和向量化的作用"><a href="#11-%e5%b9%b6%e8%a1%8c%e5%92%8c%e5%90%91%e9%87%8f%e5%8c%96%e7%9a%84%e4%bd%9c%e7%94%a8" class="header-anchor"></a>1.1 并行和向量化的作用
</h3><h3 id="12-为什么要并行或向量化"><a href="#12-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%b9%b6%e8%a1%8c%e6%88%96%e5%90%91%e9%87%8f%e5%8c%96" class="header-anchor"></a>1.2 为什么要并行或向量化
</h3><h3 id="13-为什么向量化或并行难"><a href="#13-%e4%b8%ba%e4%bb%80%e4%b9%88%e5%90%91%e9%87%8f%e5%8c%96%e6%88%96%e5%b9%b6%e8%a1%8c%e9%9a%be" class="header-anchor"></a>1.3 为什么向量化或并行难
</h3><blockquote>
<p>📌 任务/数据划分：并行意味着多个控制流同时执行，而向量化意味着同时操作多个数据，并行需要在各个控制流之间划分任务和数据并去除依赖，向量化则需要处理向量内要处理的数据的依赖关系。数据/任务的划分方式不但决定了编程时的难易程度，而且划分带来的负载均衡和通信问题往往也会对程序的最终性能产生决定性的影响。
⏱ 2024-03-24 13:38:38 ^622073-7-1370-1518</p>
</blockquote>
<blockquote>
<p>📌 可扩展性的问题基本上没有解决办法，因为开发人员不能完全正确地预测在目前还不存在的硬件上发生的事情。通常的缓解方法是要求在开发项目时，留下足够的设计文档，使源码有足够的、准确的注释。这样在核心数增多可扩展性出现问题时，开发人员能够尽快定位问题，找到可能的解决办法。
⏱ 2024-03-24 13:44:00 ^622073-7-3508-3639</p>
</blockquote>
<blockquote>
<p>📌 只能自动向量化一些简单的代码，即使能自动向量化代码，通常也不是最优的；·只能自动并行化简单代码，编译器在自动并行化方面做得通常比自动向量化还要差；·不能找出并行冲突的地方；·不能协调资源访问。
⏱ 2024-03-24 13:46:13 ^622073-7-6501-6690</p>
</blockquote>
<h3 id="14-并行的替代方法"><a href="#14-%e5%b9%b6%e8%a1%8c%e7%9a%84%e6%9b%bf%e4%bb%a3%e6%96%b9%e6%b3%95" class="header-anchor"></a>1.4 并行的替代方法
</h3><h3 id="15-进程线程与处理器"><a href="#15-%e8%bf%9b%e7%a8%8b%e7%ba%bf%e7%a8%8b%e4%b8%8e%e5%a4%84%e7%90%86%e5%99%a8" class="header-anchor"></a>1.5 进程、线程与处理器
</h3><h3 id="16-并行硬件平台"><a href="#16-%e5%b9%b6%e8%a1%8c%e7%a1%ac%e4%bb%b6%e5%b9%b3%e5%8f%b0" class="header-anchor"></a>1.6 并行硬件平台
</h3><blockquote>
<p>📌 GPU是为了渲染大量像素而设计的，并不关心某个像素的处理时间，而关注单位时间内能够处理的像素数量，因此带宽比延迟更重要。考虑到渲染的大量像素之间通常并不相关，因此GPU将大量的晶体管用于并行计算，故在同样数目的晶体管上，具有比CPU更高的计算能力。
⏱ 2024-03-24 17:25:33 ^622073-10-4538-4662</p>
</blockquote>
<blockquote>
<p>📌 由于GPU将更大比例的晶体管用于计算，相对来说用于缓存的比例就比CPU小，因此通常局部性满足CPU要求而不满足GPU要求的应用不适合GPU。由于GPU通过大量线程的并行来隐藏访存延迟，一些数据局部性非常差的应用反而能够在GPU上获得很好的收益。另外一些计算访存比低的应用在GPU上很难获得非常高的性能收益，但是这并不意味着在GPU实现会比在CPU上实现差。CPU+GPU异构计算需要在GPU和CPU之间传输数据，而这个带宽比内存的访问带宽还要小，因此那种需要在GPU和CPU之间进行大量、频繁数据交互的解决方案可能不适合在GPU上实现。
⏱ 2024-03-24 17:27:35 ^622073-10-4872-5140</p>
</blockquote>
<blockquote>
<p>📌 ARM支持的向量指令集称为NEON。NEON具有16个长度为128位的向量寄存器（这些寄存器以q开头，也可表示为32个64位寄存器，以d开头），可同时操作向量寄存器的16个字节，因此使用向量指令可获得更高的性能和带宽。
⏱ 2024-03-24 17:28:17 ^622073-10-5473-5582</p>
</blockquote>
<h3 id="17-向量化和多核技术不是万能的"><a href="#17-%e5%90%91%e9%87%8f%e5%8c%96%e5%92%8c%e5%a4%9a%e6%a0%b8%e6%8a%80%e6%9c%af%e4%b8%8d%e6%98%af%e4%b8%87%e8%83%bd%e7%9a%84" class="header-anchor"></a>1.7 向量化和多核技术不是万能的
</h3><blockquote>
<p>📌  对于软件开发人员来说，一些问题很容易向量化和并行，但是也有一些不行；有些问题适合向量化和并行，但是程序却不容易编写。很难将算法划分为几百、几千个控制流，因为人脑很难维护这些控制流的状态空间。实际上自动向量化和自动并行化是解决这些问题的首选（软件开发人员编写串行代码，编译器或硬件给多个处理器有效地分发指令），但是现在的自动向量化和自动并行化工具仍旧非常弱。 ^622073-11-942-1120</p>
</blockquote>
<ul>
<li>💭 编译器是未来 - ⏱ 2024-03-24 17:29:37</li>
</ul>
<h3 id="18-本章小结"><a href="#18-%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93" class="header-anchor"></a>1.8 本章小结
</h3><h2 id="第2章-现代处理器特性"><a href="#%e7%ac%ac2%e7%ab%a0-%e7%8e%b0%e4%bb%a3%e5%a4%84%e7%90%86%e5%99%a8%e7%89%b9%e6%80%a7" class="header-anchor"></a>第2章 现代处理器特性
</h2><blockquote>
<p>📌 处理器的处理速度远快于内存读写速度，为了减少访问数据时的延迟，现代主流处理器主要采用了两种方式：·利用程序的局部性特点，采用了一系列小而快的缓存以保存正在访问和将要被访问的数据，以近似于内存的价格获得近似于缓存的速度；·利用并行性，在一个控制流由于高延迟的操作而阻塞时，执行另一个控制流。
⏱ 2024-03-24 17:31:03 ^622073-13-790-996</p>
</blockquote>
<h3 id="21-指令级并行"><a href="#21-%e6%8c%87%e4%bb%a4%e7%ba%a7%e5%b9%b6%e8%a1%8c" class="header-anchor"></a>2.1 指令级并行
</h3><blockquote>
<p>📌 乱序执行会重排指令的执行顺序，这要求处理器的发射能力大于其执行能力。如果处理器的发射能力和指令的执行能力一致，那么ROB中就不会有指令等待重新排列执行顺序。由于处理器执行不同指令的速度并不相同，因此其发射能力并不一定比执行最快的指令的吞吐量大，比如主流X86 CPU一个周期能够处理4条整数加法指令，但是其指令发射能力也是一个周期4条。
⏱ 2024-03-24 18:07:07 ^622073-14-2407-2575</p>
</blockquote>
<h3 id="22-向量化并行"><a href="#22-%e5%90%91%e9%87%8f%e5%8c%96%e5%b9%b6%e8%a1%8c" class="header-anchor"></a>2.2 向量化并行
</h3><h3 id="23-线程级并行"><a href="#23-%e7%ba%bf%e7%a8%8b%e7%ba%a7%e5%b9%b6%e8%a1%8c" class="header-anchor"></a>2.3 线程级并行
</h3><blockquote>
<p>📌 ·锁：在单核上，多个线程执行锁或者临界区时，实际上只有一个线程在执行临界区代码，而核心也只支持一个线程执行，因此不存在冲突。如果某个线程持有锁，那么只是其他线程不会被调度到CPU上执行，影响的只是持有和释放锁的时间，处理器时刻在运行着。但是在多核上运行时，锁或临界区会导致其余处理器空闲而只允许一个处理器执行持有锁的那个线程，这是一个串行的过程，会影响性能。</p>
</blockquote>
<p>·负载均衡：在单核上不用考虑负载均衡，因为各个线程轮流执行，当一个线程执行完时，便会执行另一个线程，不存在线程等待问题。</p>
<blockquote>
<p>⏱ 2024-03-24 18:26:06 ^622073-16-3486</p>
</blockquote>
<h3 id="24-缓存"><a href="#24-%e7%bc%93%e5%ad%98" class="header-anchor"></a>2.4 缓存
</h3><h3 id="25-虚拟存储器和tlb"><a href="#25-%e8%99%9a%e6%8b%9f%e5%ad%98%e5%82%a8%e5%99%a8%e5%92%8ctlb" class="header-anchor"></a>2.5 虚拟存储器和TLB
</h3><h3 id="26-numa技术"><a href="#26-numa%e6%8a%80%e6%9c%af" class="header-anchor"></a>2.6 NUMA技术
</h3><h3 id="27-本章小结"><a href="#27-%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93" class="header-anchor"></a>2.7 本章小结
</h3><h2 id="第3章-算法性能和程序性能的度量与分析"><a href="#%e7%ac%ac3%e7%ab%a0-%e7%ae%97%e6%b3%95%e6%80%a7%e8%83%bd%e5%92%8c%e7%a8%8b%e5%ba%8f%e6%80%a7%e8%83%bd%e7%9a%84%e5%ba%a6%e9%87%8f%e4%b8%8e%e5%88%86%e6%9e%90" class="header-anchor"></a>第3章 算法性能和程序性能的度量与分析
</h2><h3 id="31-算法分析的性能度量标准"><a href="#31-%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90%e7%9a%84%e6%80%a7%e8%83%bd%e5%ba%a6%e9%87%8f%e6%a0%87%e5%87%86" class="header-anchor"></a>3.1 算法分析的性能度量标准
</h3><blockquote>
<p>📌 ；从计算机架构的进展来说，目前数据读写越来越成为多核向量处理器性能的瓶颈（内存墙）。这意味着大部分时间花费在访问存储器上面的算法都不适合使用时间复杂度来估计性能，比如上面提到的矩阵加法
⏱ 2024-03-24 20:33:30 ^622073-22-2729-2821</p>
</blockquote>
<h3 id="32-程序和指令的性能度量标准"><a href="#32-%e7%a8%8b%e5%ba%8f%e5%92%8c%e6%8c%87%e4%bb%a4%e7%9a%84%e6%80%a7%e8%83%bd%e5%ba%a6%e9%87%8f%e6%a0%87%e5%87%86" class="header-anchor"></a>3.2 程序和指令的性能度量标准
</h3><h3 id="33-程序性能优化的度量标准"><a href="#33-%e7%a8%8b%e5%ba%8f%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e7%9a%84%e5%ba%a6%e9%87%8f%e6%a0%87%e5%87%86" class="header-anchor"></a>3.3 程序性能优化的度量标准
</h3><h3 id="34-程序性能分析实用工具"><a href="#34-%e7%a8%8b%e5%ba%8f%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e5%ae%9e%e7%94%a8%e5%b7%a5%e5%85%b7" class="header-anchor"></a>3.4 程序性能分析实用工具
</h3><blockquote>
<p>📌 需要注意的是：gprof通过在编译时插入代码来分析程序，因此在一些情况下，其给出的结果会有不准确的地方。</p>
</blockquote>
<p>为了简便起见，本节只简单展示了一下gprof的使用和功能，想了解更多功能的读者可参考gprof手册。</p>
<p>在大多数情况下，gprof适合粗略分析代码的性能瓶颈。程序在硬件平台上实际执行时的详细硬件计数器数据可以通过perf或Intel Vtune获得。</p>
<blockquote>
<p>⏱ 2024-03-25 04:59:17 ^622073-25-2604</p>
</blockquote>
<h3 id="35-本章小结"><a href="#35-%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93" class="header-anchor"></a>3.5 本章小结
</h3><h2 id="第4章-串行代码性能优化"><a href="#%e7%ac%ac4%e7%ab%a0-%e4%b8%b2%e8%a1%8c%e4%bb%a3%e7%a0%81%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96" class="header-anchor"></a>第4章 串行代码性能优化
</h2><h3 id="41-系统级别"><a href="#41-%e7%b3%bb%e7%bb%9f%e7%ba%a7%e5%88%ab" class="header-anchor"></a>4.1 系统级别
</h3><h3 id="42-应用级别"><a href="#42-%e5%ba%94%e7%94%a8%e7%ba%a7%e5%88%ab" class="header-anchor"></a>4.2 应用级别
</h3><h3 id="43-算法级别"><a href="#43-%e7%ae%97%e6%b3%95%e7%ba%a7%e5%88%ab" class="header-anchor"></a>4.3 算法级别
</h3><h3 id="44-函数级别"><a href="#44-%e5%87%bd%e6%95%b0%e7%ba%a7%e5%88%ab" class="header-anchor"></a>4.4 函数级别
</h3><h3 id="45-循环级别"><a href="#45-%e5%be%aa%e7%8e%af%e7%ba%a7%e5%88%ab" class="header-anchor"></a>4.5 循环级别
</h3><h3 id="46-语句级别"><a href="#46-%e8%af%ad%e5%8f%a5%e7%ba%a7%e5%88%ab" class="header-anchor"></a>4.6 语句级别
</h3><blockquote>
<p>📌 声明结构体时，尽量大数据类型在前，小数据类型在后，一方面这样会节省一些空间，另一方面可以更好地满足处理器的对齐要求。
⏱ 2024-03-25 15:37:40 ^622073-33-3063-3121</p>
</blockquote>
<h3 id="47-指令级别"><a href="#47-%e6%8c%87%e4%bb%a4%e7%ba%a7%e5%88%ab" class="header-anchor"></a>4.7 指令级别
</h3><h3 id="48-本章小结"><a href="#48-%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93" class="header-anchor"></a>4.8 本章小结
</h3><h2 id="第5章-依赖分析"><a href="#%e7%ac%ac5%e7%ab%a0-%e4%be%9d%e8%b5%96%e5%88%86%e6%9e%90" class="header-anchor"></a>第5章 依赖分析
</h2><blockquote>
<p>📌 指令级依赖分析是优化流水线性能的基础，而循环级依赖分析则是向量化和数据并行的基础。如果能够确定循环中不存在依赖，那么该循环便可由多个控制流同时执行。细粒度的循环依赖分析可以确定代码是否能够被向量化。
⏱ 2024-03-25 20:33:13 ^622073-36-760-859</p>
</blockquote>
<h3 id="51-指令级依赖"><a href="#51-%e6%8c%87%e4%bb%a4%e7%ba%a7%e4%be%9d%e8%b5%96" class="header-anchor"></a>5.1 指令级依赖
</h3><blockquote>
<p>📌 假设某个处理器上多条L1访问映射到同一条缓存线，那么即使这多个访问没有依赖，也需要串行处理，这就是由缓存的结构导致的依赖。
⏱ 2024-03-26 11:41:44 ^622073-37-1563-1624</p>
</blockquote>
<h3 id="52-循环级依赖"><a href="#52-%e5%be%aa%e7%8e%af%e7%ba%a7%e4%be%9d%e8%b5%96" class="header-anchor"></a>5.2 循环级依赖
</h3><h3 id="53-寄存器重命名"><a href="#53-%e5%af%84%e5%ad%98%e5%99%a8%e9%87%8d%e5%91%bd%e5%90%8d" class="header-anchor"></a>5.3 寄存器重命名
</h3><h3 id="54-本章小结"><a href="#54-%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93" class="header-anchor"></a>5.4 本章小结
</h3><h2 id="第6章-并行编程模型及环境"><a href="#%e7%ac%ac6%e7%ab%a0-%e5%b9%b6%e8%a1%8c%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%9e%8b%e5%8f%8a%e7%8e%af%e5%a2%83" class="header-anchor"></a>第6章 并行编程模型及环境
</h2><h3 id="61-并行编程模型"><a href="#61-%e5%b9%b6%e8%a1%8c%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%9e%8b" class="header-anchor"></a>6.1 并行编程模型
</h3><h3 id="62-常见并行编程环境"><a href="#62-%e5%b8%b8%e8%a7%81%e5%b9%b6%e8%a1%8c%e7%bc%96%e7%a8%8b%e7%8e%af%e5%a2%83" class="header-anchor"></a>6.2 常见并行编程环境
</h3><h3 id="63-本章小结"><a href="#63-%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93" class="header-anchor"></a>6.3 本章小结
</h3><h2 id="第7章-并行算法设计方法"><a href="#%e7%ac%ac7%e7%ab%a0-%e5%b9%b6%e8%a1%8c%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%e6%96%b9%e6%b3%95" class="header-anchor"></a>第7章 并行算法设计方法
</h2><h3 id="71-划分"><a href="#71-%e5%88%92%e5%88%86" class="header-anchor"></a>7.1 划分
</h3><h3 id="72-通信"><a href="#72-%e9%80%9a%e4%bf%a1" class="header-anchor"></a>7.2 通信
</h3><h3 id="73-结果归并"><a href="#73-%e7%bb%93%e6%9e%9c%e5%bd%92%e5%b9%b6" class="header-anchor"></a>7.3 结果归并
</h3><h3 id="74-负载均衡"><a href="#74-%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" class="header-anchor"></a>7.4 负载均衡
</h3><h3 id="75-本章小结"><a href="#75-%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93" class="header-anchor"></a>7.5 本章小结
</h3><h2 id="第8章-并行算法缺陷"><a href="#%e7%ac%ac8%e7%ab%a0-%e5%b9%b6%e8%a1%8c%e7%ae%97%e6%b3%95%e7%bc%ba%e9%99%b7" class="header-anchor"></a>第8章 并行算法缺陷
</h2><h3 id="81-启动结束时间"><a href="#81-%e5%90%af%e5%8a%a8%e7%bb%93%e6%9d%9f%e6%97%b6%e9%97%b4" class="header-anchor"></a>8.1 启动结束时间
</h3><h3 id="82-负载均衡"><a href="#82-%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" class="header-anchor"></a>8.2 负载均衡
</h3><h3 id="83-竞写"><a href="#83-%e7%ab%9e%e5%86%99" class="header-anchor"></a>8.3 竞写
</h3><h3 id="84-锁"><a href="#84-%e9%94%81" class="header-anchor"></a>8.4 锁
</h3><h3 id="85-饿死"><a href="#85-%e9%a5%bf%e6%ad%bb" class="header-anchor"></a>8.5 饿死
</h3><h3 id="86-伪共享"><a href="#86-%e4%bc%aa%e5%85%b1%e4%ba%ab" class="header-anchor"></a>8.6 伪共享
</h3><h3 id="87-原子操作"><a href="#87-%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c" class="header-anchor"></a>8.7 原子操作
</h3><h3 id="88-存储器栅栏"><a href="#88-%e5%ad%98%e5%82%a8%e5%99%a8%e6%a0%85%e6%a0%8f" class="header-anchor"></a>8.8 存储器栅栏
</h3><h3 id="89-缓存一致性"><a href="#89-%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7" class="header-anchor"></a>8.9 缓存一致性
</h3><h3 id="810-顺序一致性"><a href="#810-%e9%a1%ba%e5%ba%8f%e4%b8%80%e8%87%b4%e6%80%a7" class="header-anchor"></a>8.10 顺序一致性
</h3><h3 id="811-volatile同步错误"><a href="#811-volatile%e5%90%8c%e6%ad%a5%e9%94%99%e8%af%af" class="header-anchor"></a>8.11 volatile同步错误
</h3><h3 id="812-本章小结"><a href="#812-%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93" class="header-anchor"></a>8.12 本章小结
</h3><h2 id="第9章-并行编程模式实践"><a href="#%e7%ac%ac9%e7%ab%a0-%e5%b9%b6%e8%a1%8c%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%bc%8f%e5%ae%9e%e8%b7%b5" class="header-anchor"></a>第9章 并行编程模式实践
</h2><h3 id="91-map模式"><a href="#91-map%e6%a8%a1%e5%bc%8f" class="header-anchor"></a>9.1 map模式
</h3><h3 id="92-reduce模式"><a href="#92-reduce%e6%a8%a1%e5%bc%8f" class="header-anchor"></a>9.2 reduce模式
</h3><h3 id="93-结合map和reduce模式"><a href="#93-%e7%bb%93%e5%90%88map%e5%92%8creduce%e6%a8%a1%e5%bc%8f" class="header-anchor"></a>9.3 结合map和reduce模式
</h3><h3 id="94-scan模式"><a href="#94-scan%e6%a8%a1%e5%bc%8f" class="header-anchor"></a>9.4 scan模式
</h3><h3 id="95-zipunzip模式"><a href="#95-zipunzip%e6%a8%a1%e5%bc%8f" class="header-anchor"></a>9.5 zip/unzip模式
</h3><h3 id="96-流水线模式"><a href="#96-%e6%b5%81%e6%b0%b4%e7%ba%bf%e6%a8%a1%e5%bc%8f" class="header-anchor"></a>9.6 流水线模式
</h3><h3 id="97-本章小结"><a href="#97-%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93" class="header-anchor"></a>9.7 本章小结
</h3><h2 id="第10章-如何并行遗留代码"><a href="#%e7%ac%ac10%e7%ab%a0-%e5%a6%82%e4%bd%95%e5%b9%b6%e8%a1%8c%e9%81%97%e7%95%99%e4%bb%a3%e7%a0%81" class="header-anchor"></a>第10章 如何并行遗留代码
</h2><h3 id="101-找出软件的计算热点"><a href="#101-%e6%89%be%e5%87%ba%e8%bd%af%e4%bb%b6%e7%9a%84%e8%ae%a1%e7%ae%97%e7%83%ad%e7%82%b9" class="header-anchor"></a>10.1 找出软件的计算热点
</h3><h3 id="102-判断是否并行化热点"><a href="#102-%e5%88%a4%e6%96%ad%e6%98%af%e5%90%a6%e5%b9%b6%e8%a1%8c%e5%8c%96%e7%83%ad%e7%82%b9" class="header-anchor"></a>10.2 判断是否并行化热点
</h3><h3 id="103-设计算法并实现"><a href="#103-%e8%ae%be%e8%ae%a1%e7%ae%97%e6%b3%95%e5%b9%b6%e5%ae%9e%e7%8e%b0" class="header-anchor"></a>10.3 设计算法并实现
</h3><h3 id="104-将实现后的代码嵌入原软件"><a href="#104-%e5%b0%86%e5%ae%9e%e7%8e%b0%e5%90%8e%e7%9a%84%e4%bb%a3%e7%a0%81%e5%b5%8c%e5%85%a5%e5%8e%9f%e8%bd%af%e4%bb%b6" class="header-anchor"></a>10.4 将实现后的代码嵌入原软件
</h3><h3 id="105-示例如何并行化word2vec"><a href="#105-%e7%a4%ba%e4%be%8b%e5%a6%82%e4%bd%95%e5%b9%b6%e8%a1%8c%e5%8c%96word2vec" class="header-anchor"></a>10.5 示例：如何并行化word2vec
</h3><h3 id="106-本章小结"><a href="#106-%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93" class="header-anchor"></a>10.6 本章小结
</h3><h2 id="第11章-超级并行"><a href="#%e7%ac%ac11%e7%ab%a0-%e8%b6%85%e7%ba%a7%e5%b9%b6%e8%a1%8c" class="header-anchor"></a>第11章 超级并行
</h2><h3 id="111-超级并行方式编程"><a href="#111-%e8%b6%85%e7%ba%a7%e5%b9%b6%e8%a1%8c%e6%96%b9%e5%bc%8f%e7%bc%96%e7%a8%8b" class="header-anchor"></a>11.1 超级并行方式编程
</h3><h3 id="112-矩阵乘法"><a href="#112-%e7%9f%a9%e9%98%b5%e4%b9%98%e6%b3%95" class="header-anchor"></a>11.2 矩阵乘法
</h3><h3 id="113-本章小结"><a href="#113-%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93" class="header-anchor"></a>11.3 本章小结
</h3><h2 id="第12章-并行算法设计的一般准则"><a href="#%e7%ac%ac12%e7%ab%a0-%e5%b9%b6%e8%a1%8c%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%e7%9a%84%e4%b8%80%e8%88%ac%e5%87%86%e5%88%99" class="header-anchor"></a>第12章 并行算法设计的一般准则
</h2><h3 id="121-并行算法设计14准则"><a href="#121-%e5%b9%b6%e8%a1%8c%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a114%e5%87%86%e5%88%99" class="header-anchor"></a>12.1 并行算法设计14准则
</h3><h3 id="122-本章小结"><a href="#122-%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93" class="header-anchor"></a>12.2 本章小结
</h3><h2 id="附录a-整型数据与浮点数据"><a href="#%e9%99%84%e5%bd%95a-%e6%95%b4%e5%9e%8b%e6%95%b0%e6%8d%ae%e4%b8%8e%e6%b5%ae%e7%82%b9%e6%95%b0%e6%8d%ae" class="header-anchor"></a>附录A 整型数据与浮点数据
</h2><h1 id="读书笔记"><a href="#%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0" class="header-anchor"></a>读书笔记
</h1><h2 id="前言-1"><a href="#%e5%89%8d%e8%a8%80-1" class="header-anchor"></a>前言
</h2><h3 id="划线评论"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 代码性能优化和并行技术被许多顶级开发人员看成“不传之秘”或“只可意会，不可言传”的技术。本书将会把这些“不传之秘”一一展示在开发者面前，并且解释为什么。由于代码性能的具体细节非常难以解释清楚，笔者尽量在高层解释，避免陷入细节里。在写作此书时，我并没有查到世界上有类似的写给普通开发者的书籍，本书可算是第一本  ^6733360-7PVEHFsQJ
- 💭 略牛
- ⏱ 2024-03-24 13:26:28</p>
</blockquote>
<h3 id="划线评论-1"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-1" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 第5章简单介绍了指令级依赖和循环级依赖，并给出许多如何去除依赖的示例，最后以简单介绍处理器硬件支持的寄存器重命名结束。  ^6733360-7PVF9fitA
- 💭 比较重要
- ⏱ 2024-03-24 13:33:15</p>
</blockquote>
<h2 id="12-为什么要并行或向量化-1"><a href="#12-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%b9%b6%e8%a1%8c%e6%88%96%e5%90%91%e9%87%8f%e5%8c%96-1" class="header-anchor"></a>1.2 为什么要并行或向量化
</h2><h3 id="划线评论-2"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-2" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 现实世界中人类对计算能力的需求永无止境。  ^6733360-7PVFmQQqk
- 💭 算力需求无止境
- ⏱ 2024-03-24 13:36:36</p>
</blockquote>
<h3 id="划线评论-3"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-3" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 现代的GCC能够向量化和并行一些非常简单的代码，但是对于复杂一些的程序基本上无能为力。实际上，即使是简单的代码，自动向量化或并行的性能也很难做到完美（通常性能比手工编写的要差很多）。  ^6733360-7PVFpyWDH
- 💭 猜测编译器和芯片自动向量化能力不高
- ⏱ 2024-03-24 13:37:16</p>
</blockquote>
<h2 id="16-并行硬件平台-1"><a href="#16-%e5%b9%b6%e8%a1%8c%e7%a1%ac%e4%bb%b6%e5%b9%b3%e5%8f%b0-1" class="header-anchor"></a>1.6 并行硬件平台
</h2><h3 id="划线评论-4"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-4" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 为了减小使用SIMD指令的复杂度，Intel寄希望于编译器，实际上Intel的编译器向量化能力非常不错，但是通常手工编写的向量代码性能会更好。在MIC上编程时，软件开发人员的工作由显式使用向量指令转化为改写C代码和增加编译制导语句以让编译器产生更好的向量指令。  ^6733360-7PVUh7RU0
- 💭 软件的空间
- ⏱ 2024-03-24 17:24:14</p>
</blockquote>
<h2 id="17-向量化和多核技术不是万能的-1"><a href="#17-%e5%90%91%e9%87%8f%e5%8c%96%e5%92%8c%e5%a4%9a%e6%a0%b8%e6%8a%80%e6%9c%af%e4%b8%8d%e6%98%af%e4%b8%87%e8%83%bd%e7%9a%84-1" class="header-anchor"></a>1.7 向量化和多核技术不是万能的
</h2><h3 id="划线评论-5"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-5" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 对于软件开发人员来说，一些问题很容易向量化和并行，但是也有一些不行；有些问题适合向量化和并行，但是程序却不容易编写。很难将算法划分为几百、几千个控制流，因为人脑很难维护这些控制流的状态空间。实际上自动向量化和自动并行化是解决这些问题的首选（软件开发人员编写串行代码，编译器或硬件给多个处理器有效地分发指令），但是现在的自动向量化和自动并行化工具仍旧非常弱。  ^6733360-7PVUDEGVd
- 💭 编译器是未来
- ⏱ 2024-03-24 17:29:47</p>
</blockquote>
<h2 id="21-指令级并行-1"><a href="#21-%e6%8c%87%e4%bb%a4%e7%ba%a7%e5%b9%b6%e8%a1%8c-1" class="header-anchor"></a>2.1 指令级并行
</h2><h3 id="划线评论-6"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-6" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 乱序执行需要在执行指令前知道指令之间的依赖关系，如果两条指令之间有依赖，那么这两条指令就不能乱序执行。现代处理器对乱序执行有不同程度的支持，比如大多数的Intel X86桌面处理器和服务器处理器上都具有重排缓冲区（ReOrder Buffer，ROB），并且具有远多于逻辑寄存器数量的物理寄存器以支持寄存器重命名。  ^6733360-7PVX0vRtn
- 💭 有依赖就不能乱序执行
- ⏱ 2024-03-24 18:05:57</p>
</blockquote>
<h3 id="划线评论-7"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-7" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 许多处理器支持一个周期发射2条或多条指令，但是多条指令要满足一条条的条件，比如有些处理器要求没有依赖关系、有些处理器只允许访存指令和计算指令同时发射，而Intel Xeon PHI处理器两个周期可以为一个线程发射两条指令，但是这两条指令要没有背靠背的依赖。  ^6733360-7PVXHfoNZ
- 💭 估计NPU也有要求
- ⏱ 2024-03-24 18:16:28</p>
</blockquote>
<h2 id="22-向量化并行-1"><a href="#22-%e5%90%91%e9%87%8f%e5%8c%96%e5%b9%b6%e8%a1%8c-1" class="header-anchor"></a>2.2 向量化并行
</h2><h3 id="划线评论-8"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-8" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 使用SIMD指令要求开发人员非常熟悉指令的类型、吞吐量和延迟。因为不同的处理器对SIMD指令的支持程度不同，这不但表现在指令类型很不相同，还表现在同一指令在不同的架构处理器上的延迟和吞吐量可能也不相同，或者某些指令存在某些未公开的性能缺陷。  ^6733360-7PVXV79r5
- 💭 不是每条指令都是高性能的
- ⏱ 2024-03-24 18:19:53</p>
</blockquote>
<h3 id="划线评论-9"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-9" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 SIMT指定了逻辑向量宽度，而隐藏了物理向量宽度，软件开发人员依据逻辑向量宽度来编写代码，这提高了代码性能的可移植性。比如AMD GCN，其逻辑向量宽度为256字节，而物理向量宽度为64字节，如果AMD为了性能将其物理向量宽度改为128字节（不改变其他条件），那么为AMD GCN架构编写的代码不用修改，在物理向量长度增加后的架构上其性能也会得到相应的提升。而在支持AVX指令集的硬件上运行使用SSE指令集编写的程序却不能得到相应的性能提升。  ^6733360-7PVY39OY9
- 💭 抽象更好？
- ⏱ 2024-03-24 18:21:52</p>
</blockquote>
<h2 id="24-缓存-1"><a href="#24-%e7%bc%93%e5%ad%98-1" class="header-anchor"></a>2.4 缓存
</h2><h3 id="划线评论-10"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-10" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 软件开发人员应当意识到：对于性能限制在内存/缓存上的程序来说，缓存能够显著增加程序的实际性能，因此要编写缓存友好的代码，同时在多核的条件下要注意避免伪共享问题导致的性能损失。  ^6733360-7PVYpLgFo
- 💭 编写缓存友好程序
- ⏱ 2024-03-24 18:27:26</p>
</blockquote>
<h3 id="划线评论-11"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-11" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 由于处理器具有多级缓存，那么如何保证缓存中的数据和内存中的数据是一致的，这由处理器的缓存一致性协议来保证。  ^6733360-7PVYtpN9w
- 💭 Cache一致性概念
- ⏱ 2024-03-24 18:28:20</p>
</blockquote>
<h3 id="划线评论-12"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-12" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 典型的硬件指令预取会在缓存因失效而从内存载入一个缓存线的同时，请求紧随其后的另一个缓存线  ^6733360-7PW5ybgVf
- 💭 cache line预取
- ⏱ 2024-03-24 20:16:23</p>
</blockquote>
<h3 id="划线评论-13"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-13" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 缓存以缓存线为基本单位读写，每条缓存线可保存L（现代机器上L一般为64）个字节。数据在缓存间上下移动时以缓存线为单位，即不可能出现只加载半条缓存线的情况。对于软件开发人员来说，缓存的总量和缓存线的大小相当重要，另外缓存的层次结构、缓存映射策略也需要了解。  ^6733360-7PW5DICaQ
- 💭 cache line非常重要
- ⏱ 2024-03-24 20:17:45</p>
</blockquote>
<h2 id="25-虚拟存储器和tlb-1"><a href="#25-%e8%99%9a%e6%8b%9f%e5%ad%98%e5%82%a8%e5%99%a8%e5%92%8ctlb-1" class="header-anchor"></a>2.5 虚拟存储器和TLB
</h2><h3 id="划线评论-14"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-14" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 虚拟存储器使用虚拟地址寻址，而物理存储器使用物理地址寻址，因此硬件执行访存操作时需要将虚拟地址翻译成物理地址，操作系统和存储器管理单元（Memory Management Unit，MMU）硬件配合来完成这一工作。由于从虚拟地址到物理地址的转换非常耗时，处理器和操作系统主要使用了两个优化来减少转换次数。  ^6733360-7PW60O4Xh
- 💭 虚拟地址到物理地址转换非常耗时
- ⏱ 2024-03-24 20:23:26</p>
</blockquote>
<h3 id="划线评论-15"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-15" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 ·TLB，TLB用于缓存已经翻译的虚拟地址，通过利用访问页的局部性来减少翻译次数。由于虚拟地址和物理地址之间的转换非常耗时且TLB不命中的代价很大，因此TLB的映射策略通常设计为全相联。实际上，在一些硬件上，缓存层次中也使用多层TLB来减少地址翻译代价。一些需要对多维数据进行访问的程序在大数据量的情况下，通常存在TLB不命中的情况。  ^6733360-7PW6lItnS
- 💭 tlb的具体含义
- ⏱ 2024-03-24 20:28:35</p>
</blockquote>
<h2 id="31-算法分析的性能度量标准-1"><a href="#31-%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90%e7%9a%84%e6%80%a7%e8%83%bd%e5%ba%a6%e9%87%8f%e6%a0%87%e5%87%86-1" class="header-anchor"></a>3.1 算法分析的性能度量标准
</h2><h3 id="划线评论-16"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-16" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 对于具体的代码而言，依据在某种处理器上运行的性能瓶颈不同而采用实现复杂度的不同方面来度量。对于一个计算限制的算法，应当使用计算复杂度和指令复杂度；而对于一个存储器限制的算法，应当使用访存复杂度来分析。  ^6733360-7PW6Xzxkk
- 💭 不同的bound情况使用不同的指标衡量
- ⏱ 2024-03-24 20:37:54</p>
</blockquote>
<h3 id="划线评论-17"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-17" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 由于各种现代向量多核处理器具有不同的特点，比如X86CPU是为延迟优化的，在考虑计算复杂度时权重应该以延迟为准；而GPU是为吞吐量优化的，考虑计算复杂度时权重应当以吞吐量倒数为准。但这并不绝对，一些优化良好的X86 CPU代码有很好的指令级并行能力，也应当从吞吐量倒数考虑。  ^6733360-7PW72gXr9
- 💭 借鉴这一思路，比较好的计算复杂度应该以吞吐量为准
- ⏱ 2024-03-24 20:39:04</p>
</blockquote>
<h3 id="划线评论-18"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-18" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 O（2n×α+β×n+γ×n）  ^6733360-7PW7e5Q8m
- 💭 这个没有考虑到加载和计算之间匹配的问题
- ⏱ 2024-03-24 20:41:59</p>
</blockquote>
<h3 id="划线评论-19"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-19" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 从某种程度上说，指令复杂度的分析是人的大脑对程序指令在具体处理器上执行的分析，因此非常复杂和困难，也更容易出错，笔者通常使用一些编译器工具协助分析。  ^6733360-7PW7QUAmx
- 💭 指令复杂度类似于vf的复杂度，更复杂更容易出错
- ⏱ 2024-03-24 20:51:32</p>
</blockquote>
<h3 id="划线评论-20"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-20" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 通常使用执行代码关键路径所需要的时钟周期数来表示指令复杂度  ^6733360-7PW7YTZYn
- 💭 找出最长的关键路径非常关键
- ⏱ 2024-03-24 20:53:30</p>
</blockquote>
<h3 id="划线评论-21"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-21" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 但对于顶级代码优化人员来说，指令复杂度是优化的终极法宝。代码优化的过程，就是指令复杂度降低的过程。  ^6733360-7PW83RxH8
- 💭 当前的优化是非常重要技能
- ⏱ 2024-03-24 20:54:44</p>
</blockquote>
<h3 id="划线评论-22"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-22" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 指令复杂度分析通常关注耗时最长的循环，通常分析此循环内部的指令数量，不同指令是否能够同时发射、执行等，通过这些信息来重构代码，以便生成的指令能够更好地在处理器上执行。  ^6733360-7PW85KzE3
- 💭 指令复杂度分析的有效手段和方法
- ⏱ 2024-03-24 20:55:11</p>
</blockquote>
<h2 id="32-程序和指令的性能度量标准-1"><a href="#32-%e7%a8%8b%e5%ba%8f%e5%92%8c%e6%8c%87%e4%bb%a4%e7%9a%84%e6%80%a7%e8%83%bd%e5%ba%a6%e9%87%8f%e6%a0%87%e5%87%86-1" class="header-anchor"></a>3.2 程序和指令的性能度量标准
</h2><h3 id="划线评论-23"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-23" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 通常程序中最耗时的部分就是小循环，因此如何表征对循环的优化效果就非常重要  ^6733360-7PW8AsZdn
- 💭 为什么小循环最耗时？因为和大循环相比，启动时间相同，计算时间比较短，没法隐藏启动时间？
- ⏱ 2024-03-24 21:02:45</p>
</blockquote>
<h3 id="划线评论-24"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-24" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 假设测试发现上面的代码段在某个具体配置下耗时T个时钟周期，那么其CPI为：T/num  ^6733360-7PW8DJVpO
- 💭 这是衡量vf的非常重要的性能指标
- ⏱ 2024-03-24 21:03:34</p>
</blockquote>
<h3 id="划线评论-25"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-25" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 循环的CPI通常由其依赖链（指整个循环中相互依赖的运算或访存，也称为关键路径）决定，减少循环CPI的过程就是减小或去掉循环内依赖链的过程。  ^6733360-7PW8PcEF7
- 💭 非常重要的想法，也是vf的优化手段
- ⏱ 2024-03-24 21:06:23</p>
</blockquote>
<h3 id="划线评论-26"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-26" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 循环的CPI通常由其依赖链（指整个循环中相互依赖的运算或访存，也称为关键路径）决定，减少循环CPI的过程就是减小或去掉循环内依赖链的过程。  ^6733360-7PW8NsoU3
- 💭 非常重要的思想
- ⏱ 2024-03-24 21:05:57</p>
</blockquote>
<h3 id="划线评论-27"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-27" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 相对指令的整体延迟来说，还需要关注指令发射时间，因为在现在的乱序执行的硬件上，发射时间也是指令性能能够达到的一个上限。  ^6733360-7PWa4l9bP
- 💭 发射对应的应该是commit
- ⏱ 2024-03-24 21:25:23</p>
</blockquote>
<h3 id="划线评论-28"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-28" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 由于对吞吐量优化的技术不要求尽快得到数据，而要求在单位时间做更多的运算，因此硬件往往采用更多频率更低的计算单元，采用“人海战术”取胜。由于这种小而简单的单元工作频率和电压都较低，因此耗能少，能够在给定的能耗下集成更多的核心，进而在不增加功耗的前提下提高整体的吞吐量。目前无论是X86 CPU还是GPU都采用了这种思路来提高性能。  ^6733360-7PW9JCcF3
- 💭 使用基于寄存器的访问，最大的好处和收益应该是延迟更小，吞吐量更大
- ⏱ 2024-03-24 21:20:17</p>
</blockquote>
<h3 id="划线评论-29"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-29" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 吞吐量倒数表示在某个架构上，某种指令的吞吐量的倒数。吞吐量倒数表示平均下来某种指令最少需要的时钟周期数，是一种下限，而延迟则是一个上限  ^6733360-7PW9NeLaJ
- 💭 是一个非常不错的视角，吞吐量倒数是上限，延迟是下限
- ⏱ 2024-03-24 21:21:10</p>
</blockquote>
<h3 id="划线评论-30"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-30" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 little定律认为要发挥硬件执行某种指令的计算能力所需要的并行度等于指令的延迟乘以指令的吞吐量。并行度指没有依赖的指令数量，  ^6733360-7PWCIbPDo
- 💭 以带宽为瓶颈锁定实际的计算性能
- ⏱ 2024-03-25 04:42:43</p>
</blockquote>
<h2 id="42-应用级别-1"><a href="#42-%e5%ba%94%e7%94%a8%e7%ba%a7%e5%88%ab-1" class="header-anchor"></a>4.2 应用级别
</h2><h3 id="划线评论-31"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-31" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 fast-math表示对超越函数使用更快但精度低一些的版本；unroll-all-loops表示使用循环展开；avx表示使用avx指令集向量化；tune=native表示为当前编译的处理器做优化。  ^6733360-7PWS4q1VM
- 💭 vdiv和vrec
- ⏱ 2024-03-25 08:37:14</p>
</blockquote>
<h3 id="划线评论-32"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-32" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 如果指针a、b指向不同的内存地址，也就是说a、b之间不存在存储器别名，那么函数f可简化为：  ^6733360-7PWSdodxx
- 💭 将要读取的指针取出放在临时变量里面
- ⏱ 2024-03-25 08:39:26</p>
</blockquote>
<h2 id="43-算法级别-1"><a href="#43-%e7%ae%97%e6%b3%95%e7%ba%a7%e5%88%ab-1" class="header-anchor"></a>4.3 算法级别
</h2><h3 id="划线评论-33"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-33" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 对优化前代码来说，在内层循环上，相邻循环体内访问a的地址相隔N个元素，在N比较大的情况下，可能会存在满不命中和冲突不命中的情况，故访问a的局部性很差；对优化后的代码来说，在内层循环上，相邻循环体内访问a的地址相隔1个元素，加载到缓存线中的数据会在随后使用，从这一点来说，访问a的局部性非常好  ^6733360-7PWSmJS96
- 💭 读取地址连续
- ⏱ 2024-03-25 08:41:45</p>
</blockquote>
<h3 id="划线评论-34"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-34" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 由于计算机图像学中需要对大量的像素做插值运算，故GPU的纹理设计时就支持硬件插值运算，  ^6733360-7PWT3gasr
- 💭 gpu纹理计算有专门的双线性插值
- ⏱ 2024-03-25 08:52:13</p>
</blockquote>
<h2 id="44-函数级别-1"><a href="#44-%e5%87%bd%e6%95%b0%e7%ba%a7%e5%88%ab-1" class="header-anchor"></a>4.4 函数级别
</h2><h3 id="划线评论-35"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-35" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 如果内联后的函数比较长，就可能会增加寄存器的压力。如果函数内有分支，内联后会对指令流水线产生不利的影响，因此通常对少于10行且其中代码没有分支的函数内联。  ^6733360-7PWTQICUl
- 💭 为什么内联不宜过长
- ⏱ 2024-03-25 09:04:24</p>
</blockquote>
<h2 id="45-循环级别-1"><a href="#45-%e5%be%aa%e7%8e%af%e7%ba%a7%e5%88%ab-1" class="header-anchor"></a>4.5 循环级别
</h2><h3 id="划线评论-36"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-36" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 展开循环不但减少了每次的判断数量和循环变量改变的计算次数，更能够增加处理器流水线执行的性能。通常展开小循环且内部没有判断的会获益，展开大循环则可能会因为导致寄存器溢出而导致性能下降，而展开内部有判断的循环会增加分支预测的开销也可能会导致性能下降。  ^6733360-7PWTVQbk3
- 💭 循环展开的门道，小循环 + 内部没有判断分支最佳
- ⏱ 2024-03-25 09:05:39</p>
</blockquote>
<h3 id="划线评论-37"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-37" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 循环合并不但可以减少判断次数，还能够增加指令级并行能力（能够合并的两个循环内代码通常没有依赖）  ^6733360-7PWU2PHTU
- 💭 指令集并行的前提是循环没有依赖
- ⏱ 2024-03-25 09:07:23</p>
</blockquote>
<h3 id="划线评论-38"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-38" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 如果大循环（循环体内代码比较多、执行时间长）存在寄存器溢出的情况，那么将大循环拆分为几个小循环，就能够提高寄存器的使用，而且能够为循环展开等技术的使用提供条件。  ^6733360-7PWU9tSEA
- 💭 循环内部的代码不宜过大也不宜过小，一般与芯片的中的寄存器的数量相关
- ⏱ 2024-03-25 09:09:01</p>
</blockquote>
<h2 id="46-语句级别-1"><a href="#46-%e8%af%ad%e5%8f%a5%e7%ba%a7%e5%88%ab-1" class="header-anchor"></a>4.6 语句级别
</h2><h3 id="划线评论-39"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-39" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 在不考虑编译器优化的前提下，代码清单4-21只需要计算一次分支，而代码清单4-20要计算len次。  ^6733360-7PXjPuCcN
- 💭 分支判断越少越好
- ⏱ 2024-03-25 15:41:05</p>
</blockquote>
<h2 id="47-指令级别-1"><a href="#47-%e6%8c%87%e4%bb%a4%e7%ba%a7%e5%88%ab-1" class="header-anchor"></a>4.7 指令级别
</h2><h3 id="划线评论-40"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-40" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 整数乘以一个整数可以转变成左移操作，如果乘数是常量，编译器会自动执行这种转换。整数除法和模余是非常耗时的，要少使用，如果是除以或模2的幂，则可转变为右移或位与运算。  ^6733360-7PXtWAjUz
- 💭 整数除法时延差看来是有名的
- ⏱ 2024-03-25 18:15:31</p>
</blockquote>
<h2 id="51-指令级依赖-1"><a href="#51-%e6%8c%87%e4%bb%a4%e7%ba%a7%e4%be%9d%e8%b5%96-1" class="header-anchor"></a>5.1 指令级依赖
</h2><h3 id="划线评论-41"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-41" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 为了既提高硬件利用效率又保证提供必需的带宽，许多处理器的缓存层次（从寄存器到内存）都采用了存储体（Bank）的方式组织，其中每个存储体可同时、独立地提供带宽  ^6733360-7PYAw8bfC
- 💭 类似于ub中的bank
- ⏱ 2024-03-26 11:42:33</p>
</blockquote>
<h3 id="划线评论-42"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-42" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 在ARM A15处理器上，其NEON指令集支持的32位浮点乘加向量指令延迟大约为8个周期，吞吐量为每核心每周期1个，故需要的并行度为8；如果处理器不能提供足够的寄存器，那么就需要从一级缓存中读取，此时寄存器的数量和一级缓存的带宽就有可能成为结构化的依赖。  ^6733360-7PYAAKvQQ
- 💭 并行度为8是一次最多发射8条指令？
- ⏱ 2024-03-26 11:43:42</p>
</blockquote>
<h3 id="划线评论-43"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-43" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 解决写后写依赖的方法非常简单：如上例只需要将S5中的AREA变量重新命名为ar，同时将S4的r变量重新命名为p即可。现在的编译器能够自动进行这种优化，而且一些处理器（如Intel X86）硬件上提供了寄存器重命名机制来帮助处理器在运行时处理这种依赖关系。  ^6733360-7PYAL1hOY
- 💭 写后写和读后写都是寄存器重命名
- ⏱ 2024-03-26 11:46:14</p>
</blockquote>
<h2 id="53-寄存器重命名-1"><a href="#53-%e5%af%84%e5%ad%98%e5%99%a8%e9%87%8d%e5%91%bd%e5%90%8d-1" class="header-anchor"></a>5.3 寄存器重命名
</h2><h3 id="划线评论-44"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-44" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 只是受限于处理器指令集体系结构规定的逻辑寄存器数量的限制，汇编程序能够使用的寄存器是非常有限的，因此编译器很多时候只能是无能为力。  ^6733360-7PWUg8Xzu
- 💭 编译器受限于指令集体系中的逻辑寄存器的数量，所以对于OOO无能为力
- ⏱ 2024-03-25 09:10:39</p>
</blockquote>
<h3 id="划线评论-45"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-45" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 由于不能直接在汇编指令中看到物理寄存器，因此代码优化人员无法确定他的优化的确能够帮助处理器更好地进行寄存器重命名工作。  ^6733360-7PWUlmFsr
- 💭 如何更好的利用OoO，芯片需要提供给软件开发人员必要的编程指导
- ⏱ 2024-03-25 09:11:57</p>
</blockquote>
<h3 id="划线评论-46"><a href="#%e5%88%92%e7%ba%bf%e8%af%84%e8%ae%ba-46" class="header-anchor"></a>划线评论
</h3><blockquote>
<p>📌 由于不能直接在汇编指令中看到物理寄存器，因此代码优化人员无法确定他的优化的确能够帮助处理器更好地进行寄存器重命名工作。  ^6733360-7PWUj2CFX
- 💭 也是一个原因
- ⏱ 2024-03-25 09:11:22</p>
</blockquote>
<h1 id="本书评论"><a href="#%e6%9c%ac%e4%b9%a6%e8%af%84%e8%ae%ba" class="header-anchor"></a>本书评论
</h1>
</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css"integrity="sha256-J&#43;iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s="crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js"integrity="sha256-InsNdER1b2xUewP&#43;pKCUJpkhiqwHgqiPXDlIk7GzBu4="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js"integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI="crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
	const mainArticleElement = document.querySelector(".main-article");
        renderMathInElement(mainArticleElement, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>

    
</article>

    

    

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "bugxch" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2016 - 
        
        2024 bugxch
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.29.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.87d72694fb97c84cb5cbf9b1a64d476a38e04a5706618a6ffe5b89c7db00488f.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
